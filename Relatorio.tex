%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Universidade Federal de Santa Catarina             
% Biblioteca Universitária                     
%----------------------------------------------------------------------
% Exemplo de utilização da documentclass ufscThesis
%----------------------------------------------------------------------                                                           
% (c)2010 Roberto Simoni (roberto.emc@gmail.com)
%         Carlos R Rocha (cticarlo@gmail.com)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{ufscThesis} % Definicao do documentclass ufscThesis

%----------------------------------------------------------------------
% Pacotes usados especificamente neste documento
\usepackage{graphicx} % Possibilita o uso de figuras e gráficos
\usepackage{color, colortbl}    % Possibilita o uso de cores no documento
\usepackage{multirow}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage[labelsep=endash]{caption}
\usepackage{mathtools}
\usepackage{listings}
\usepackage[portuguese, lined, linesnumbered, boxed,ruled,commentsnumbered]{algorithm2e}
\usepackage{float}
\usepackage{lmodern}
\usepackage[T1]{fontenc}

\definecolor{BLUE}{rgb}{0, 0, 1}
\definecolor{BLACK}{rgb}{0, 0, 0}

\everymath{\color{green!20!black}}
\everydisplay{\color{green!20!black}}
\DeclareTextFontCommand{\emph}{\scshape}



%----------------------------------------------------------------------
% Comandos criados pelo usuário
\newcommand{\afazer}[1]{{\color{red}{#1}}} % Para destacar uma parte a ser trabalhada
\newcommand{\citacaoAzul}[1]{{\color{blue!40!black}{\cite{#1}}}}
%\newcommand{\citacaoAzul}[1]{\cite{#1}}

\newcommand{\citacaoInline}[1]{{\color{blue!40!black}{\citeonline{#1}}}}

\newcommand{\emfase}[1]{\emph{#1}}

%----------------------------------------------------------------------
% Identificadores do trabalho
% Usados para preencher os elementos pré-textuais
\instituicao[a]{Universidade Federal de Santa Catarina} % Opcional
\departamento[a]{Departamento de Informática e Estatística}
\curso[o]{Curso de Bacharelado em Ciências da Computação}
%\documento[a]{TCC} % Opcional (Tese é o padrão)
\titulo{Análise de \textit{Timing} Estática e a Avaliação do Impacto do Atraso das Interconexões em Circuitos Digitais}
%\subtitulo{Considerando Atraso de Interconexões} % Opcional
\autor{Chrystian de Sousa Guth}
\grau{Bacharel em Ciências da Computação}
\local{Florianópolis - Santa Catarina} % Opcional (Florianópolis é o padrão)
\data{09}{Novembro}{2013}
\orientador[Orientador]{M.Sc. Vinícius dos Santos Livramento}
\coorientador[Coorientador]{Prof. Dr. José Luís Almada Güntzel}
\coordenador[Coordenador]{Prof. Dr. Renato Cislaghi}

\numerodemembrosnabanca{3} % Isso decide se haverá uma folha adicional
\orientadornabanca{sim} % Se faz parte da banca definir como sim
\coorientadornabanca{sim} % Se faz parte da banca definir como sim
%\bancaMembroA{Vinicius dos Santos Livramento} %Nome do presidente da banca
\bancaMembroB{Dr. Renan Alves Fonseca}      % Nome do membro da Banca
%\bancaMembroC{Prof. Dr. Luiz Cláudio Villar dos Santos}     % Nome do membro da Banca
%\bancaMembroD{Quarto membro}       % Nome do membro da Banca
%\bancaMembroE{Prof. quinto membro}       % Nome do membro da Banca
%\bancaMembroF{Prof. sexto membro}        % Nome do membro da Banca
%\bancaMembroG{Prof. sétimo membro}       % Nome do membro da Banca


\textoResumo {
Análise de \textit{timing} estática (\textit{STA: Static Timing Analysis}) é a técnica mais utilizada para estimar o atraso de circuitos digitais durante o fluxo de síntese física. Com o advento das tecnologias CMOS (Complementary Metal-Oxide Semiconductor) nanométricas, o atraso das interconexões passou a ser dominante em relação ao atraso das portas lógicas e por este motivo, não pode mais ser desprezado. A técnica de Elmore, baseada no primeiro momento da resposta ao impulso é amplamente utilizada para se calcular os atrasos das interconexões, porém, pode ser imprecisa por desconsiderar o efeito de \textit{resistive shielding}. Algumas técnicas, modificam a técnica de Elmore, a fim de contornar o problema do efeito de \textit{resistive shielding}, obtendo resultados mais precisos, mantendo um baixo custo computacional. A consideração do efeito de \textit{resistive shielding} reflete na implementação de uma técnica para obtenção da capacitância efetiva em cada segmento da interconexão, impactando também no atraso da sua porta lógica \textit{driver}. Este trabalho tem por objetivo implementar e validar uma ferramenta de STA, que realiza o cálculo dos atrasos das interconexões, utilizando uma variação da técnica de Elmore que captura o efeito do \textit{resistive shielding}. 

}
\palavrasChave {Automação de Projeto Eletrônico (EDA), Biblioteca \textit{Standard Cell}, Análise de \textit{Timing} Estática \textit{(STA)}, \textit{Complementary Metal-Oxide Semiconductor}}

\textAbstract {Here is written the abstract of the document}

\keywords {key 1. key 2. ... key n.}

%----------------------------------------------------------------------
% Início do documento                                
\begin{document}
%--------------------------------------------------------
% Elementos pré-textuais
\capa  
\folhaderosto[comficha] % Se nao quiser imprimir a ficha, é só não usar o parâmetro
\folhaaprovacao
\paginadedicatoria
\paginaagradecimento
% \paginaepigrafe
\paginaresumo
\paginaabstract
\listadefiguras
\listadetabelas 
% \listadeabreviaturas
% \listadesimbolos
\sumario
%--------------------------------------------------------
% Elementos textuais
\chapter{Introdução}
	
Este capítulo tem por objetivo, apresentar uma visão geral sobre o fluxo de projeto \textit{standard cell} e a importância da análise de \textit{timing} estática (\textit{STA: Static Timing Analysis}) no desenvolvimento de circuitos digitais. Serão apresentadas também a motivação e a justificativa deste trabalho.

\section{Fluxo de Projeto \textit{Standard Cell}}

O crescimento da complexidade dos circuitos digitais contemporâneos\footnote{Um processador para \textit{desktop} desenvolvido no ano de 2008 tem cerca de 731 milhões de transistores, excluindo a área de memória \citacaoAzul{Intel08}.} e a necessidade de um \textit{time-to-market} (tempo de entrega ao mercado) curto faz com que o projeto de tais circuitos adote o fluxo \textit{standard cell} (Figura \ref{fig:fluxo_standard_cell}).

No fluxo \textit{standard cell} as portas lógicas são desenvolvidas e verificadas previamente em uma dada tecnologia. Essas células \footnote{Célula é a instância de \textit{layout} para a implementação física de uma porta lógica.} são catalogadas com suas diversas características elétricas em uma biblioteca de células, sendo reutilizadas em diversos projetos que usem a mesma tecnologia. O reuso amortiza o custo dos projetos inseridos neste nodo tecnológico e possibilita um \textit{time-to-market} mais curto.

O fluxo \textit{standard cell} pode ser subdividido em etapas, e ao decorrer dessas etapas, a análise de \textit{timing} pode ser requisitada milhares de vezes. De acordo com \citacaoInline{BhaskerChadha09}, essas são algumas das etapas importantes no fluxo \textit{standard cell}:


\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.8\linewidth]{imagens/fluxo_standard_cell.pdf}
\caption{Fluxo de projeto \textit{Standard Cell}. Adaptado de \citacaoAzul{BhaskerChadha09}.}
\label{fig:fluxo_standard_cell}
\end{center}
\end{figure}

\begin{itemize}
\item \textbf{Síntese: } Responsável por criar uma representação em nível de portas lógicas, a partir de uma descrição no nível de transferência entre registradores (\textit{RTL: Register Transfer Level}). A partir desta etapa, a análise de \textit{timing} estática (\textit{STA: Static Timing Analysis}) é utilizada, para estimar as características \textit{temporais} do circuito;

\item \textbf{Otimização Lógica: } Responsável por minimizar a lógica do circuito sintetizado. A análise de \textit{timing} estática pode ser realizada antes desta etapa, para verificar os caminhos de maior atraso, também chamados de caminho crítico. Se a análise de \textit{timing} for realizada depois desta etapa, o objetivo é identificar quais caminhos ainda precisam ser otimizados ou identificar os caminhos críticos;

\item \textbf{Posicionamento: } Define a localização espacial dos \textit{layouts} das células. Antes dessa etapa, modelos de interconexão ideais são adotados, pois ainda não se possui as informações necessárias de posicionamento. Uma maneira alternativa para se modelar as interconexões é utilizar um modelo de \textit{wireload}, que estima o tamanho das interconexões de acordo com o seu número de destinos, ou \textit{fanouts};

\item \textbf{Síntese da Árvore de \textit{Clock}: } No início da síntese física, as árvores dos relógios são consideradas como ideais, ou seja, não possuem atraso de propagação. O objetivo desta etapa é minimizar o \textit{clock skew}, que é a diferença entre os tempos de chegada do sinal de relógio nas entradas dos registradores. A análise de \textit{timing} estática é importante nesta etapa para avaliar essas diferenças nos tempos de chegada.

\item \textbf{Roteamento: } Responsável por criar as conexões entre as diferentes células incluídas no projeto, utilizando as diferentes camadas de metal. Antes desta etapa, as capacitâncias e as resistências parasitas associadas ao roteamento são estimadas a partir do comprimento das conexões e do número de vias e de contatos utilizados.
\end{itemize}

Os projetos de circuitos digitais no fluxo \textit{standard cell} são realizados visando, além das funcionalidades requisitadas, a operação em uma frequência especificada. Por isso, diversas otimizações são efetuadas ao longo do fluxo, para que tais funcionalidades consigam ser realizadas na frequência definida. Nas primeiras etapas de um projeto no fluxo \textit{standard cell}, apenas as questões relacionadas à funcionalidade do projeto são verificadas, pois ainda não estão disponíveis informações detalhadas referentes ao comportamento elétrico do circuito.

\section{Motivação}
%otimizações		como \textit{gate sizing} \citacaoAzul{Livramento13} \citacaoAzul{Hu12} \citacaoAzul{Mohammad12}
% \textit{Placement} \citacaoAzul{Shahookar91} 
No fluxo \textit{standard cell}, a partir do RTL, uma série otimizações são realizadas ao decorrer de suas etapas. Como consequência dessas otimizações, as topologias das interconexões se alteram, necessitando ao decorrer do fluxo, diversas avaliações de suas informações temporais.

Durante as otimizações nas etapas iniciais do fluxo (\textit{pre-layout}), a análise de \textit{timing} é requisitada milhares de vezes, sendo assim necessário que a ferramenta de análise de \textit{timing} tenha o melhor desempenho possível. Como as informações relacionadas ao aspecto físico do circuito, como posicionamento \citacaoAzul{Wang2000} e roteamento \citacaoAzul{Ryzhenko2012} ainda não são definidas com precisão nas etapas iniciais, essas informações são aproximadas e a ferramenta de análise de \textit{timing} fornece dados pessimistas sobre o \textit{timing} do circuito.

Já nas etapas finais (\textit{pós-layout}), mais próximas da síntese física, a análise de \textit{timing} precisa ser a mais precisa possível, porém, a modelagem dos elementos dos circuitos digitais torna-se mais complexa, diminuindo o desempenho da ferramenta.

Como as informações de \textit{timing} precisam ser avaliadas centenas ou milhares de vezes durante os processos de otimização, ferramentas de análise de \textit{timing} eficientes e escaláveis precisam ser desenvolvidas e aperfeiçoadas para acompanhar a evolução da tecnologia \textit{CMOS} (\textit{Complementary Metal-Oxide Semiconductor}).
		
%Em diversos sistemas projetados atualmente, cerca de 50\% a 70\% do ciclo de relógio é ``consumido'' pelo atraso de propagação de suas interconexões \citacaoAzul{Cong96}. Nas tecnologias com alta escala de integração (\textit{VLSI: Very-large-scale integration}) atuais, onde diversas otimizações tem por objetivo reduzir a resistência dos \textit{drivers}, as interconexões passam a ser cada vez mais impactantes no desempenho do circuito digital.

	\section{Justificativa}

Diversas otimizações são realizadas no decorrer do fluxo de projeto \textit{standard cell} e o uso de ferramentas para a automação de projeto eletrônico (\textit{EDA: Electronic design automation}) é indispensável em suas diferentes etapas. A inexistência de ferramentas de análise de \textit{timing} estática precisas de domínio público e a restrição no acesso à ferramentas industriais (devido ao alto custo de suas licenças), resulta em um problema de infraestrutura de pesquisa. Assim, este trabalho terá como resultado uma alternativa de ferramenta de análise de \textit{timing} para projetistas de circuitos digitais, bem como uma infraestrutura realista e precisa para desenvolvedores de ferramentas, que necessitam da análise de \textit{timing}, em alguma etapa do fluxo de projeto \textit{standard cell}.

\section{Objetivos}

\subsection{Objetivo Geral}

Este trabalho tem por objetivo o projeto, avaliação, validação e documentação de uma ferramenta de análise de \textit{timing} voltada para o fluxo \textit{standard cell}. 

\subsection{Objetivos Específicos}

\begin{enumerate}

\item \label{objetivos:lumped}Implementação do modelo de interconexão com capacitância concentrada, desprezando-se o impacto das resistências; 

\item \label{objetivos:elmore} Implementação da técnica de Elmore para cálculo do atraso das interconexões baseando-se em um modelo de interconexão RC concentrado;

\item  \label{objetivos:puri} Implementação da técnica para cálculo do atraso de interconexões utilizando a abordagem de capacitância efetiva; 

\item Construção de uma ferramenta de análise de \textit{timing} estática incluindo as funcionalidades descritas nos objetivos \ref{objetivos:lumped}, \ref{objetivos:elmore} e \ref{objetivos:puri}, bem como sua validação perante uma ferramenta de análise de \textit{timing} industrial.

\end{enumerate}

\section{Escopo}

Este trabalho aborda o problema da análise de \textit{timing} estática utilizando técnicas para estimação dos atrasos das interconexões. A análise de \textit{timing} é realizada propagando os atrasos de cada porta lógica em ordem topológica, a fim de estimar o desempenho do circuito. Os modelos de \textit{delay} e \textit{slew} utilizados neste trabalho são os mesmos utilizados no \textit{fluxo standard cell}\footnote{O cálculo dos atrasos das portas lógicas será melhor apresentado na seção \ref{sec:caracteristicas_temporais_portas_logicas}.}.

As interconexões serão modeladas de duas formas:
\begin{itemize}
\item \textbf{Modelo da capacitância concentrada}, impactando apenas nos \textit{atrasos} de seus \textit{drivers};

\item \textbf{Modelo RC concentrado}\footnote{Este modelo pode ser chamado de modelo RC distribuído em alguns trabalhos científicos, como na competição de \textit{sizing} do \textit{ISPD (International Symposium on Physical Design)} de 2013 \citacaoAzul{Contest2013}.}, apresentando também, seus próprios atrasos como impacto no atraso do circuito.
\end{itemize}

Não faz parte do escopo deste trabalho, a consideração dos tempos de \textit{setup} e \textit{hold} das células sequenciais, como os \textit{flip-flops}. Eles serão modelados pelo \textit{timing arc}\footnote{O conceito de \textit{timing arc} será apresentado na seção \ref{sec:caracteristicas_temporais_portas_logicas}.} da entrada de relógio até a saída.

			% \afazer{Talvez tirar a seção Objetivos e colocar essa como objetivos...}

%
%A ferramenta de Análise de \textit{Timing} desenvolvida será capaz de reportar informações de \textit{timing} de um circuito. As portas lógicas serão modeladas utilizando um modelo de atraso não-linear (NLDM: \textit{Non-Linear Delay Model}), onde seus atrasos são caracterizados por \textit{lookup tables}, fornecidas nas bibliotecas \textit{standard cells} atuais. As informações reportadas para as portas lógicas são: \textit{slacks, slews, arrival times}, caminho crítico, total de \textit{slack} negativo e pior \textit{slack}. Essas informações serão explicadas nos Capítulos \ref{cap:conceitos} e \ref{cap:sta}.
%
%Para as interconexões, dois modelos serão implementados: capacitância concentrada e o modelo RC concentrado. Seus atrasos serão calculados utilizando a técnica de \citeonline{Elmore48} e a técnica de capacitância efetiva de  \citeonline{PURI02}.
%			
%Os cada elemento sequencial será tratado como uma saída e uma entrada primária do circuito. Para simplificação do algoritmo de análise de \textit{timing}, tempos de \textit{setup}, \textit{hold} e carga não serão considerados.
%			
%Por fim, a qualidade das informações de \textit{timing} obtidas pela ferramenta serão comparadas com os dados obtidos pela ferramenta industrial PrimeTime \textregistered \ da \citeonline{PrimeTime12}.
		
\section{Organização Deste Trabalho}
Este trabalho está organizado da seguinte forma:

O capítulo \ref{cap:conceitos} apresenta os conceitos básicos essenciais para o entendimento do presente trabalho.

No capítulo \ref{cap:tecnica} será apresentada uma revisão bibliográfica acerca das técnicas utilizadas para cálculo do atraso das interconexões e capacitância efetiva.

Já o capítulo \ref{cap:sta} fala sobre a análise de \textit{timing}, apresentando seus algoritmos e particularidades na implementação.

O capítulo \ref{cap:experimentos} apresenta os experimentos realizados utilizando a ferramenta implementada neste trabalho.

E por fim, as conclusões são apresentadas no capítulo \ref{cap:conclusao}.
\chapter{Conceitos Fundamentais de Circuitos Digitais}
\label{cap:conceitos}

Este capítulo apresenta os conceitos básicos relacionados à temporização e modelagem de circuitos digitais essenciais para o entendimento do presente trabalho. A seção \ref{sec:caracteristicas_temporais_portas_logicas} apresenta as características temporais das portas, assim como os modelos de atraso adotados em fluxo \textit{standard cell}. Os modelos de interconexões e as suas características temporais serão apresentadas nas seções \ref{sec:modelos_interconexoes} e  \ref{sec:caracteristicas_temporais_interconexoes}, respectivamente.

\section{Características Temporais das Portas Lógicas}
\label{sec:caracteristicas_temporais_portas_logicas}

As características temporais do circuito são derivadas das características temporais de suas partes, ou seja, as portas lógicas e as interconexões que o compõem. Para as portas lógicas, as informações a seguir são relevantes \citacaoAzul{Livramento2013}:

\begin{itemize}
\item \textbf{\textit{Timing Arc} (Arco de Tempo):} é um conceito utilizado para associar um pino de entrada de uma porta com a saída dessa mesma porta. Uma porta \textit{NAND} de duas entradas, como a apresentada na Figura \ref{fig:informacoes_temporais_porta_logica} possui dois \textit{timing arcs}: um entre a entrada $a$ e a saída ($a \to o$) e outro entre a entrada $b$ e a saída ($b \to o$). Para elementos sequenciais, como os \textit{flip-flops}, normalmente consideram-se como \textit{timing arcs} as conexões entre o sinal de relógio e as saídas. O arco é chamado \textit{positive unate} se uma transição de subida (descida) na entrada causa uma transição de subida (descida) na saída. Se uma transição de subida (descida) da entrada causa uma transição de descida (subida) na saída, o arco é chamado \textit{negative unate} \citacaoAzul{BhaskerChadha09}.

	\item \textbf{\textit{Delay} (Atraso de Propagação): } é o tempo que o sinal em um pino de saída $o$ leva para atingir um limiar\footnote{Este limiar geralmente é definido nas bibliotecas de célula como sendo 50\% do $Vdd$.} de sua transição total, devido a uma mudança no sinal em um pino de entrada. Se a transição em $o$ for do nível lógico 0 para 1, o atraso é chamado de atraso de subida (\textit{rise delay}), caso o contrário, é chamado de atraso de descida (\textit{fall delay}) (Figura \ref{fig:informacoes_temporais_porta_logica}).
	
	\item \textbf{\textit{Slew} (Tempo de Transição): } é o tempo que um sinal leva para transicionar de uma porcentagem do valor de referência ($V_{dd}$) à outra \citacaoAzul{BhaskerChadha09}\footnote{Nas bibliotecas de células, essas porcentagens geralmente são definidas como 20\% e 80\% ou 10\% e 90\%}. Se a transição for de um valor for de uma porcentagem menor para uma maior, ela é chamada de transição de subida (\textit{rise slew}), caso contrário, transição de descida (\textit{fall slew}) (Figura \ref{fig:informacoes_temporais_porta_logica}).
	
	\item \textbf{Propagação do \textit{Slew: }} é a política utilizada para propagação dos \textit{slews} das entradas até as saídas das portas lógicas. A estratégia geralmente adotada é a de propagar o maior tempo de transição dentre os \textit{timing arcs}, para o pino de saída da porta lógica.
	
	\item \textbf{\textit{Driver:} } é a porta lógica (ou o pino de saída de uma porta lógica) que está ligado a uma interconexão. Cada interconexão possui apenas um \textit{driver}.
	
\end{itemize}

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\subfigure[]
{
\includegraphics[width=0.5 \linewidth]{imagens/portalogica_e_fio.pdf}

}
\subfigure[]
{
\includegraphics[width=0.9 \linewidth]{imagens/atrasos_nand.pdf}

}
\caption{(a) Uma porta lógica \textit{CMOS} $u1$, de função \textbf{NAND}, com duas entradas é \textit{driver} da interconexão \textit{n1}. (b) As características temporais (\textit{delay} e \textit{slew}) da porta lógica $u1$.}
\label{fig:informacoes_temporais_porta_logica}
\end{center}
\end{figure}



\subsection{Modelo de atraso adotado em fluxo \textit{standard cell}}
%
%\afazer{apresentar lookup table
%
%falar da interpolaç~ao
%
%modelo n~ao linear}	

%Na Análise de \textit{Timing} Estática, os cicuitos são modelados considerando duas partes principais, as portas lógicas e as interconexões. As portas lógicas são modeladas a nível de seus arcos de \textit{timing}, e seus modelos são fornecidos pelas bibliotecas de célula, através de elementos conhecidas como \textit{lookup tables}. As interconexões, podem receber um modelo simplista ou mais sofisticado, dependendo da etapa que o projeto se encontra no fluxo \textit{standard cell}. Para etapas mais preliminares, as interconexões são modeladas como capacitâncias, sem atraso. Nas etapas seguintes, as interconexões são representadas por suas árvores RC.
%	
%	Nesta seção, serão apresentados detalhes sobre a modelagem das portas lógicas, e seu mapeamento para a biblioteca de célula, e posteriormente, como é calculado o atraso de propagação nas interconexões, dependendo do modelo empregado.
	
	%\includegraphics[width=0.8 \linewidth]{imagens/methodology_for_rc_delay_calculation.png} 



Nas bibliotecas \textit{standard cell} atuais, modelos de atrasos não-lineares são fornecidos para os \textit{timing arcs} das células disponíveis. Esses modelos, que geralmente são obtidos através de simulações em nível elétrico, são armazenados na forma de \textit{lookup tables}, como a da Figura \ref{fig:lookup_table}. Uma \textit{lookup table} descreve o \textit{delay} ou o \textit{slew} de uma porta lógica em função de dois fatores: o \textit{slew} na entrada do \textit{timing arc} (colunas), e a capacitância de saída (\textit{load}) (linhas).

\begin{figure}
\lstset{basicstyle=\footnotesize}
\begin{lstlisting}[frame=single]
rise_delay (delay_table) {
 load (0.0, 0.1, 0.2, 0.4, 0.8, 1.6, 3.2) ;
 input_slew (0.5, 3.0, 5.0, 8.0, 14.0, 20.0, 30.0, 50.0) ;
 values (
   1.17, 1.82, 2.26, 2.76, 3.48, 4.04, 4.82, 6.12,
   1.69, 2.34, 2.86, 3.49, 4.41, 5.11, 6.06, 7.58,
   2.21, 2.86, 3.38, 4.12, 5.22, 6.05, 7.16, 8.90,
   3.25, 3.90, 4.42, 5.20, 6.60, 7.67, 9.08, 11.23,
   5.33, 5.98, 6.50, 7.28, 8.84, 10.30, 12.24, 15.14,
   9.50, 10.15, 10.67, 11.45, 13.01, 14.57, 17.15, 21.33,
   17.83, 18.48, 19.00, 19.78, 21.34, 22.90, 25.50, 30.70
  );
}
\end{lstlisting}
\caption{Uma \textit{lookup table} para atraso de subida (\textit{rise delay}) de um arco de \textit{timing}. As linhas são endereçadas por \textit{load} (capacitância de saída da porta lógica) e as colunas por \textit{input slew} (\textit{slew} aplicado na entrada do \textit{timing arc}). Adaptada de \citacaoAzul{Contest2013}.}
\label{fig:lookup_table}
\end{figure}

Utilizando a \textit{lookup table} da Figura \ref{fig:lookup_table} para estimar o \textit{delay} de um dos \textit{timing arcs} de uma porta \textit{CMOS} e supondo que o \textit{slew} na entrada deste \textit{timing arc} seja de $8.0$, e a capacitância vista na saída seja $0.1$, obtém-se que $delay = 3.49$, pois $3.49$ é o valor endereçado pelos índices da função (\textit{slew} e \textit{load}). Caso os valores de \textit{slew} ou \textit{load} não existam na tabela, uma interpolação linear é realizada. Da mesma forma, o cálculo do \textit{slew} do \textit{timing arc} é realizado com base na \textit{lookup table}.


\section{Modelos de Interconexão}
\label{sec:modelos_interconexoes}

%\afazer{Fazer um link: Motivação: Primeiro parágrafo de introdução do paper ``Performance Optimization of VLSI Interconnect Layout''}


Modelos de interconexão devem ser adotados de acordo com a etapa que o projeto se encontra no fluxo. Nas etapas iniciais, ou de \textit{pre-layout}, as informações de posicionamento e roteamento ainda não foram obtidas. Assim, as interconexões recebem modelos simplistas, possibilitando que as otimizações necessárias sejam realizadas, sem degradação no desempenho, para que as informações reais dos parasitas sejam apuradas. Nas etapas mais próximas da síntese física, ou \textit{pos-layout}, as interconexões são modeladas em função de suas capacitâncias e resistências, com o intuito de fornecer uma simulação mais precisa possível.

Esta seção tem por objetivo, apresentar alguns modelos de representação de interconexões, suas vantagens e desvantagens. Também será apresentado o formato de representação de parasitas mais utilizado no projeto de circuitos digitais.

%	\subsection{Modelo de Interconexão Ideal}
%
%		Nos projetos, fios são representados como linhas que não fornecem impacto algum sobre o sistema. Uma diferença na tensão em um ponto deste fio reflete instantaneamente em todos os outros pontos, mesmo se o fio tiver um comprimento muito grande. Este modelo ideal de interconexão não é utilizado para representar interconexões reais, mas ele é bastante utilizado nas fases iniciais dos projetos, quando é necessário observar o comportamento dos transistores e portas lógicas que estão sendo conectadas \citacaoAzul{Rabaey08}.
%
%	A medida em que o fluxo de projeto atinge fases mais avançadas, as interconexões necessitam ser abordadas em outro nível, considerando seu efeito e comportamento elétrico.



	\subsection{Modelo RC Distribuído (\textit{Distributed RC Model})}

Uma interconexão pode ser representada idealmente como uma linha distribuída (Figura \ref{fig:distributed_rc}). Uma linha é dividida em segmentos de tamanho $\Delta L$, com $\Delta L \to 0$, e cada segmento é representado por um valor de resistência $r$ e um valor de capacitância $c$. Assim, a resistência e a capacitância total da interconexão são $r \times L$ e $c \times L$, respectivamente. O cálculo dos atrasos em um modelo RC distribuído implica na resolução de equações diferenciais, que por sua vez, não possuem fórmula fechada. Uma solução numérica seria realista, a qual resulta em um custo computacional muito elevado, não tornando viável sua adoção em fluxo \textit{standard cell}. Para tal objetivo, utilizam-se modelos de interconexão simplificados.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.8 \linewidth]{imagens/distributed_rc.png}
% \includegraphics{sta.png}
\caption{(a) Modelo RC Distribuído; (b) Seu símbolo de esquemático. Obtida de \citacaoAzul{Rabaey08}.}
\label{fig:distributed_rc}
\end{center}
\end{figure}


	\subsection{Modelo de Capacitância Concentrada (\textit{Lumped C Model})}
	
		O Modelo de capacitância concentrada foi amplamente utilizado, pois se trata de um modelo simples e fácil de simular.
Quando a resistência da interconexão é desprezível, devido o fato de que a resistência do \textit{driver} é substancialmente maior que a resistência total da interconexão, ou quando as informações parasitas ainda não foram obtidas com detalhe, o fio pode ser representado como um capacitor $C$, que corresponde à capacitância total da interconexão. Seu atraso de propagação é desconsiderado, já que o fio não possui resistências. Seu único impacto no desempenho é a sua contribuição na capacitância vista pelo \textit{driver} \citacaoAzul{Rabaey08}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.8 \linewidth]{imagens/lumped_model.jpg}
% \includegraphics{sta.png}
\caption{Modelo de Capacitância Concentrada (\textit{Lumped C Model}). Obtida de \citacaoAzul{Rabaey08}.}
\label{fig:lumped_model}
\end{center}
\end{figure}

	\subsection{Modelo RC Concentrado (\textit{Lumped RC Model})}

O modelo RC concentrado é amplamente adotado no fluxo \textit{standard cell} para modelagem das interconexões. No modelo RC concentrado (\textit{lumped RC model}), concentra-se toda a resistência de cada segmento da interconexão em um único resistor $R$ e similarmente combina-se a capacitância total em um único capacitor $C$. A rede resistor-capacitor é representada como uma árvore RC (Figura \ref{fig:rc_tree}). De acordo com \citacaoInline{Rabaey08}, uma árvore RC possui as seguintes propriedades:
		
\begin{itemize}
\item A rede tem apenas um nodo de entrada, chamado de \textbf{fonte} (\textit{source});
\item Todos os capacitores são entre um nodo e o terra;
\item A rede não possui \textit{loops} resistivos, por isso é chamada de Árvore.
\end{itemize}


		\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7 \linewidth]{imagens/rc_tree.jpg}
% \includegraphics{sta.png}
\caption{Uma árvore RC. Obtida de \citacaoAzul{Rabaey08}.}
\label{fig:rc_tree}
\end{center}
\end{figure}

		

%		\subsubsection{Limitações do Modelo RC Concentrado}
%
%			Com a utilização do atraso de Elmore, ignora-se o fato de que algumas resistências influenciam nas capacitâncias dos nodos da Árvore RC, ponderando de forma diferente a soma da Equação \ref{eq:tau}. Ao se obter a resistência compartilhada entre dois nodos $i$ e $k$ e o nodo fonte $s$, o impacto da resistência nas capacitâncias \textit{downstream} de $i$ e $k$ não são considerados, resultando em uma perda de precisão no modelo de atraso de Elmore. Por exemplo, a influência de $R_2$ em $C_2$ não é considerada no atraso $\tau_{D4}$ (Figura \ref{fig:rc_tree}). Esse efeito é conhecido como \textit{resistive shield} \citacaoAzul{Kashyap00}. Considerando um caso hipotético, nesta topologia, se $R_2 = \infty$, o atraso de Elmore $\tau_{D4}$ continuaria sendo dado pela Equação \ref{eq:delay_4}, mesmo que $R_2$ impedisse $C_4$ de ser carregado ou descarregado.




\subsection{Extração de Elementos Parasitas no Projeto de Circuitos Digitais}

Quando se tem as informações de capacitância e resistência totais de uma interconexão, $C_{wire}$ e $R_{wire}$ respectivamente, em uma fase de \textit{pré-layout}, é necessário criar uma topologia para este fio, uma vez que o atraso da interconexão depende de como ela está estruturada. Existem três topologias (Figura \ref{fig:interconnect_tree}) que podem ser utilizadas a fim de representar a interconexão \citacaoAzul{BhaskerChadha09}:



\begin{itemize}
\item \textbf{Árvore de melhor caso (\textit{Best-case tree}): } (Figura \ref{fig:interconnect_tree}-a) Assume-se que cada pino de destino é fisicamente adjacente ao \textit{driver}. Assim, nenhuma resistência estará no caminho entre \textit{driver} e destino, e todos os pinos de destino atuarão como \textit{load} na saída da interconexão.

\item \textbf{Árvore balanceada (\textit{Balanced tree}): } (Figura \ref{fig:interconnect_tree}-b) Na árvore balanceada, todos os pinos de destino se encontram na mesma distância do \textit{driver}, e o caminho para cada destino corresponde a mesma quantidade de capacitância e resistência que os outros caminhos.

\item \textbf{Árvore de pior caso (\textit{Worst-case tree}): } (Figura \ref{fig:interconnect_tree}-c) Neste caso, todos os destinos se encontram no fim da interconexão. Assim, cada pino de destino vê a resistência e a capacitância total da interconexão.
\end{itemize}

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.8 \linewidth]{imagens/interconnect_tree.png}
% \includegraphics{sta.png}
\caption{Representações utilizadas para as árvores RC em um contexto de \textit{pre-layout}. Obtida de \citacaoAzul{BhaskerChadha09}.}
\label{fig:interconnect_tree}
\end{center}
\end{figure}

		Em projetos de circuitos digitais, as capacitâncias parasitas são geralmente descritas no formato SPEF \footnote{Existem outros formatos como SPF (\textit{standard parasitic format}), DSPF (\textit{detailed standard parasitic format}), RSPF (\textit{reduced standard parasitic format}) e SBPF (\textit{Synopsys binary parasitic format})} (\textit{Standard Parasitic Exchange Format}) do \textit{IEEE} (\textit{Institute of Electrical and Electronics Engineers}). O formato SPEF é um padrão feito para garantir a interoperabilidade entre ferramentas de automação de projeto eletrônico (\textit{EDA: Electronic Design Automation}). Os parasitas podem ser representados em diferentes níveis de sofisticação, desde o simplista modelo de capacitância concentrada, até uma representação mais precisa de Árvores RC.

		Um exemplo de interconexão descrita no formato SPEF \citacaoAzul{IEEE99} pode ser visualizado nas Figuras \ref{fig:spef_example} e \ref{fig:spef_example_code}. A linha 1 no código SPEF da Figura \ref{fig:spef_example_code} apresenta o nome da interconexão ($inp1$) e o valor de sua capacitância total ($5.4$). As linhas 2, 3 e 4 indicam que existe uma conexão entre uma entrada primária $inp1$, indicado por $*P inp1 I$, e a entrada de um pino interno \textit{a} da porta \textit{u1}, indicado por $*I u1:a I$. Da linha 6 até a linha 9 são representadas as capacitâncias da árvore RC.

		A representação de um capacitor num arquivo SPEF se dá pelo formato:

		\begin{verbatim}
		[Número] [Nome] [Capacitância]
		\end{verbatim}

		De maneira semelhante, os resistores, como pode ser visto nas linhas 11 até 13, são descritos no formato:

		\begin{verbatim}
		[Número] [Capacitor Fonte] [Capacitor Destino] [Resistência]
		\end{verbatim}

		O valor $*END$ (linha 14) é utilizado para determinar o fim da descrição de uma interconexão.

\begin{figure}[ht!]
\begin{center}
\subfigure[]
{
\includegraphics[trim=0 8cm 0 0, clip=true, width=0.8 \linewidth]{imagens/spef_example}
\label{fig:spef_example}
}
\subfigure[]
{
\includegraphics[width=0.4 \linewidth, trim=0 4cm 0 0, clip=true]{recursos/spef_example_code.pdf}
\label{fig:spef_example_code}
}
\end{center}
\caption{(a) Interconexão RC obtida do circuito $simple$ da competição de \textit{sizing} do ISPD. (b) SPEF referente à Figura \ref{fig:spef_example}.}
\end{figure}
		

\section{Características Temporais das Interconexões}
\label{sec:caracteristicas_temporais_interconexoes}


\begin{figure}[ht]
\begin{center} % TRIM = L D R U
\subfigure[]
{
\includegraphics[width=0.6 \linewidth]{imagens/modelagem/circuito.pdf} 
\label{fig:circuito_exemplo_modelagem_interconnect}
}
\subfigure[]
{
\includegraphics[width=0.6 \linewidth]{imagens/modelagem/modelagem.pdf} 
\label{fig:circuito_exemplo_modelagem_interconnect2}

}
\caption{(a) Um circuito composto por três portas lógicas ($u1$, $u2$ e $u3$), uma célula sequencial ($f1$) e uma interconexão em forma de árvore RC, que liga a saída de $u1$ às entradas de $u2$, $u3$ e $f1$; (b) São apresentadas as modelagens para os \textit{timing arcs} da porta lógica $u1$; O modelo da interconexão é abstraído, recebendo um valor de capacitância efetiva. As setas indicam que a interconexão oferece um atraso e uma degradação no \textit{slew}.; Cada destino da interconexão é representado como um valor de capacitância de seus pinos de entrada. }

\end{center}
\end{figure}

Uma interconexão tem sua contribuição para o desempenho do circuito atribuída a três fatores:
\begin{itemize}
	\item \textbf{Capacitância Vista Pelo \textit{Driver}: } É necessário modelar a carga capacitiva a ser carregada pelo \textit{driver} da interconexão com o objetivo de se obter a informação de \textit{load}, a qual é utilizada no cálculo do \textit{delay} e \textit{slew} dos \textit{timing arcs} das portas lógicas, como visto anteriormente. Nesta capacitância é incluído também, o impacto causado pelos pinos de destino da interconexão \footnote{Um pino de destino de uma interconexão é um pino que se liga na interconexão, que não é o pino \textit{driver}. Por exemplo, na Figura \ref{fig:circuito_exemplo_modelagem_interconnect}, os pinos de destino da interconexão são o segundo pino de entrada da porta $u2$, o pino de entrada da porta $u3$ e o pino $d$ do \textit{flip-flop} $f1$.}. Na fase \textit{pré-layout}, essa estimativa é realizada somando a capacitância total da interconexão com a capacitância de cada pino de destino dela. Porém, ao se tratar de interconexões com característica resistiva, o uso da abordagem de capacitância concentrada é impreciso. Para que os modelos de atraso não-lineares, que dependem do valor de capacitância de saída, sejam utilizados para os \textit{drivers} diretamente, é necessário o uso de uma abordagem conhecida como ``Capacitância Efetiva''.

A abordagem de ``Capacitância Efetiva'' tenta encontrar um valor de capacitância que pode ser utilizado como carga equivalente, em termos de \textit{timing}, para a saída do \textit{driver}. Essa capacitância equivalente é chamada de \textbf{Capacitância Efetiva} ($C_{eff}$) \citacaoAzul{BhaskerChadha09}.

	\item \textbf{Atraso da Interconexão: } Além do impacto local nos \textit{delays} e \textit{slews} de seus \textit{drivers}, as interconexões exercem impacto global no circuito, com seu próprio atraso de propagação, devido a sua característica resistiva. Com a alta frequência de operação dos circuitos digitais atuais e o dimensionamento dos transistores para escalas nanométricas, os atrasos das interconexões, que antes não eram significativos, hoje chegam consumir de 50\% a 70\% do ciclo do relógio, e esta porcentagem tende a aumentar na medida que os transistores diminuem \citacaoAzul{Cong96}. Uma das métricas mais populares para se calcular o atraso em interconexões é o atraso de Elmore (\textit{Elmore Delay}) \citacaoAzul{Elmore48}, pela simplicidade e razoável correlação com os atrasos reais. Esta técnica será apresentada com mais detalhes na seção \ref{sec:calculo_elmore}.
	
	\item \textbf{Degradação do \textit{Slew}: } O cálculo do \textit{slew} é crucial para determinar a precisão de uma avaliação de \textit{timing} em um circuito digital \citacaoAzul{Zhou2007}. Os \textit{delays} dos \textit{timing arcs} dependem do \textit{slew} de entrada e do \textit{slew} de saída. Quando um sinal se propaga por uma interconexão, seu \textit{slew} (i.e. sua declividade) sofre uma degradação devido ao efeito resistivo da mesma (figura \ref{fig:circuito_exemplo_modelagem_interconnect2}). A não-modelagem desta degradação pela interconexão, acarreta em erros de até 50\% \citacaoAzul{Sheehan2002}.
\end{itemize}
		
		
%Conforme explicado anteriormente, o impacto local de uma interconexão no seu \textit{driver} se dá pela contribuição no valor da capacitância vista pelo mesmo. 
%
%Para se realizar os cálculos de atrasos com precisão e eficiência, modelos são utilizados para o \textit{driver}, para a interconexão e para os destinos. Cada arco de \textit{timing} é modelado de modo a fazer com que os atrasos correspondam com a simulação elétrica. A interconexão, da mesma maneira, é modelada geralmente com modelos simplificados, que capturam o comportamento elétrico da descrição original da Árvore RC.

%Na figura \ref{fig:circuito_exemplo_modelagem_interconnect} é mostrado um circuito de exemplo composto por três portas lógicas ($u1$, $u2$ e $u3$), uma célula sequencial ($f1$) e a interconexão que liga a saída de $u1$ nas entradas de $u2$, $u3$ e $f1$. Na Figura \ref{fig:circuito_exemplo_modelagem_interconnect2} é ilustrada a modelagem deste circuito de exemplo.
%
%Existem algumas maneiras conhecidas de estimar o valor de capacitância visto na saída do \textit{driver}. 









\chapter{Cálculo das Características Temporais da Interconexão}
\label{cap:tecnica}
		
		Este capítulo tem por objetivo, apresentar uma técnica utilizada para o cálculo das características temporais das interconexões, necessário para a estimativa de \textit{timing} global dos circuitos digitais. Na seção \ref{sec:representacao_interconexoes_puri} será apresentado um modelo computacional para as interconexões. A seção \ref{sec:calculo_elmore} apresentará a técnica de Elmore, que é muito utilizada no cálculo do atraso das interconexões. Finalmente, a técnica utilizada neste trabalho para o cálculo das características temporais das interconexões será apresentada na seção \ref{sec:calculo_ceff_degradacao}.
	
\section{Representação das Interconexões}
\label{sec:representacao_interconexoes_puri}
		% \label{cap:atraso}
		% \afazer{Neste capítulo, serão apresentados detalhes sobre a implementação dos modelos de atrasos de interconexões, complementando a informação já obtida no Capítulo \ref{cap:sta}.}

		Para que o atraso de uma interconexão seja estimado com precisão, um modelo de grafo (Figura \ref{fig:grafo_interconexao}) é utilizado para representar o fio em termos de capacitâncias e resistências.

		No modelo de grafo $I(C, R)$ utilizado, o conjunto dos vértices é composto pelos nodos internos da interconexão, que representam cada capacitor. As arestas do grafo modelam os resistores, e cada resistor conecta um par de capacitores. Sendo assim:
		\begin{itemize}
		\item \textbf{C} = \{$c | c$ é um capacitor da rede RC\}
		\item \textbf{R} = \{$(c, d) |$ existe um resistor que conecta os capacitores $c$ e $d$\}
		\end{itemize}
	
		\begin{figure}[ht]
		\begin{center}% TRIM = L D R U
		\includegraphics[width=0.5 \linewidth, trim=0cm 12cm 0 0, clip=true]{imagens/grafo_interconexao/grafo.pdf}
		\caption{O grafo correspondente à interconexão da figura \ref{fig:circuito_exemplo_modelagem_interconnect}, com cinco vértices e quatro arestas.}
		\label{fig:grafo_interconexao}
		\end{center}
		\end{figure}


		\section{Cálculo do Atraso das Interconexões} 
		\label{sec:calculo_elmore}
		
A técnica de Elmore fornece uma análise rápida, já que se trata do primeiro momento de resposta ao impulso. Algumas outras técnicas conhecidas, como a de \citacaoInline{Alpert2000} e \textit{AWE} \citacaoAzul{AWE}, utilizam momentos de maior ordem, porém requerem um alto custo computacional.
		
A alta complexidade computacional de se obter momentos de maior ordem e a busca pelo compromisso entre técnicas rápidas e precisas para o cálculo do atraso em interconexões fazem com que a técnica de Elmore ainda seja amplamente utilizada. A popularidade da técnica de Elmore deve-se aos fatores:
		
\begin{itemize}
\item Boa correlação com os atrasos reais nos nodos mais afastados do \textit{driver} \citacaoAzul{Kashyap00};
\item Utiliza uma fórmula fechada, que envolve apenas as resistências e capacitâncias do circuito \citacaoAzul{Horowitz1983};
\item Provê um limite superior provado para o atraso real de qualquer árvore RC \citacaoAzul{Gupta97};
\item É aditiva, ou seja, o atraso do nodo A até o nodo C passando pelo nodo B é a soma dos atrasos entre A e B e entre B e C \citacaoAzul{Kashyap00}.
\end{itemize}
	
De acordo com \citacaoInline{Rabaey08}, em um nodo $c_i$ da Árvore RC, o atraso de Elmore ($\tau_i$) pode ser facilmente calculado como:
\begin{equation}
\tau_i = \sum_{k=1}^{N} C_k R_{ik}
\label{eq:elmore}
\end{equation}


Onde $N$ é o número de capacitores da árvore RC, $C_k$ é o valor de capacitância do nodo $c_k$ e $R_{ik}$ é a resistência compartilhada entre os caminhos $s \to i$ e $s \to k$ ($s$ é o nodo fonte), ou seja:
\begin{equation}
R_{ik} = \sum R_j \Rightarrow (R_j \in [caminhos(s \to i)\cap caminhos(s \to k)])
\label{eq:rik}
\end{equation}

Na topologia da figura \ref{fig:circuito_exemplo_modelagem_interconnect}, $C0$ é o nodo fonte. Assim, o atraso de Elmore para o nodo $C4$ é:

\begin{equation}
\tau_4 = C_1\ R_1 + C_2\ R_1 + C_3 \ R_1 + C_4(R_1+R_4) 
\label{eq:delay_4}
\end{equation}

A técnica de Elmore pode ser implementada também em sua forma recursiva. O algoritmo para cálculo do atraso de Elmore recebe como entrada o grafo $I(C, R)$ da interconexão e é executado após a inicialização das capacitâncias totais \textit{downstream} ($C_{total_i}$) de cada nodo interno. 
		
\begin{enumerate}


\item \textbf{Inicialização das capacitâncias totais \textit{downstream}:} Os nodos internos são numerados de $1$ até $n$ em ordem topológica, sendo $n$ o tamanho do conjunto de vértices. Assim, o passo de inicialização de cada $c_i \in C$ acontece em ordem topológica reversa, seguindo a equação \ref{eq:inicializacao_elmore};
		
\begin{equation}
C_{total_i} = C_i + \sum_{j \in filhos(i)} C_{total_j}
\label{eq:inicializacao_elmore}
\end{equation}

Sendo que $C_i$ é o valor de capacitância do nodo $c_i$. O conjunto $filhos(i)$ é o conjunto de capacitores que estão interligados diretamente com o capacitor $c_i$ através de um resistor $R$, que tenham um nível topológico maior que este\footnote{Caso $c_i$ seja um nodo terminal, seu conjunto $filhos(i)$ é vazio.}. Analogamente, o $pai(i)$ é um capacitor que precede $c_i$\footnote{Se $c_i$ não for o nodo fonte da árvore.} e se conecta com ele, também, através de um resistor. 

\item \textbf{Cálculo dos atrasos utilizando a técnica de Elmore:}  O atraso de Elmore em cada nodo $c_i$ da interconexão é calculado recursivamente, somando o atraso no pai de $c_i$ com o valor da resistência que liga $c_i$ ao seu pai multiplicado pela capacitância total \textit{downstream} de $c_i$, como mostrado na equação \ref{eq:elmore_recursivo}.

\begin{equation}
\tau_i = \tau_{pai(i)} + R(pai(i), i) \times C_{total_i}
\label{eq:elmore_recursivo}
\end{equation}

\end{enumerate}

A função $R(i, j)$ retorna o valor da resistência que liga dois capacitores $c_i$ e $c_j \in C$. O atributo $c_{total_i}$ é a capacitância total \textit{downstream} de um nodo $c_i$.

Assim, o cálculo do atraso em cada nodo da interconexão reflete no atraso da interconexão partindo do \textit{driver} até cada pino de destino.


A técnica de Elmore para atraso de interconexões não considera o efeito conhecido como \textit{resistive shielding}. O efeito de \textit{resistive shielding} acontece devido ao fato de que as resistências alteram o tempo que as capacitâncias levam para serem carregadas ou descarregadas. Considerando a interconexão da figura \ref{fig:circuito_exemplo_modelagem_interconnect}, no caso extremo em que $R4 = \infty$, o capacitor $C4$ nunca seria carregado, portanto o atraso da interconexão não deveria levar em consideração o valor do capacitor $C4$.

Algumas adaptações na técnica de Elmore foram propostas, para que o cálculo do atraso das interconexões capturem também o efeito do \textit{resistive shielding} utilizando a abordagem de capacitância efetiva em cada nodo da interconexão. Essas técnicas serão apresentadas na seção \ref{sec:calculo_ceff_degradacao}.
		
\section{Técnica de \citacaoInline{PURI02} para o Cálculo da Capacitância Efetiva e Degradação do \textit{Slew}}
\label{sec:calculo_ceff_degradacao}
%\afazer{Aqui, será descrito em forma de Algoritmo ou Fluxograma, o algoritmo utilizado para cálculo do atraso, na abordagem de Capacitância Efetiva \citacaoInline{PURI02}, que será implementado neste trabalho.}	
A necessidade de uma abordagem de capacitância efetiva se dá pelo fato de que a característica resistiva das interconexões altera o tempo em que suas capacitâncias são carregadas ou descarregadas. Esse efeito, mais conhecido como \textit{resistive shielding}, faz com que o atraso do \textit{driver} de uma interconexão seja menor que o atraso dele considerando a capacitância total da interconexão.



\begin{figure}[ht]
\begin{center} % TRIM = L D R U
\includegraphics[width=\linewidth]{imagens/effective_capacitance_vs_actual_vs_total.pdf} 
\caption{Formas de onda na saída de uma porta lógica em função da abordagem utilizada para cálculo da capacitância. Obtida de \citacaoAzul{BhaskerChadha09}.}
\label{fig:effective_capacitance_vs_actual_vs_total}
\end{center}
\end{figure}

A figura \ref{fig:effective_capacitance_vs_actual_vs_total} mostra formas de onda na saída de uma porta lógica que é \textit{driver} de uma interconexão. A curva pontilhada (\textit{Effective capacitance}) representa o sinal na entrada da interconexão, ao modelá-la utilizando um valor de capacitância efetiva. A curva contínua (\textit{Total capacitance}) mostra a forma de onda utilizando o valor de capacitância concentrada. E a curva tracejada (\textit{Actual load}), mostra a forma de onda, quando o \textit{driver} está ligado na árvore RC. Pode-se observar que para o valor escolhido de capacitância efetiva, o sinal leva o mesmo tempo para atingir o ponto médio da curva (\textit{$V_{dd} = 50\%$}) que quando o \textit{driver} está conectado diretamente à árvore RC. Note a diferença neste ponto em relação à curva de capacitância concentrada, mostrando a imprecisão de se utilizar este modelo em certos casos.

Como a abordagem de capacitância efetiva está relacionada à consideração do efeito de \textit{resistive shielding}, ao utilizá-la em cada segmento da interconexão, é possível obter-se um atraso na interconexão mais preciso do que o atraso de Elmore, mesmo sem considerar momentos de maior ordem da resposta ao impulso.

%Diversas técnicas são utilizadas para cálculo da capacitância efetiva. Em \citacaoAzul{Kashyap00}, o método proposto trata de calcular o valor de $C_{eff}$ da interconexão, aproximando o \textit{slew} na entrada da árvore RC, de modo a obter a capacitância efetiva. Porém, nos circuitos digitais, os \textit{drivers} das interconexões são portas lógicas \textit{CMOS} com função de \textit{slew} de saída conhecidas, e seus valores são dependentes do valor da capacitância efetiva, que por sua vez, depende do \textit{slew} aplicado na entrada. Para contornar o problema encontrado na técnica de \citacaoInline{Kashyap00}, em \citacaoAzul{PURI02} foi proposta uma técnica que calcula o \textit{slew} e a $C_{eff}$ iterativamente, até que seus valores convirjam, dado uma precisão estipulada. Esta técnica será apresentada no capítulo \ref{cap:tecnica} e será implementada na ferramenta abordada neste trabalho.

\citacaoInline{Kashyap00} propuseram uma técnica para calcular o atraso da interconexão levando em conta o efeito de \textit{resistive shielding}. Com a mesma complexidade da técnica de Elmore, a técnica proposta para cálculo de atraso em uma árvore RC calcula também o valor de capacitância efetiva. Porém, \citacaoInline{Kashyap00} não tratava o \textit{driver} da interconexão como sendo uma porta lógica \textit{CMOS}. Sua aproximação para o \textit{slew} na entrada da árvore RC era imprecisa. Como o cálculo da capacitância efetiva de uma árvore depende do \textit{slew} que incide nesta, e o \textit{slew} depende da capacitância vista pelo \textit{driver}, \citacaoInline{PURI02} propuseram uma técnica que leva em consideração o impacto da capacitância no \textit{slew} do driver, e também, do \textit{slew} no cálculo da capacitância efetiva. Para simular a interdependência entre o \textit{slew} e a capacitância efetiva, o \textit{slew} no nodo fonte da árvore RC é refinado iterativamente, a fim de obter com precisão os dois valores.

\subsection{Cálculo da Capacitância Efetiva}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\linewidth]{imagens/puri/effective_ramp.pdf}
\caption{Cálculo da capacitância efetiva utilizando rampa de entrada. Obtida de \citacaoAzul{PURI02}.}
\label{fig:effective_ramp}
\end{center}
\end{figure}

Considere uma rede $\pi$ $C_1 - R - C_2$ alimentada por uma fonte de tensão $V(t)$, como a ilustrada na figura \ref{fig:effective_ramp}. Seja $I(t)$ a corrente total fornecida pela fonte de tensão $V(t)$, $I_1(t)$ a corrente através de $C_1$ e $I_2(t)$ a corrente através de $R - C_2$. De acordo com \citacaoInline{PURI02}, realizando uma análise no domínio da frequência, obtemos que:

\begin{equation}
I(s) = I_1(s) + I_2(s)
\end{equation}

Se

\begin{equation}
I_1(s) = \frac{V(s)}{1/C_1s}
\end{equation}

\begin{equation}
I_2(s) = \frac{V(s)}{R+1/C_2s}
\end{equation}

Então:

\begin{equation}
I(s) = \frac{V(s)}{1/C_1s} + \frac{V(s)}{R+1/C_2s}
\end{equation}

ou

\begin{equation}
I(s) = V(s)\left(C_1s + \frac{C_2s}{1+RC_2s}\right)
\label{eq:ifreq}
\end{equation}

Agora, considerando que a fonte de tensão $V(t)$ é uma rampa com tempo de subida $t_r$, $V(t)$ é dado por:

\begin{equation}
V(t) = \left\{
\begin{array}{l l}
\frac{V_{dd}}{t_r} \times t & \quad \text{se $t < t_r$} \\
V_{dd} & \quad \text{caso contrário}
\end{array} \right. 
\end{equation}

E no domínio da frequência:

\begin{equation}
V(s) = \frac{V_{dd}}{t_r} \times \frac{1}{s^2}\times (1-e^{-st_r})
\label{eq:vfreq}
\end{equation}

Substituindo a $V(s)$ da equação \ref{eq:ifreq} pela equação \ref{eq:vfreq} e voltando ao domínio do tempo obtém-se:

\begin{equation}
I(t) = \frac{V_{dd}}{t_r}((C_1 + C_2) - C_2e^{-\frac{t}{RC_2}}) \quad \text{para $t < t_r$}
\end{equation}

Em termos de \textit{timing}, na capacitância efetiva, a carga transferida $Q$ é a mesma que da rede $\pi$, no ponto médio da curva (tempo que a curva atinge $50\% V_{dd}$). A carga transferida $Q$ é a integral da corrente $I(t)$ com o tempo indo de $0$ até $t_r/2$:

\begin{equation}
Q = \int_0^{t_r/2} I(t) \mathrm{d}t = \int_0^{t_r/2} \frac{V_{dd}}{t_r}((C_1 + C_2) - C_2e^{-\frac{t}{RC_2}}) \mathrm{d}t
\end{equation}

A carga transferida $Q$ para carregar a capacitância efetiva da rede $\pi$ ($C_{eff}$) até $50\%$ de $V_{dd}$ é dada, também, por $\frac{C_{eff}V_{dd}}{2}$. Ao igualar as duas equações de transferência de carga, obtemos:

\begin{equation}
C_{eff} = C_1 + C_2(1 - \frac{2RC_2 V_{dd}}{t_r} (1 - e^{-\frac{t_r}{2RC_2}}))
\end{equation}

Assim, $C_{eff} = C_1 + C_2 \times K$, onde $K$ é o fator de \textit{shielding}, definido por:

\begin{equation}
K = 1 - 2x(1 - e^{-\frac{1}{2x}}), \quad  \text{onde } x = \frac{RC_2}{t_r}
\label{eq:shieldfactor}
\end{equation}

\subsection{Degradação do \textit{Slew} Através da Árvore RC}


\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\linewidth, trim=0 16cm 0 0, clip=true]{imagens/puri/degradacao_slew.pdf}
\caption{Degradação no \textit{slew} em um segmento de uma árvore RC. Obtida de \citacaoAzul{PURI02}.}
\label{fig:degradacao_slew}
\end{center}
\end{figure}


O \textit{slew} é degradado na árvore RC para obtenção de coeficientes mais precisos para os fatores de \textit{shielding}. Considerando um segmento de uma árvore RC, mostrado na figura \ref{fig:degradacao_slew}, que é alimentado por uma fonte de tensão $V(t) = \frac{V_{dd}}{t_r} \times t$, onde $t_r$ é o \textit{slew} da rampa de entrada. Conforme \citacaoAzul{PURI02}, a tensão de saída neste caso, quando $t = t_r$, pode ser derivado como:

\begin{equation}
\frac{V_{dd}}{t_r}(t_r - RC_2 + RC_2 e^{-\frac{t_r}{RC_2}})
\label{eq:slew2}
\end{equation}

Conforme a figura \ref{fig:degradacao_slew}:

\begin{equation}
\frac{V_1}{t_r} = \frac{V_{dd}}{t_r'}
\label{eq:slew1}
\end{equation}

Onde $t_r'$ é o \textit{slew} na saída. Substituindo $V_1$ da equação \ref{eq:slew1} pela equação \ref{eq:slew2}, obtemos o valor de \textit{slew} na saída, em função do \textit{slew} aplicado na entrada:

\begin{equation}
t_r' = \frac{t_r}{1-x(1-e^{-\frac{1}{x}})} \quad \text{onde } x = \frac{RC_2}{t_r}
\end{equation}

Generalizando para uma árvore RC qualquer \footnote{Representada conforme apresentado na seção \ref{sec:representacao_interconexoes_puri}.} e utilizando o valor de capacitância efetiva, o $slew_i$ no nodo $c_i$ é definido pela equação:

\begin{equation}
slew_i = \frac{slew_j}{1-\frac{R_i\ C_{eff_i}}{slew_j} (1-e^{-\frac{slew_j}{R_i\ C_{eff_i}}})}
\label{eq:degradacao_slew}
\end{equation}

Onde $slew_j$ é o \textit{slew} na entrada de $v_i$, vindo pelo nodo pai $v_j$ e $R_i$ é o valor do resistor que conecta $c_i$ com $c_j$

\subsection{O Algoritmo de \citacaoInline{PURI02}}

		Dado o grafo de uma árvore RC\footnote{Com os nodos numerados de $1$ a $n$ em ordem topológica, onde $n$ é o tamanho do conjunto de vértices e o nodo $c_1$ é o nodo fonte da árvore RC.}, o algoritmo apresentado nessa seção calcula os valores de capacitância efetiva e \textit{slew} em cada nodo interno da interconexão. Para o atraso da interconexão, o método implementa a técnica de Elmore, utilizando os valores de capacitância efetiva, ao invés dos valores de capacitância total \textit{downstream}, simulando o efeito de \textit{resistive shielding}.
		
		A capacitância efetiva é denotada em cada nodo $c_i$ por $C_{eff_i}$ e o \textit{slew} por $slew_i$. O valor do \textit{slew} aplicado no nodo fonte da árvore RC, denotado por $slew_1$, é exatamente o valor do \textit{slew} na saída do \textit{driver} desta interconexão, o qual é função do \textit{slew} na entrada da porta lógica \textit{driver} e da capacitância efetiva vista na saída. Este valor de \textit{slew} será refinado iterativamente para se estimar o valor de capacitância efetiva da interconexão.
		
		O algoritmo para cálculo iterativo da capacitância efetiva de uma interconexão, bem como seu atraso e a degradação no \textit{slew}, conforme \citacaoAzul{PURI02}, ocorre em cinco passos:

		\begin{enumerate}

			\item \textbf{Inicialização:}

				\begin{enumerate}

					\item A capacitância efetiva $C_{eff_i}$ de cada nodo $c_i$ da Árvore RC é incializada com o valor de capacitância total \textit{downstream} de $c_i$, ou seja $C_{eff_i} = C_{total_i}$;
					
					\item O \textit{slew} no nodo fonte da árvore RC $slew_1$ é calculado utilizando o modelo de atraso da porta lógica \textit{driver}, considerando a capacitância concentrada da árvore RC (i.e. $\sum_{i=1}^N C_i$): $slew_1 = f(C_{total_1})$.

				\end{enumerate}

			\item \textbf{Atualização dos \textit{slews} em ordem topológica:}  \label{enum:algo_net_timing:1}

				\begin{enumerate}

					\item Atraso $\tau_i$ do nodo fonte $c_1$ para cada nodo $c_i$ da árvore é calculado utilizando a técnica de Elmore (equação \ref{eq:elmore_recursivo}), substituindo $C_{eff_i}$ por $C_{total_i}$, para simular o efeito de \textit{resistive shielding};


					\item A degradação do \textit{slew} em cada nodo $c_i$ é calculada utilizando a equação \ref{eq:degradacao_slew}.
					
				\end{enumerate}

			\item \textbf{Atualização das capacitâncias efetivas em ordem topológica reversa:}
				\begin{enumerate}

					\item A capacitância efetiva ($C_{eff_i}$) de cada nodo $c_i$ é calculada como a soma da capacitância do nodo $c_i$ e todas as capacitâncias dos nodos filhos:

					\begin{equation}
						C_{eff_i}=C_i + \sum_{j \in filhos(i)}\ K_j \times C_{tot_j}
					\end{equation}

					Onde $K_j$ é o fator de \textit{shielding}, definido por:

					\begin{equation}
						K_j=1-\frac{2R_jC_{eff_j}}{slew_i}(1-e^{-\frac{slew_i}{2R_jC_{eff_j}}})
					\end{equation}
					
					Onde $R_j$ é o valor da resistência que conecta o nodo $c_j$ ao seu pai, no caso, $c_i$.

				\end{enumerate}


			\item \textbf{Atualização do \textit{Slew} do \textit{Driver}:} O \textit{slew} no nodo fonte $slew_1$ é calculado diretamente, utilizando o $C_{eff_1}$ atual  \label{enum:algo_net_timing:2};

			\item \textbf{Iteração:} Os passos de \ref{enum:algo_net_timing:1} até \ref{enum:algo_net_timing:2} são repetidos até que $slew_1$ convirja, dada uma precisão $\varepsilon$ .

		\end{enumerate}

Na implementação apresentada neste trabalho, o $\varepsilon$ foi definido como sendo $1\%$. Na maioria dos casos observados, cerca de $5$ iterações são necessárias para realizar o cálculo da capacitância efetiva no nodo fonte da árvore. Como cada iteração do algoritmo se trata de uma passagem na lista de nodos, com complexidade linear, e são necessárias algumas iterações para a convergência, a complexidade do algoritmo é de $O(c . n)$, onde $c$ geralmente é menor que $5$, e $n$ é o número de nodos na árvore RC.

A técnica apresentada calcula a degradação do \textit{slew} e o atraso de propagação em cada ponto de destino da interconexão. Porém, ela apresenta resultados pessimistas em relação ao \textit{PrimeTime}, como mostrado na tabela \ref{tab:ceff_elmore_slew}. A fim de reduzir o erro apresentado no experimento da tabela \ref{tab:ceff_elmore_slew}, neste trabalho é proposto uma modificação à técnica de \citacaoInline{PURI02} para o cálculo de atraso de interconexões. O atraso de Elmore, que é realizado no passo \label{enum:algo_net_timing:1} do algoritmo passa a ser multiplicado por $ln(2)$ nos \textit{fanouts} da interconexões. Os resultados obtidos podem ser observador na tabela \ref{tab:puri_ln2}

		
%\section{Proposta de Modificação da Técnica de \citacaoInline{PURI02}}
%\label{sec:modificacao}
%
%Conforme dito anteriormente, o trabalho de \citacaoInline{PURI02} não esclarece como os \textit{slews} são anotados nos pinos de destino das interconexões. Por meio de experimentos foi possível observar que ao anotar-se os \textit{slews} degradados\footnote{que anteriormente foram utilizados para o cálculo da capacitância efetiva} nos pinos de destino da interconexão, a ferramenta reporta valores muito pessimistas para as informações globais do circuito, conforme observado na tabela \ref{tab:ceff_elmore_slew}. Após uma pesquisa na bibliografia, uma métrica mais otimista de propagação dos \textit{slews} foi incorporada ao algoritmo de \citacaoInline{PURI02} a fim de obter resultados mais otimistas.
%
%Em \citacaoAzul{Hu2007} é abordado o problema da insersão de \textit{buffers} nas interconexões, a fim de reduzir as violações de \textit{slew}. Ao inserir um \textit{buffer} é necessário estimar o valor do \textit{slew} em sua entrada, considerando o \textit{slew} do \textit{driver} da interconexão e a degradação causada pela característica resistiva da mesma. Conforme \citacaoInline{Hu2007}, o \textit{slew} $s_j$ anotado na entrada da porta lógica destino da interconexão é \citacaoAzul{Kashyap2004}:
%
%\begin{equation}
%\label{eq:degradacao_slew_sqrt}
%s_j = \sqrt{s_i^2 + s_{i \to j}^2}
%\end{equation}
%
%Onde $s_i$ é o \textit{slew} no \textit{driver} da interconexão e $s_{i \to j}$ é a degradação do \textit{slew}. Considerando o atraso de Elmore no nodo destino da interconexão ($\tau_j$), a degradação pode ser calculada utilizando a métrica de \citacaoInline{Bakoglu1990}:
%\begin{equation}
%s_{i \to j} = ln(4) * \tau_j
%\end{equation}
%
%		O algoritmo para cálculo iterativo da capacitância efetiva de uma interconexão, bem como seu atraso de propagação ocorre em sete passos:
%
%		\begin{enumerate}
%
%			\item \textbf{Inicialização:} Este passo é exatamente o mesmo do algoritmo apresentado na seção \ref{sec:calculo_ceff_degradacao}.
%
%			\item \textbf{Atualização dos \textit{slews} em ordem topológica:} A degradação do \textit{slew} em cada nodo $c_i$ é calculada utilizando a equação \ref{eq:degradacao_slew}. \label{enum:algo_net_timing_mod:1}
%				
%			\item \textbf{Atualização das capacitâncias efetivas em ordem topológica reversa:} Este passo é exatamente o mesmo do algoritmo apresentado na seção \ref{sec:calculo_ceff_degradacao}.
%
%			\item \textbf{Atualização do \textit{Slew} do \textit{Driver}:} O \textit{slew} no nodo fonte $slew_1$ é calculado diretamente, utilizando o $C_{eff_1}$ atual  \label{enum:algo_net_timing_mod:2};
%
%			\item \textbf{Iteração:} Os passos de \ref{enum:algo_net_timing_mod:1} até \ref{enum:algo_net_timing_mod:2} são repetidos até que $slew_1$ convirja, dada uma precisão $\varepsilon$.
%
%
%		\item \textbf{Anotação dos \textit{Slews} nos \textit{Fanouts}:} Para cada pino de destino da interconexão, o \textit{slew} é calculado usando a equação \ref{eq:degradacao_slew_sqrt}.
%		
%		\item \textbf{Cálculo do Atraso de Elmore: } 
%			
%			\begin{enumerate}
%			
%				\item Atraso $\tau_i$ do nodo fonte $c_1$ para cada nodo $c_i$ da árvore é calculado utilizando a técnica de Elmore (equação \ref{eq:elmore_recursivo});
%		
%				\item O atraso de Elmore em cada ponto de destino da interconexão é multiplicado por $ln(2)$, para se obter o tempo de transição até $50\% V_{dd}$.
%				
%			\end{enumerate}
%
%		\end{enumerate}
%		
%		

\chapter{Análise de \textit{Timing} Estática}
\label{cap:sta}
Análise de \textit{timing} estática, ou \textit{static timing analysis} \citacaoAzul{Guntzel00} \citacaoAzul{BhaskerChadha09}, é uma das técnicas utilizadas para se estimar o atraso crítico de circuitos digitais. A análise de \textit{timing} é chamada de estática (\textit{STA: Static Timing Analysis}) quando ela não realiza simulação e portanto, independe de estímulos de entrada, considerando apenas o comportamento estático das portas lógicas e interconexões. É um processo completo e exaustivo \citacaoAzul{BhaskerChadha09} que verifica as mais diversas informações de \textit{timing} em um circuito, como os \textit{delays}, \textit{slews}, \textit{slacks} (folgas), \textit{required times} (tempos requeridos) e diversas violações de restrições de projeto.

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=0.5 \linewidth, trim=0 3cm 0 0]{imagens/sta.pdf}
% \includegraphics{sta.png}
\caption{Análise de \textit{timing} estática. Adaptado de \citacaoAzul{BhaskerChadha09}.}
\label{fig:STA}
\end{center}
\end{figure}

Dado a descrição do projeto usando alguma linguagem de descrição de hardware (\textit{HDL: Hardware Description Language}), restrições de projeto e uma biblioteca de células, o objetivo da análise de \textit{timing} é apresentar informações temporais em todos os pontos do circuito e apontar as possíveis violações (figura \ref{fig:STA}). Essas informações são utilizadas para validar se o projeto sob verificação pode operar na velocidade estipulada, ou seja, se o circuito final poderá funcionar, com segurança, na frequência de relógio escolhida, sem que existam violações nas restrições de projeto.

O fluxo básico de uma ferramenta de análise de \textit{timing} é:

\begin{enumerate}
\item \textbf{Leitura dos arquivos de entrada:} Nesta etapa, os arquivos referentes às bibliotecas de célula, descrição do circuito juntamente com as restrições do projeto são lidos e suas informações são armazenadas em estruturas de dados, que serão consultadas na geração do modelo de grafo e na atualização das informações temporais;

\item \textbf{Geração do grafo de \textit{timing}:} Responsável por implementar o modelo de grafo de \textit{timing}. As estruturas de dados utilizadas na implementação do modelo de grafo têm impacto direto no desempenho da ferramenta de \textit{timing}.

\item \label{enum:etapa_sta} \textbf{Atualização de informações temporais: } Etapa onde a propagação dos atrasos através dos \textit{timing arcs}, bem como a avaliação do cumprimento ou não das restrições de desempenho são realizados. 
\end{enumerate}

Na seção \ref{sec:representacao_circuitos_sta} será apresentado o modelo de grafo utilizado para modelar os circuitos digitais na análise de \textit{timing}. A seção \ref{sec:calculo_desempenho} mostrará a nomenclatura utilizada para as diversas informações temporais relevantes na análise de \textit{timing} estática. E finalmente, informações particulares sobre a implementação da ferramenta construída neste trabalho serão apresentadas na seção \ref{sec:implementacao_sta}. 

\section{Representação de Circuitos Digitais}
\label{sec:representacao_circuitos_sta}

\begin{figure}[ht]
\begin{center}
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/exemplo_circuito_simple.pdf}
\label{fig:exemplo_circuito_simple}
}
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/exemplo_grafo_simple.pdf}
\label{fig:exemplo_grafo_simple}
}
\caption{(a) Circuito \textit{simple} retirado do banco de \textit{benchmarks} da competição de \textit{sizing} do ISPD; (b) Grafo correspondente ao circuito da letra (a).}
\label{fig:exemplo_simple_circuito_grafo}
\end{center}
\end{figure}

Um circuito combinacional pode ser representado por um grafo de \textit{timing}. Neste grafo, as portas lógicas e os pinos de entrada e saídas primárias são os vértices e as interconexões são as arestas, como mostrado na figura \ref{fig:exemplo_simple_circuito_grafo} \citacaoAzul{BhaskerChadha09}.




%Um par de vértices, $v_i$ e $v_j \in V$ são conectados por uma aresta direcionada $a(v_i, v_j) \in E$ se existe uma interconexão da saída do elemento representado pelo vértice $v_i$ para a entrada do elemento representado pelo vértice $v_j$. Dois vértices especiais, fonte (\textit{source}) e terminal (\textit{sink}), juntamente de suas arestas,  são inseridos antes das entradas e depois das saídas primárias, respectivamente, a fim de fornecer ao grafo, um único ponto de entrada e de saída.
%
%Um exemplo de circuito e seu grafo correspondente é ilustrado nas Figuras \ref{fig:exemplo_circuito_simple} e \ref{fig:exemplo_grafo_simple}, em que as cores utilizadas para representar as entradas primárias, células combinacionais, células sequenciais e saídas primárias são respectivamente: azul, laranja, amarelo e verde. Note que neste caso, a entrada primária de \textit{clock} e sua interconexão não são representados no modelo de grafo, visto que neste trabalho, a abordagem será restringida a análise de timing em circuitos combinacionais, ou seja, não serão considerados tempos de \textit{setup} e \textit{hold} nas células sequenciais.

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\linewidth]{imagens/subcircuitos.pdf}
\caption{Grafo de \textit{timing} dividido em dois sub-circuitos devido à existência de uma célula sequencial.}
\label{fig:subcircuitos}
\end{center}
\end{figure}

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\linewidth]{imagens/grafo_refinado.pdf}
\caption{Grafo de \textit{timing} com célula sequencial atuando como entrada e saída primária do circuito.}
\label{fig:grafo_refinado}
\end{center}
\end{figure}

Um circuito que consiste de células combinacionais e sequenciais (\textit{flip-flops} e \textit{latches}) pode ser representado como um conjunto de blocos combinacionais, divididos pelos \textit{latches} (figura \ref{fig:subcircuitos}), assim, a entrada de uma célula sequencial pode ser tratada como uma saída primária do circuito, e a saída dessa pode ser tratada como uma entrada primária de outro circuito (figura \ref{fig:grafo_refinado}).

Em um contexto de projeto com o fluxo \textit{standard cell}, é interessante que o grafo modele também os \textit{timing arcs} das portas lógicas. Assim, alternativamente, os vértices do grafo de \textit{timing} são os pinos de entrada e saída das portas lógicas, entradas e saídas primárias e as arestas são definidas pelos \textit{timing arcs} e pelas interconexões. Um grafo representando o modelo escolhido pode ser visualizado na figura \ref{fig:grafo_timing_points}.


		 % Um circuito combinacional pode ser representado como um grafo direcionado $G(V, A)$, onde em $V$, o conjunto de vértices, são encontrados os pinos do circuito, e nas arestas ($E$), a união de dois conjuntos: as interconexões, denotado pela letra $I$, e os arcos de \textit{timing}, neste caso denominado $A$.

		A seguir, é apresentada a nomenclatura utilizada no modelo do grafo direcionado $G(V, E)$:

\begin{itemize}

\item V  = \{ $v_i | v_i$ é um \textit{timing point} (pino de \textit{timing}), que pode ser a entrada ou saída de uma porta lógica, aqui referenciado como pino. Um \textit{timing point} pode também representar uma entrada ou saída primária do circuito. \}

\item I = \{ $(v_i, v_j) | v_i, v_j \in V$ e $(v_i, v_j)$ é uma interconexão do circuito, que conecta $v_i$ em $v_j$. $v_i$ é um pino de saída de uma porta lógica ou uma entrada primária, e $v_j$ pode ser a entrada de uma porta lógica ou uma saída primária. \}

\item A = \{ $(v_i, v_j) | v_i, v_j \in V$ e $(v_i, v_j)$ é um \textit{timing arc}. Portanto, $v_i$ e $v_j$ são pinos de entrada e saída (respectivamente) de uma mesma porta lógica. \}

\item Por fim, o conjunto das arestas E = I $\cup$ A.

\end{itemize}

\begin{figure}[H]
\begin{center}% TRIM = L D R U
\includegraphics[width=\linewidth]{imagens/grafo_timing_points.pdf}
% \includegraphics{sta.png}
\caption{Grafo de \textit{timing} com representação dos \textit{timing points}, \textit{timing arcs} e interconexões.}
\label{fig:grafo_timing_points}
\end{center}
\end{figure}

Nos vértices, ou \textit{timing points}, são armazenadas as informações temporais para os pinos do circuito, tais como os \textit{arrival times}, \textit{slews} e \textit{slacks} que serão apresentadas na Seção \ref{sec:calculo_desempenho}.

	
		
\section{Cálculo do Pior Atraso do Circuito}
\label{sec:calculo_desempenho}
O cálculo do pior atraso do circuito é realizado propagando os \textit{arrival times} (tempos de chegada) das portas lógicas em ordem topológica através de um método conhecido como PERT CPM. Para o entendimento das políticas de propagação dos atrasos na avaliação do desempenho de um circuito, os termos a seguir são importantes:

\begin{itemize}

\item \textbf{Caminho: } uma sequência de vértices (\textit{timing points}) tal que, para cada um de seus vértices há uma aresta (\textit{timing arc} ou interconexão) para o próximo vértice da sequência. O primeiro \textit{timing point} da sequência é uma entrada primária e o último é uma saída primária;

\item \textbf{$inputs(i)$}: conjunto de \textit{timing points} que se ligam com $v_i$ através de um \textit{timing arc}. Todo $v_j \in input(i)$ é necessariamente um pino de entrada de uma porta lógica, e $v_i$ é um pino de saída;

\item \textbf{$a_i$}: \textit{arrival time}, ou tempo de chegada no pino $v_i$. O \textit{arrival time} é definido pela soma dos \textit{delays} e dos atrasos das interconexões desde uma entrada primária, até $v_i$;

\item \textbf{$slew_i$}: o \textit{slew} no pino $v_i$;

\item \textbf{$d_{j \to i}$}: o \textit{delay} do \textit{timing arc} que vai do pino $v_j$ até o pino $v_i$;

\item \textbf{$slew_{j \to i}$}: o \textit{slew} do \textit{timing arc} que vai do pino $v_j$ até o pino $v_i$;

\item \textbf{$iD_{i \to k}$}: o atraso de propagação na interconexão que liga o pino $v_i$ até o pino $v_k$. No modelo de capacitância concentrada, $iD_{i \to k} = 0$;

\item \textbf{$iS_{i \to k}$}: degradação do \textit{slew} através da interconexão que liga $v_i$ em $v_k$;

\item \textbf{$fanouts(i)$}: conjunto dos pinos que são destino da interconexão para qual $v_i$ é \textit{driver};

\item \textbf{$r_i$}: é o \textit{required time} no \textit{timing point} $v_i$. O \textit{required time} é o tempo máximo que o valor de $a_i$ pode assumir para que a restrição de desempenho respeitada. Se $v_i$ é uma saída primária do circuito, então $r_i = T$, onde $f = \frac{1}{T}$ é a frequência mínima de operação do circuito digital;

\item \textbf{$slack_i$}: folga de tempo no ponto $v_i$, ou seja, quanto o \textit{arrival time} pode atrasar neste ponto, de modo que o período máximo continue sendo respeitado. Se em um determinado ponto do circuito o \textit{slack} é negativo, então o caminho em questão está violando a restrição de atraso máximo do sistema. 
\end{itemize}
		
Na análise de \textit{timing} estática, os piores atrasos de cada porta lógica são propagados visitando-se o grafo direcionado em ordem topológica. Para cada $v_i \in V$ que são pinos de saída de portas lógicas, os \textit{arrival times}, bem como os \textit{slews} são determinados de modo a respeitar as seguintes restrições:

\begin{equation}
a_i = \max_{\forall v_j \in inputs(i)}(a_j + d_{j \to i})
\end{equation}

\begin{equation}
slew_i = \max_{\forall v_j \in inputs(i)}(slew_{j \to i})
\end{equation}

Se $v_i \in V$ é um pino de entrada de uma porta lógica e $v_j \in V$ é o \textit{driver} da interconexão que conecta $v_j$ em $v_i$, o \textit{arrival time} e o \textit{slew} em $v_i$ são definidos por:

\begin{equation}
a_i = a_j + iD_{j \to i}
\end{equation}

\begin{equation}
slew_i = slew_j + iS_{j \to i}
\end{equation}

Após a propagação dos \textit{arrival times} em todos os pinos, é necessário realizar a propagação dos tempos requeridos, o que é feito percorrendo-se o grafo em ordem topológica reversa, a fim de obterem-se os valores dos \textit{slacks}. Em um pino de saída $v_i$ de uma porta lógica, o tempo requerido pode ser obtido facilmente, observando o menor dos tempos requeridos dentre os seus \textit{fanouts} e suas interconexões, ou seja:

\begin{equation}
r_i = \min_{\forall v_j \in fanouts(i)}(r_j - iD_{i \to j})
\end{equation}

Para se propagar o \textit{required time} do pino $v_j$ de saída de uma porta lógica para uma entrada $v_i$, utiliza-se o valor de \textit{delay} do arco que liga $v_i$ em $v_j$, o qual já foi calculado previamente:

\begin{equation}
r_i = r_j - d_{i \to j}
\end{equation}

A partir dos \textit{required times} e \textit{arrival times}, podemos determinar os \textit{slacks} nos  diversos pontos do circuito, através da equação:

\begin{equation}
slack_i = r_i - a_i
\end{equation}

Se em algum ponto $v_i$, $slack_i = 0$, então $v_i$ se encontra em um caminho crítico. Se $slack_i < 0$, então $v_i$ se encontra em um caminho que viola a restrição de desempenho.

O \textbf{pior slack} é definido como o menor valor de \textit{slack} entre as saídas primárias. O valor \textbf{total de slack negativo} é o somatório dos módulos dos \textit{slacks} negativos das saídas primárias.

\section{Implementação da Ferramenta de STA}
	\label{sec:implementacao_sta}
	Esta seção apresentará as estratégias utilizadas para o desenvolvimento da ferramenta de análise de \textit{timing}. Serão ilustradas as principais estruturas de dados, modelos de grafo, e serão apresentados também os algoritmos implementados na ferramenta desenvolvida.

	\subsection{O Modelo de Grafo Adotado}

As estruturas de dados utilizadas para armazenar os elementos do grafo são essencialmente listas ordenadas topologicamente. Em uma lista ordenada topologicamente, dado um elemento $i$, à esquerda necessariamente se encontram os elementos de mesmo ou menor nível lógico, e à direita, de nível igual ou maior, como mostrado na figura \ref{fig:grafo_lista_nivel_logico}. Da mesma maneira, os \textit{timing arcs} e as interconexões também são ordenados topologicamente, em suas respectivas listas. Com essa escolha, o algoritmo de análise de \textit{timing} estática passa a ser apenas de uma varredura em ordem, na lista de \textit{timing points}, atualizando a informação de \textit{timing} acumulada para cada vértice do grafo.

		\begin{figure}[ht]
		\begin{center}% TRIM = L D R U
		\includegraphics[width=\linewidth]{imagens/grafo_lista_nivel_logico.pdf}
		\caption{Na lista ordenada, observando o elemento \textit{u1:o}, os elementos de menor nível lógico (\textit{fonte, inp1, inp2, f1:q, u1:a, u1:b, u2:a}) se encontram à esquerda, e os de maior (\textit{u2:o, f1:d, out, terminal}) se encontram à direita.}
		\label{fig:grafo_lista_nivel_logico}
		\end{center}
		\end{figure}

	% , onde V é o conjunto dos pinos do circuito, ou \textit{timing points}. Um par de vértices, ou pinos, $v_i$ e $v_j \in V$, são conectados por uma aresta direcionada $(v_i,v_j) \in A$ se existe uma interconexão que liga $v_i$ em $v_j$, sendo que $v_i$ é um pino de saída de uma porta lógica e $v_j$ é o pino de entrada de outra porta lógica.

\subsection{Algoritmo de Análise de \textit{Timing} Estática}

Com o modelo de grafo definido e implementado em suas devidas estruturas de dados, a análise de \textit{timing} estática é realizada atualizando as informações de \textit{timing} de cada nodo do grafo de \textit{timing}, em ordem topológica, como mostrado no algoritmo \ref{algo:sta}.

\begin{algorithm}[ht]
\Entrada{Grafo de \textit{timing} $G(V, E)$}
\Saida{Informações de \textit{timing} para os elementos do grafo (\textit{timing points}, interconexões e \textit{timing arcs})}
\Para{ cada $v_i \in V$ em ordem topológica}{
	atualiza\_timing($v_i$)
}
\Para{ cada $v_i \in V$ em ordem topológica reversa}{
	atualiza\_folgas($v_i$)
}
\caption{Análise de \textit{timing} estática}
\label{algo:sta}
\end{algorithm}

No procedimento $atualiza\_timing$, do algoritmo \ref{algo:sta}, os \textit{slews} e \textit{arrival times} são propagados seguindo a política apresentada na seção \ref{sec:calculo_desempenho} e após todos os \textit{arrival times} serem calculados, as folgas são obtidas propagando-se os \textit{required times} em ordem topológica reversa, como foi apresentado também na seção \ref{sec:calculo_desempenho} correspondendo ao procedimento $atualiza\_folgas$.


\chapter{Experimentos}
\label{cap:experimentos}

Esse capítulo tem por objetivo descrever os experimentos realizados e apresentar os resultados obtidos. Na seção \ref{sec:metodologia}, será apresentada a metodologia utilizada para realização dos experimentos. Na seção  \ref{sec:validacao_lumped}, é apresentado o primeiro experimento, que trata da validação da ferramenta perante o \textit{PrimeTime}, utilizando o modelo de interconexões de capacitância concentrada. Na seção \ref{sec:sta_industrial} será apresentada a maneira como o \textit{PrimeTime} modela o circuito, e como as informações de \textit{timing} são calculadas. A seção \ref{sec:validacao_ceff} tem por objetivo mostrar os resultados obtidos com a técnica de cálculo de capacitância efetiva e degradação do \textit{slew} implementadas neste trabalho. E por fim, serão apresentados os resultados obtidos utilizando algumas variações nos modelos de atraso, na seção \ref{sec:variacoes}.

\section{Metodologia Experimental}
\label{sec:metodologia}
%\afazer{A COMPLETAR}

Para realizar a avaliação das técnicas abordadas neste trabalho, uma ferramenta para análise de \textit{timing} na linguagem de programação C++ foi implementada. A ferramenta realiza a análise de \textit{timing} e considera dois possíveis modelos de interconexão: o modelo da capacitância concentrada e o modelo RC concentrado.

Como parte dos experimentos é realizada comparando as informações calculadas pela ferramenta implementada com as informações reportadas pelo \textit{PrimeTime}, o erro relativo (equação \ref{eq:erro_relativo}) foi adotado como métrica para a qualidade das informações de \textit{timing} reportadas pela ferramenta implementada neste trabalho.
	
\begin{equation}
\label{eq:erro_relativo}
Erro\ Relativo(a, b) = \frac{a - b}{b}
\end{equation}

Neste trabalho, esta métrica  foi utilizada para comparar diretamente dois valores $a$ e $b$, em ponto flutuante, sendo $a$ a informação de \textit{timing} calculada pela ferramenta apresentada neste trabalho e $b$, a informação de \textit{timing} reportada pelo \textit{PrimeTime}, para cada \textit{timing point} do circuito. 

Por exemplo, supondo que o valor aproximado $a = 3.12534$ e o valor real $b = 3.12566$. Aplicando a equação \ref{eq:erro_relativo} obtemos $Erro\ Relativo(a, b) = -0.000102378$, ou $-0.010237838\%$. O valor negativo implica que o valor aproximado $a$ subestima o valor real $b$ em $0.01\%$.

\subsection{Infraestrutura Experimental}

Este trabalho utilizará como base a infraestrutura disponibilizada pela competição de \textit{gate sizing} discreto do ISPD de 2013, a qual fornece:

\begin{itemize}

\item Um conjunto de 8 circuitos da competição do ISPD de 2013:
	\begin{enumerate}
	\item \textbf{$usb\_phy$}: com 511 células combinacionais, 98 células sequenciais, 15 entradas e 19 saídas primárias;
	\item \textbf{$pci\_bridge32$}: com 27316 células combinacionais, 3359 células sequenciais, 160 entradas e 201 saídas primárias;
	\item \textbf{$fft$}: com 30297 células combinacionais, 1984 células sequenciais, 1026 entradas e 1026 saídas primárias;
	\item \textbf{$cordic$}: com 40371 células combinacionais, 1230 células sequenciais, 34 entradas e 64 saídas primárias;
	\item \textbf{$des\_perf$}: com 103842 células combinacionais, 8802 células sequenciais, 234 entradas e 201 saídas primárias;
	\item \textbf{$edit\_dist$}: com 125000 células combinacionais, 5661 células sequenciais, 2562 entradas e 12 saídas primárias;
	\item \textbf{$matrix\_mult$}: com 30297 células combinacionais, 1984 células sequenciais, 3202 entradas e 1600 saídas primárias;
	\item \textbf{$netcard$}: com 884427 células combinacionais, 97831 células sequenciais, 1836 entradas e 10 saídas primárias.
	\end{enumerate}

\item Uma biblioteca \textit{standard cell} realista, composta por onze células combinacionais de diversas funções lógicas e um célula sequencial;

\item Uma ferramenta de análise de \textit{timing} estática PrimeTime \textregistered \ da empresa \citacaoInline{PrimeTime12}  para comparação de resultados;
\end{itemize}

Os circuitos são compostos por descrições no formato Verilog, capacitâncias parasitas e resistências descritas no formato IEEE SPEF (\textit{Standard Parasitic Exchange Format}) \citacaoAzul{IEEE99}, e restrições de \textit{timing} descritas no formato SDC (\textit{Synopsys Design Constraints}).

	\section{Validação do Modelo de Capacitância Concentrada Perante Ferramenta Industrial}
	\label{sec:validacao_lumped}

Este experimento tem por objetivo validar a ferramenta de \textit{STA} desenvolvida perante a ferramenta industrial \textit{PrimeTime}, utilizando a abordagem de capacitância concentrada para modelar as interconexões. No experimento, os valores de tempo de execução (\textit{runtime}), erro médio, erro mínimo e erro máximo\footnote{Os erros foram obtidos utilizando a equação \ref{eq:erro_relativo} e seus valores absolutos são apresentados na tabela, e.g., um erro de 2\% é menor que um de -3\% porque $|2| < |3|$. } foram obtidos para os 7 circuitos da competição de \textit{sizing} do \textit{ISPD}. Na Tabela \ref{tab:lumped_capacitance_vs_primetime}, a informação de \textit{runtime} se refere ao tempo gasto para se realizar uma análise de \textit{timing} estática, desconsiderando os tempos de inicialização das ferramentas comparadas \footnote{O tempo  de inicialização, neste contexto, se refere ao tempo de leitura dos arquivos de entrada e inicialização das estruturas de dados necessárias para a análise de \textit{timing} estática.}. Para tanto, utilizou-se um computador \textit{desktop} com processador Intel Core i7, de 4 núcleos, e 4GB de \textit{RAM}.



\begin{table}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/comparacoes/lumped_capacitance_vs_primetime.pdf}
\caption{Comparação das informações de \textit{timing} calculadas pela ferramenta implementada \textit{versus} informações fornecidas pelo \textit{PrimeTime}, utilizando o modelo de interconexões de capacitância concentrada.}
\label{tab:lumped_capacitance_vs_primetime}
\end{center}
\end{table}


Os erros apresentados na tabela \ref{tab:lumped_capacitance_vs_primetime} foram calculados sobre o \textit{arrival time}, \textit{slew} e \textit{slack} para cada \textit{timing point} do circuito, em relação às informações reportadas pelo \textit{PrimeTime}.

Note que na tabela \ref{tab:lumped_capacitance_vs_primetime}, os erros estão muito próximos de $0$, exceto no circuito $cordic$, onde o erro de $12\%$ se justifica por se tratar de valores muito pequenos, quando comparados, podem apresentar um erro relativo muito grande \footnote{No circuito $cordic$, nos pinos $g744540:a$, $g744569:o$, $g744569:a$, $g744621:o$ e $g744621:b$, a ferramenta reporta $0.00397127$ para \textit{slack} contra $0.004517$ do \textit{PrimeTime}. Aplicando a equação \ref{eq:erro_relativo}, obtém-se $erro = -0.1208169139$. Porém, ao avaliar o erro absoluto, conclui-se que as duas ferramentas fornecem valores iguais até a $3^{\underline{a}}$ casa decimal, sendo uma precisão aceitável neste contexto.}.

A partir das informações de \textit{runtime} obtidas na tabela \ref{tab:lumped_capacitance_vs_primetime}, observa-se que a média dos \textit{runtimes} da ferramenta desenvolvida é de cerca de 50 vezes menor que a média dos \textit{runtimes} do \textit{PrimeTime}, sendo que no circuito $usb\_phy$, a diferença é de 20 vezes, e no circuito $fft$, a diferença chega a ser de aproximadamente 98 vezes. Essa diferença nos \textit{runtimes} é justificável, já que a ferramenta da \textit{Synopsys} realiza o levantamento de diversas informações, além das abordadas neste trabalho.

	\section{Análise de \textit{Timing} Estática em Ferramenta Industrial}
	\label{sec:sta_industrial}
	
Esta seção tem por objetivo apresentar o modelo (Figura \ref{fig:modelagem_primetime}) utilizado para cálculo do desempenho na ferramenta industrial \textit{PrimeTime} e apresentar algumas informações de \textit{timing} relevantes, obtidas para cada circuito da competição de \textit{sizing} do ISPD.

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/modelo_primetime.png} 
\caption{Modelagem utilizada no \textit{PrimeTime} para o \textit{driver}, interconexão e destinos. Obtida de \citacaoAzul{Ptug13}.}
\label{fig:modelagem_primetime}
\end{center}
\end{figure}


\subsection{Modelagem de \textit{Driver} (\textit{Driver model})}

No \textit{PrimeTime}, o \textit{driver} é modelado utilizando uma rampa de tensão em série com um resistor (um modelo Thèvenin). O resistor ajuda a suavizar a rampa de tensão, para que a forma de onda resultada seja similar à forma de onda do \textit{driver} real, que está conectado na interconexão.

De acordo com \citacaoAzul{Ptug13}, o modelo de \textit{driver} tem três parâmetros: 
\begin{itemize}
\item A resistência do \textit{driver} $R_d$;
\item O tempo de início da rampa $t_Z$;
\item A duração da rampa $\Delta t$.
\end{itemize}

 O \textit{PrimeTime} escolhe os parâmetros de modo que a forma de onda de saída seja o mais próximo possível da simulação. O modelo de \textit{driver} simplificado é construído para cada \textit{timing arc} de cada porta lógica do circuito.

\subsection{Modelagem do Destino (\textit{Receiver model})}
Cada destino da interconexão é representado como um valor de capacitância, que corresponde à capacitância do pino em que a interconexão está ligada.

\subsection{Modelagem da Interconexão (\textit{Reduced-order network model})}

Um modelo reduzido de interconexão é uma representação simplificada de uma interconexão, com as mesmas características de resposta da interconexão original, a qual pode ter centenas de capacitâncias e resistências. O \textit{PrimeTime} utiliza a redução de Arnoldi \citacaoAzul{Odabasioglu1997} \citacaoAzul{Silveira1999} para criar um modelo reduzido. Através do modelo reduzido, a ferramenta escolhe valores para a $C_{eff}$, de modo que o atraso do \textit{driver} seja igual ao atraso do \textit{driver} ligado à interconexão original. Por falta de fontes na bibliografia, não foi possível implementar este método de ajuste da $C_{eff}$, impossibilitando uma comparação mais justa.

Não foi possível identificar o algoritmo para o cálculo do atraso das interconexões no \textit{PrimeTime}.

\subsection{Resultados Obtidos}

A tabela \ref{tab:comparacoes_primetime} mostra os valores obtidos pelo \textit{PrimeTime}, para cada um dos seis circuitos da competição de \textit{sizing} do ISPD. As informações obtidas no experimento foram:
\begin{itemize}
\item \textbf{\textit{TNS (Total Negative Slack)}: } O somatório de \textit{slack} negativo nas saídas primárias.

\item \textbf{\textit{Violating POs: }} Número de saídas primárias violando a restrição de desempenho mínimo.

\item \textbf{\textit{Runtime (s): }} Tempo de execução, em segundos, para realizar uma análise de \textit{timing} em um circuito.

\item \textbf{\textit{Critical Path: }} Valor do caminho crítico do circuito.
\end{itemize}

A última linha apresenta a média dos valores calculados para cada coluna da tabela. Esses valores de média serão comparados em experimentos futuros.

\begin{table}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/comparacoes/primetime.pdf}
\caption{Valores obtidos pelo \textit{PrimeTime} nos circuitos da competição de \textit{sizing} do ISPD.}
\label{tab:comparacoes_primetime}
\end{center}
\end{table}

\section{Validação da Técnica Implementada Perante Ferramenta Industrial}
\label{sec:validacao_ceff}
	
Esta seção tem por objetivo comparar a qualidade das informaçoes de \textit{timing} obtidas pela ferramenta de análise de \textit{timing} implementada neste trabalho com  as informações reportadas pelo \textit{PrimeTime}. Utilizando a técnica de cálculo de capacitância efetiva, atraso de interconexões e degradação de \textit{slew}, apresentada na seção \ref{sec:calculo_ceff_degradacao}. A análise de \textit{timing} estática foi aplicada nos sete circuitos da competição de \textit{sizing} do ISPD e suas soluções foram comparadas com o \textit{PrimeTime}, utilizando a métrica apresentada na seção \ref{sec:metodologia}.

\begin{table}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/comparacoes/ceff_elmore_slew.pdf}
\caption{Valores obtidos pela ferramenta implementada neste trabalho nos circuitos da competição de \textit{sizing} do ISPD.}
\label{tab:ceff_elmore_slew}
\end{center}
\end{table}

\begin{table}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/comparacoes/puri_ln2.pdf}
\caption{Valores obtidos pela ferramenta implementada neste trabalho, utilizando o fator de \textit{scaling} no atraso de Elmore, nos circuitos da competição de \textit{sizing} do ISPD.}
\label{tab:puri_ln2}
\end{center}
\end{table}

A tabela \ref{tab:ceff_elmore_slew} mostra os valores obtidos pela ferramenta implementada neste trabalho, para cada um dos sete circuitos da competição de \textit{sizing} do ISPD. A penúltima linha apresenta a média dos valores de cada coluna, e a última linha apresenta a média dos erros em relação aos valores reportados pelo \textit{PrimeTime}, apresentadas na tabela \ref{tab:comparacoes_primetime}.

Observa-se que os valores obtidos para \textit{TNS} e \textit{critical path}, neste experimento, são muito pessimistas em relação ao \textit{PrimeTime} ($49.34\%$ e $25.73\%$ respectivamente) e portanto, foi proposta uma modificação na técnica de cálculo do atraso das interconexões, utilizando um fator de \textit{scaling} para o atraso de Elmore. As informações obtidas pela técnica modificada podem ser visualizadas na tabela \ref{tab:puri_ln2}. Desta vez, os erros em relação ao \textit{PrimeTime} são bem menores (cerca de $4\%$), porém, subestimando o valor real.

A análise de \textit{timing} do \textit{PrimeTime} realiza outras avaliações além das abordadas neste trabalho. Isso justifica o alto valor de \textit{runtime} do \textit{PrimeTime} em relação ao da ferramenta implementada.

\subsection{Relação entre $C_{eff}$ e $C_{total}$}

Neste experimento, foram obtidas as relações $C_{eff}/C_{total}$ para todas as interconexões dos circuitos $pci\_bridge32$ e $matrix\_mult$ e os histogramas com as distribuições de frequências para estas relações são apresentados nas figuras \ref{fig:pci_bridge32_resistance} e \ref{fig:matrix_mult_resistance}.

%
%\begin{figure}[ht]
%%\begin{center}% TRIM = L D R U
%\subfigure[]
%{
%\includegraphics[width=\linewidth]{imagens/experimentos/pci_bridge32_slew_full.pdf}
%\label{fig:pci_bridge32_slew_full}
%}
%\subfigure[]
%{
%\includegraphics[width=\linewidth]{imagens/experimentos/pci_bridge32_slew_zoom.pdf}
%\label{fig:pci_bridge32_slew_zoom}
%}
%
%\caption{Distribuição das frequências das relações $C_{eff}/C_{total}$ das interconexões do circuito $pci\_bridge32$. (a) é a apresentação de todas as frequências no histograma e em (b) o eixo das frequências é limitado em 100 ocorrências. Cada gráfico é dividido em três partes: na primeira, as frequências são das interconexões com os menores valores de \textit{slew} de entrada; Na segunda parte, das com \textit{slew} médio. E na terceira, das com maiores \textit{slews}.}
%\end{figure}
%
%A figura \ref{fig:pci_bridge32_slew} mostra a distribuição das frequências da relação $C_{eff}/C_{total}$ de cada interconexão no circuito $pci\_bridge32$. Os dois gráficos representam o mesmo conjunto de dados, sendo que no gráfico da letra (a) todos os valores de frequência são mostrados, e no gráfico da letra (b), o valor de frequência é limitado em 100. Cada gráfico é dividido em três partes, sendo que na primeira, em verde, é mostrada a distribuição de frequências para o primeiro \textit{terço} das interconexões, ordendadas pelo \textit{slew} de entrada, ou seja, as interconexões com os menores valores de \textit{slew} na saída de seus \textit{drivers}. A segunda parte, em vermelho, mostra a distribuição de frequências para segundo terço das interconexões. E a última parte, em azul, mostra as frequências para o terceiro terço, ou seja, das interconexões com os maiores valores de \textit{slew} na saída de seus \textit{drivers}.


\begin{figure}[ht]
%\begin{center}% TRIM = L D R U
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/experimentos/pci_bridge32_resistance_full.pdf}
\label{fig:pci_bridge32_resistance_full}
}
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/experimentos/pci_bridge32_resistance_zoom.pdf}
\label{fig:pci_bridge32_resistance_zoom}
}
\caption{Distribuição das frequências das relações $C_{eff}/C_{total}$ das interconexões do circuito $pci\_bridge32$. Na primeira parte, as frequências são das interconexões com menor valor de resistência total, na segunda parte, das com valor de resistência total médio, e na terceira, das com maiores valores de resistência total.}
\label{fig:pci_bridge32_resistance}

\end{figure}

O experimento apresentado na  figura \ref{fig:pci_bridge32_resistance} mostra a relação $C_{eff}/C_{total}$ nas interconexões do circuito $pci\_bridge32$ e é dividido em três partes. A primeira em verde, apresenta as frequências das relações $C_{eff}/C_{total}$ nas interconexões com menor valor de resistência; a segunda parte, em vermelho, mostra a distribuição das frequências nas interconexões com valor médio de resistência; e a última parte, em azul, mostra as frequências para a última parte das interconexões, ou seja, as com maior valor de resistência total. Note que na figura \ref{fig:pci_bridge32_resistance_full} todos os valores de frequência são mostrados, e na figura \ref{fig:pci_bridge32_resistance_zoom}, apenas os valores de frequência menores que 200 são mostrados.

Os mesmo experimento apresentado na figura \ref{fig:pci_bridge32_resistance} foi também realizado para o circuito $matrix\_mult$ e seu resultado pode ser visualizado na figuras \ref{fig:matrix_mult_resistance}.
%
%\begin{figure}[ht]
%%\begin{center}% TRIM = L D R U
%\subfigure[]
%{
%\includegraphics[width=\linewidth]{imagens/experimentos/matrix_mult_slew_full.pdf}
%\label{fig:matrix_mult_slew_full}
%}
%\subfigure[]
%{
%\includegraphics[width=\linewidth]{imagens/experimentos/matrix_mult_slew_zoom.pdf}
%\label{fig:matrix_mult_slew_zoom}
%}
%\caption{Distribuição das frequências das relações $C_{eff}/C_{total}$ das interconexões do circuito $matrix\_mult$. (a) é a apresentação de todas as frequências no histograma e em (b) o eixo das frequências é limitado em 100 ocorrências. Cada gráfico é dividido em três partes: na primeira, as frequências são das interconexões com os menores valores de \textit{slew} de entrada; Na segunda parte, das com \textit{slew} médio. E na terceira, das com maiores \textit{slews}.}
%\label{fig:matrix_mult_slew}
%
%\end{figure}

\begin{figure}[ht]
%\begin{center}% TRIM = L D R U
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/experimentos/matrix_mult_resistance_full.pdf}
\label{fig:matrix_mult_resistance_full}
}
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/experimentos/matrix_mult_resistance_zoom.pdf}
\label{fig:matrix_mult_resistance_zoom}
}
\caption{Distribuição das frequências das relações $C_{eff}/C_{total}$ das interconexões do circuito $matrix\_mult$. Na primeira parte, as frequências são das interconexões com menor valor de resistência total, na segunda parte, das com valor de resistência total médio, e na terceira, das com maiores valores de resistência total.}
\label{fig:matrix_mult_resistance}

\end{figure}

Analisando os histogramas apresentados nesse experimento, observa-se que na grande maioria das interconexões, a relação $C_{eff}/C_{total}$ é próxima de $1$. Isso se dá pelo fato de que a maioria das interconexões ou são pequenas, ou não possuem muitas resistências, já que a relação $C_{eff}/C_{total}$ é inversamente proporcional ao efeito de \textit{resistive shielding}, o que pode ser melhor visualizado nos histogramas das figuras \ref{fig:pci_bridge32_resistance} e \ref{fig:matrix_mult_resistance}. 

%\afazer{CONCLUSÃO EM RELAÇÃO AO SLEW}

\subsection{Nível Lógico \textit{versus} Erro Relativo}

Neste experimento os erros relativos percentuais foram obtidos para os \textit{arrival times} de saída de cada porta lógica dos circuitos $pci\_bridge32$ e $matrix\_mult$, em relação aos \textit{arrival times} reportados pelo \textit{PrimeTime}.

As figuras \ref{fig:pci_bridge32_logic-level_x_relative-error} e \ref{fig:matrix_mult_logic-level_x_relative-error} mostram os erros distribuídos pelos níveis lógicos nos circuitos $pci\_bridge32$ e $matrix\_mult$, respectivamente. Em azul, estão apresentados os pontos de cada \textit{arrival time} de saída. Na curva em vermelho, são mostrados os erros para os \textit{arrival times} de saída das portas pertencentes ao caminho crítico. Na curva em verde, são mostrados os erros referentes às portas pertencentes ao caminho com o maior número de portas.

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/pci_bridge32_logic-level_x_relative-error.png}
\caption{Erro relativo dos \textit{arrival times} em relação aos resultados obtidos pelo \textit{PrimeTime}, ao decorrer dos níveis lógicos, no \textit{benchmark} $pci\_bridge32$. O \textit{arrival time} utilizado na comparação é o \textit{arrival time} no \textit{timing point} de saída de cada porta lógica. Em azul, cada ponto representa uma porta lógica. Em vermelho, é a curva referente às portas lógicas pertencentes ao caminho crítico. A curva em verde, é referente às portas lógicas pertencentes ao maior caminho, ou seja, ao caminho com maior número de portas.}
\label{fig:pci_bridge32_logic-level_x_relative-error}
\end{center}
\end{figure}

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/matrix_mult_logic-level_x_relative-error.png}
\caption{Erro relativo dos \textit{arrival times} em relação aos resultados obtidos pelo \textit{PrimeTime}, ao decorrer dos níveis lógicos, no \textit{benchmark} $matrix\_mult$. O \textit{arrival time} utilizado na comparação é o \textit{arrival time} no \textit{timing point} de saída de cada porta lógica. Em azul, cada ponto representa uma porta lógica. Em vermelho, é a curva referente às portas lógicas pertencentes ao caminho crítico. A curva em verde, é referente às portas lógicas pertencentes ao maior caminho, ou seja, ao caminho com maior número de portas.}
\label{fig:matrix_mult_logic-level_x_relative-error}
\end{center}
\end{figure}

Ao analisar os gráficos das figuras \ref{fig:pci_bridge32_logic-level_x_relative-error} e \ref{fig:matrix_mult_logic-level_x_relative-error}, observa-se que tanto os erros grandes, quanto os erros pequenos dos primeiros níveis lógicos, ao serem propagados, são estabilizados, em cerca de -20\%, o que se reflete também nos erros dos caminhos críticos e maiores caminhos.

\section{Variações no Modelo de Atraso Comparadas à Ferramenta Industrial}
\label{sec:variacoes}
Nesta seção serão apresentados dois experimentos que foram efetuados realizando algumas variações nos modelos de atrasos. Os resultados desses experimentos podem ser conferidos nas tabelas \ref{tab:lump_elmore_slew} e \ref{tab:ceff_elmore_no_slew}. A penúltima linha de cada uma das tabelas apresentam a média dos valores de cada uma das colunas, e a última linha apresenta os erros, calculados com a métrica apresentada na seção \ref{sec:metodologia}, em relação às médias obtidas pelo \textit{PrimeTime}, apresentadas na tabela \ref{tab:comparacoes_primetime}.

\begin{table}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/comparacoes/lump_elmore_slew.pdf}
\caption{Experimentos utilizando o modelo capacitância concentrada para carga de saída dos \textit{drivers}, técnica de Elmore para computar os atrasos das interconexões, e degradação do \textit{slew} conforme apresentado no capítulo \ref{cap:tecnica}.}
\label{tab:lump_elmore_slew}
\end{center}
\end{table}


No experimento mostrado na Tabela \ref{tab:lump_elmore_slew}, o modelo de capacitância concentrada foi utilizado para modelar a carga vista pelo \textit{driver}. Para o atraso das interconexões, a técnica de Elmore foi utilizada. E para a degradação do \textit{slew}, foi utilizada a técnica descrita no capítulo \ref{cap:tecnica}. Como esperado, os erros neste experimento são maiores que os erros do experimento original, mostrado na seção \ref{sec:validacao_ceff}, já que neste experimento, os \textit{drivers} vêem a capacitância total das interconexões em suas saídas, reportando resultados pessimistas para os atrasos de seus \textit{timing arcs}.

\begin{table}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/comparacoes/ceff_elmore_no_slew.pdf}
\caption{Experimentos utilizando o modelo capacitância efetiva para carga de saída dos \textit{drivers}, técnica de Elmore utilizando as capacitâcias efetivas de cada nodo interno das interconexões, para computar seus atrasos. Neste experimento, a degradação do \textit{slew} não foi considerada.}
\label{tab:ceff_elmore_no_slew}
\end{center}
\end{table}

Por fim, o experimento da tabela \ref{tab:ceff_elmore_no_slew} utiliza a abordagem de capacitância efetiva, como apresentada no capítulo \ref{cap:tecnica}, porém, sem considerar a degradação do \textit{slew}. Os erros globais parecem ser razoáveis (\textit{TNS:} 7.24\% e \textit{Critical Path: } 5.15\%), porém é necessário uma análise com detalhe das informações locais das portas lógicas. Como a degradação do \textit{slew} não é considerada, as informações locais podem conter erros.

\chapter{Conclusão}
\label{cap:conclusao}

A consideração do atraso das interconexões no fluxo \textit{standard cell} é muito importante e a avaliação desses atrasos deve ser eficiente e precisa. A abordagem da capacitância efetiva para interconexões implica na consideração do efeito de \textit{resistive shielding}, o qual impacta na qualidade do cálculo do atraso do circuito. A ferramenta de análise de \textit{timing} desenvolvida neste trabalho implementa a técnica de \citacaoInline{PURI02} utilizando $ln(2)$ como fator de \textit{scaling} no atraso de Elmore. Tal ferramenta apresentou ser eficiente em termos de \textit{runtime}, obtendo resultados bons\footnote{Quando comparados ao \textit{PrimeTime}.} na análise de \textit{timing}.

\section{Trabalhos Futuros}
	Possíveis trabalhos futuros podem ser feitos na melhoria da ferramenta de análise de \textit{timing} implementada, entre elas:
	
	\begin{itemize}
		\item A implementação de modelos reduzidos para os \textit{drivers};
		\item A implementação de modelos de ordem reduzida para as interconexões, a fim de estabelecer comparações;
		\item Implementação de diferentes técnicas para obtenção da capacitância efetiva;
		\item Análise da propagação do \textit{slew} e o seu impacto em um contexto de análise de \textit{timing} estática.
	\end{itemize}

% \chapter{Anexos}
% 	\section{Código Fonte em C++ da Ferramenta Desenvolvida}

% 		\lstinputlisting[label=timing_analysis.cpp,caption=timing\_analysis.cpp]{../implementacao/TimingAnalysis/src/timing_analysis.cpp}


%--------------------------------------------------------
% Elementos pós-textuais
\bibliography{Relatorio}

\end{document}
