%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Universidade Federal de Santa Catarina             
% Biblioteca Universitária                     
%----------------------------------------------------------------------
% Exemplo de utilização da documentclass ufscThesis
%----------------------------------------------------------------------                                                           
% (c)2010 Roberto Simoni (roberto.emc@gmail.com)
%         Carlos R Rocha (cticarlo@gmail.com)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{ufscThesis} % Definicao do documentclass ufscThesis

%----------------------------------------------------------------------
% Pacotes usados especificamente neste documento
\usepackage{graphicx} % Possibilita o uso de figuras e gráficos
\usepackage{color, colortbl}    % Possibilita o uso de cores no documento
\usepackage{multirow}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage[labelsep=endash]{caption}
\usepackage{mathtools}
\usepackage{listings}
\usepackage[portugues, lined,boxed,ruled,commentsnumbered]{algorithm2e}
\usepackage{float}



%----------------------------------------------------------------------
% Comandos criados pelo usuário
\newcommand{\afazer}[1]{{\color{red}{#1}}} % Para destacar uma parte a ser trabalhada

%----------------------------------------------------------------------
% Identificadores do trabalho
% Usados para preencher os elementos pré-textuais
\instituicao[a]{Universidade Federal de Santa Catarina} % Opcional
\departamento[a]{Departamento de Informática e Estatística}
\curso[o]{Curso de Bacharelado em Ciências da Computação}
%\documento[a]{TCC} % Opcional (Tese é o padrão)
\titulo{Análise de \textit{Timing} Estática e a Avaliação do Impacto do Atraso das Interconexões em Circuitos Digitais}
%\subtitulo{Considerando Atraso de Interconexões} % Opcional
\autor{Chrystian de Sousa Guth}
\grau{Bacharel em Ciências da Computação}
\local{Florianópolis - Santa Catarina} % Opcional (Florianópolis é o padrão)
\data{02}{Julho}{2013}
\orientador[Orientador]{M.Sc. Vinícius dos Santos Livramento}
\coorientador[Coorientador]{Prof. Dr. José Luís Almada Güntzel}
\coordenador[Coordenador]{Prof. Dr. Renato Cislaghi}

\numerodemembrosnabanca{3} % Isso decide se haverá uma folha adicional
\orientadornabanca{sim} % Se faz parte da banca definir como sim
\coorientadornabanca{sim} % Se faz parte da banca definir como sim
%\bancaMembroA{Vinicius dos Santos Livramento} %Nome do presidente da banca
\bancaMembroB{Dr. Renan Alves Fonseca}      % Nome do membro da Banca
%\bancaMembroC{Prof. Dr. Luiz Cláudio Villar dos Santos}     % Nome do membro da Banca
%\bancaMembroD{Quarto membro}       % Nome do membro da Banca
%\bancaMembroE{Prof. quinto membro}       % Nome do membro da Banca
%\bancaMembroF{Prof. sexto membro}        % Nome do membro da Banca
%\bancaMembroG{Prof. sétimo membro}       % Nome do membro da Banca


\textoResumo {
Análise de \textit{Timing} Estática (\textit{STA: Static Timing Analysis}) é a técnica mais utilizada para estimar o atraso de circuitos digitais durante o fluxo de síntese física. Com o advento das tecnologias CMOS nanométricas, o atraso das interconexões passou a ser dominante em relação ao atraso das portas lógicas e, por este motivo, não pode mais ser desprezado. Além disso, técnicas pessimistas para o cálculo do atraso de interconexões, como o de Elmore, não são não são precisas o suficiente para modelar o atraso em circuitos contemporâneos. Este trabalho tem por objetivo pesquisar, implementar e validar uma técnica de STA contra uma ferramenta industrial.
}
\palavrasChave {Automação de Projeto Eletrônico (EDA), Biblioteca \textit{Standard Cell}, Análise de \textit{Timing} Estática \textit{(STA)}, \textit{Complementary Metal-Oxide Semiconductor}}

\textAbstract {Here is written the abstract of the document}

\keywords {key 1. key 2. ... key n.}

%----------------------------------------------------------------------
% Início do documento                                
\begin{document}
%--------------------------------------------------------
% Elementos pré-textuais
\capa  
\folhaderosto[comficha] % Se nao quiser imprimir a ficha, é só não usar o parâmetro
\folhaaprovacao
\paginadedicatoria
\paginaagradecimento
% \paginaepigrafe
\paginaresumo
\paginaabstract
\listadefiguras
\listadetabelas 
% \listadeabreviaturas
% \listadesimbolos
\sumario
%--------------------------------------------------------
% Elementos textuais
\chapter{Introdução}
	
Este capítulo tem por objetivo, apresentar uma visão geral sobre o fluxo de projeto \textit{standard cell} e a importância da análise de \textit{timing} estática (\textit{STA: Static Timing Analysis}) no desenvolvimento de circuitos digitais. Será apresentada também a motivação e a justificativa deste trabalho.

\section{Fluxo de Projeto \textit{Standard Cell}}

Com o crescimento na dimensão dos circuitos digitais contemporâneos\footnote{Um processador para \textit{desktop} desenvolvido no ano de 2008 tem cerca de 731 milhões de transistores, excluindo a área de memória \cite{Intel08}.} e a necessidade de um tempo de entrega ao mercado (\textit{time-to-market}) curto faz com que esses projetos adotem o fluxo de projeto \textit{standard cell} (Figura \ref{fig:fluxo_standard_cell}).

No fluxo \textit{standard cell} as células são desenvolvidas e verificadas previamente em uma dada tecnologia. Essas células \footnote{Célula é a instância de uma porta lógica.} são registradas com suas diversas características elétricas e tabelas (\textit{lookup tables}) de atraso em uma biblioteca de células, sendo reutilizadas em diversos projetos na mesma tecnologia. O reuso amortiza o custo dos projetos inseridos neste nodo tecnológico e possibilita um \textit{time-to-market} mais curto.

O fluxo \textit{standard cell} pode ser subdividido em etapas, e ao decorrer dessas etapas, a análise de \textit{timing} pode ser requisitada milhares de vezes. De acordo com \citeonline{BhaskerChadha09}, essas são algumas das etapas importantes no fluxo:


\begin{figure}[ht]
\begin{center}
\includegraphics[width=\linewidth]{imagens/fluxo_standard_cell.pdf}
\caption{Fluxo de projeto \textit{Standard Cell}. Adaptado de \cite{BhaskerChadha09}.}
\label{fig:fluxo_standard_cell}
\end{center}
\end{figure}

\begin{itemize}
\item \textbf{Síntese: } Responsável por criar uma representação em nível de portas lógicas, a partir de uma descrição no nível de transferência entre registradores (\textit{RTL: Register Transfer Level}). A partir desta etapa, a análise de \textit{timing} estática (\textit{STA: Static Timing Analysis}) é utilizada, para apurar as informações \textit{temporais} do circuito;

\item \textbf{Otimização Lógica: } Responsável por minimizar a lógica do circuito sintetizado. A análise de \textit{timing} estática pode ser realizada antes desta etapa, para verificar os piores caminhos ou os caminhos críticos. Se a análise de \textit{timing} for realizada depois desta etapa, o objetivo é identificar quais caminhos ainda precisam ser otimizados ou identificar os caminhos críticos;

\item \textbf{Posicionamento: } Define a localização espacial dos \textit{layouts} das células. Antes dessa etapa, modelos de interconexão ideais são adotados, pois ainda não se possui as informações necessárias de posicionamento. Uma maneira alternativa para se modelar as interconexões, é utilizar um modelo de \textit{wireload}, que estima o tamanho das interconexões de acordo com o seu número de destinos, ou \textit{fanouts};

\item \textbf{Síntese da Árvore de Relógio: } No início da síntese física, as árvores dos relógios são consideradas como ideal, ou seja, não possuem atraso de propagação. O objetivo desta etapa é minimizar o \textit{clock skew}, que é a diferença entre os tempos de chegada nas entradas dos registradores. A análise de \textit{timing} estática é importante nesta etapa, para avaliar essas diferenças nos tempos de chegada.

\item \textbf{Roteamento: } Responsável por criar as conexões entre as diferentes células incluídas no projeto, utilizando as diferentes camadas de metal. Antes desta etapa, o tamanho das conexões, ou \textit{vias} são estimadas para obter os parasitas em forma de capacitâncias e resistências.
\end{itemize}

Os projetos de circuitos digitais no fluxo \textit{standard cell} são realizados visando, além das funcionalidades do projeto, a operação em uma frequência especificada. Por isso, diversas otimizações são efetuadas ao longo do fluxo, para que todos os recursos e tarefas do dispositivo consigam ser concluídas na frequência definida. Nas primeiras etapas de um projeto no fluxo \textit{standard cell}, apenas as questões relacionadas à funcionalidade do projeto são verificadas, pois ainda, não se tem com precisão, as informações de atraso e informações elétricas necessárias, para realizar uma avaliação precisa de desempenho.



\section{Motivação}
%otimizações		como \textit{gate sizing} \cite{Livramento13} \cite{Hu12} \cite{Mohammad12}
% \textit{Placement} \cite{Shahookar91} 
No fluxo \textit{standard cell}, a partir do RTL, uma série otimizações são realizadas ao decorrer de suas etapas. Como consequência dessas otimizações, as topologias das interconexões se alteram, necessitando ao decorrer do fluxo, diversas avaliações de suas informações temporais.

Durante as otimizações nas etapas iniciais do fluxo (\textit{pre-layout}), a análise de \textit{timing} é requisitada milhares de vezes, sendo assim necessário, que a ferramenta de análise de \textit{timing} tenha o melhor desempenho possível. Como as informações relacionadas ao aspecto físico do circuito, como posicionamento \afazer{CITAR} e roteamento \afazer{CITAR} ainda não são definidas com precisão nas etapas iniciais, essas informações são aproximadas e a ferramenta de análise de \textit{timing} fornece dados pessimistas sobre o \textit{timing} do circuito.

Já nas etapas finais (\textit{pos-layout}), mais próximas da síntese física, a análise de \textit{timing} precisa ser a mais precisa possível, porém, a modelagem dos elementos dos circuitos digitais torna-se mais complexa, diminuindo o desempenho da ferramenta.

Como as informações \textit{timing} precisam ser avaliadas centenas ou milhares de vezes durante os processos de otimização, ferramentas de análise de \textit{timing} eficientes e escaláveis precisam ser desenvolvidas e aperfeiçoadas para acompanhar a evolução da tecnologia \textit{CMOS} (\textit{Complementary Metal-Oxide Semiconductor}).
		
%Em diversos sistemas projetados atualmente, cerca de 50\% a 70\% do ciclo de relógio é ``consumido'' pelo atraso de propagação de suas interconexões \cite{Cong96}. Nas tecnologias com alta escala de integração (\textit{VLSI: Very-large-scale integration}) atuais, onde diversas otimizações tem por objetivo reduzir a resistência dos \textit{drivers}, as interconexões passam a ser cada vez mais impactantes no desempenho do circuito digital.

	\section{Justificativa}

Diversas otimizações são realizadas no decorrer do fuxo de projeto \textit{standard cell} e o uso de ferramentas para a automação de projeto eletrônico (\textit{EDA: Electronic design automation}) é indispensável em suas diferentes etapas. A inexistência de ferramentas de análise de \textit{timing} estática precisas de domínio público e a restrição no acesso à ferramentas industriais (devido ao alto custo de suas licenças), resulta em um problema de infraestrutura de pesquisa. Assim, este trabalho terá como resultado, uma alternativa de ferramenta de análise de \textit{timing} para projetistas de circuitos digitais, bem como uma infraestrutura realista e precisa, para desenvolvedores de ferramentas, que necessitam da análise de \textit{timing}, em alguma etapa do fluxo de projeto \textit{standard cell}.

\section{Objetivos}

\subsection{Objetivo Geral}

Este trabalho tem por objetivo o projeto, avaliação, validação e documentação de uma ferramenta de análise de \textit{timing} voltada para o fluxo \textit{standard cell}. 

\subsection{Objetivos Específicos}

\begin{enumerate}

\item \label{objetivos:lumped}Implementar o modelo de interconexão com capacitância concentrada, desprezando-se o impacto das resistências; 
\item \label{objetivos:elmore} Implementar a técnica de Elmore para cálculo do atraso das interconexões baseando-se em um modelo de interconexão RC Concentrado;
\item  \label{objetivos:puri} Implementar a técinca para cálculo do atraso de interconexões utilizando a abordagem de capacitância efetiva, proposto por \citeonline{PURI02}; 
\item Construção de uma ferramenta de análise de \textit{timing} estática incluindo as funcionalidades descritas nos objetivos \ref{objetivos:lumped}, \ref{objetivos:elmore} e \ref{objetivos:puri}, bem como sua validação perante uma ferramenta de análise de \textit{timing} industrial.

\end{enumerate}

\section{Escopo}

			% \afazer{Talvez tirar a seção Objetivos e colocar essa como objetivos...}

%
%A ferramenta de Análise de \textit{Timing} desenvolvida será capaz de reportar informações de \textit{timing} de um circuito. As portas lógicas serão modeladas utilizando um modelo de atraso não-linear (NLDM: \textit{Non-Linear Delay Model}), onde seus atrasos são caracterizados por \textit{lookup tables}, fornecidas nas bibliotecas \textit{standard cells} atuais. As informações reportadas para as portas lógicas são: \textit{slacks, slews, arrival times}, caminho crítico, total de \textit{slack} negativo e pior \textit{slack}. Essas informações serão explicadas nos Capítulos \ref{cap:conceitos} e \ref{cap:sta}.
%
%Para as interconexões, dois modelos serão implementados: capacitância concentrada e o modelo RC concentrado. Seus atrasos serão calculados utilizando a técnica de \citeonline{Elmore48} e a técnica de capacitância efetiva de  \citeonline{PURI02}.
%			
%Os cada elemento sequencial será tratado como uma saída e uma entrada primária do circuito. Para simplificação do algoritmo de análise de \textit{timing}, tempos de \textit{setup}, \textit{hold} e carga não serão considerados.
%			
%Por fim, a qualidade das informações de \textit{timing} obtidas pela ferramenta serão comparadas com os dados obtidos pela ferramenta industrial PrimeTime \textregistered \ da \citeonline{PrimeTime12}.

\section{Infraestrutura Experimental}

Este trabalho utilizará como base, a infraestrutura disponibilizada pela competição de \textit{Gate Sizing} Discreto do ISPD de 2013 \cite{Contest2013}, a qual fornece:

\begin{itemize}

\item Um conjunto de 7 circuitos da competição do ISPD de 2013;

\item Uma biblioteca \textit{standard cell} realista, composta por onze células combinacionais de diversas funções lógicas e um célula sequencial;

\item Uma ferramenta de análise de \textit{timing} estática PrimeTime \textregistered \ da empresa \citeonline{PrimeTime12}  para comparação de resultados;
\end{itemize}

Os circuitos são compostos por descrições no formato Verilog, capacitâncias parasitas e resistências descritas no formato IEEE SPEF (\textit{Standard Parasitic Exchange Format}) \cite{IEEE99}, e restrições de \textit{timing} descritas no formato SDC (\textit{Synopsys Design Constraints}).
			
\section{Metodologia}
\afazer{como vou alcançar os objetivos?
		
passos metodológicos.}
		
\section{Organização Deste Trabalho}
\afazer{explicar como se organiza o trablaho}

\chapter{Conceitos Fundamentais de Circuitos Digitais}
\label{cap:conceitos}

Este capítulo apresenta os conceitos básicos relacionados à temporização e modelagem de circuitos digitais essenciais para o entendimento do presente trabalho. A seção \ref{sec:caracteristicas_temporais_portas_logicas} apresenta as características temporais das portas, assim como os modelos de atraso adotados em fluxo \textit{standard cell}. Nas seções \ref{sec:caracteristicas_temporais_interconexoes} e \ref{sec:modelos_interconexoes}, serão apresentadas as caracteristicas temporais das interconexões e seus modelos, respectivamente. As seções \ref{sec:calculo_capacitancia}, \ref{sec:atraso_interconexao} e \ref{sec:degradacao_slew} apresentarão uma introdução sobre o cálculo do atraso nas interconexões, bem como a degradação no slew, devido ao comportamento resistivo das interconexões.

\section{Características Temporais das Portas Lógicas}
\label{sec:caracteristicas_temporais_portas_logicas}

As características temporais do circuito são derivadas das caracteristicas temporais de suas partes, ou seja, as portas lógicas e as interconexões que o compõem. Para as portas lógicas, as informações a seguir são relevantes \cite{Livramento13}:

\begin{itemize}
\item \textbf{\textit{Timing Arc} (Arco de Tempo):} é um conceito utilizado para associar um pino de entrada de uma porta com a saída dessa mesma porta. Uma porta \textit{NAND} de duas entradas, como a apresentada na Figura \ref{fig:informacoes_temporais_porta_logica} possui dois \textit{timing arcs}, um entre a entrada $a$ e a saída ($a \to o$) e outro entre a entrada $b$ e a saída ($b \to o$). Para elementos sequenciais, como os \textit{flip-flops}, normalmente consideram-se como \textit{timing arcs} as conexões entre o sinal de relógio e as saídas. O arco é chamado \textit{positive unate}, se uma transição de subida (descida) na entrada causa uma transição de subida (descida) na saída. Se uma transição de subida (descida) da entrada causa uma transição de descida (subida) na saída, o arco é chamado \textit{negative unate} \cite{BhaskerChadha09}.

	\item \textbf{\textit{Delay} (Atraso de Propagação): } é o tempo que o sinal em um pino de saída $o$ leva para atingir um limiar\footnote{Este limiar geralmente é definido nas bibliotecas de célula como sendo 50\% do $Vdd$.} de sua transição total, devido a uma mudança no sinal em um pino de entrada $a$. Se a transição em $o$ for do nível lógico 0 para 1, o atraso é chamado de atraso de subida (\textit{rise delay}), caso o contrário, é chamado de atraso de descida (\textit{fall delay}) (Figura \ref{fig:informacoes_temporais_porta_logica}).
	
	\item \textbf{\textit{Slew} (Tempo de Transição): } é o tempo que o sinal leva para transicionar de 10\% até 90\% do valor final do sinal \afazer{CITAR}. Se for uma mudança positiva, a transição é chamada de transição de subida (\textit{rise slew}), caso contrário, transição de descida (\textit{fall slew}) (Figura \ref{fig:informacoes_temporais_porta_logica}). 
	
	\item \textbf{Propagação do \textit{Slew: }} é a política utilizada para propagação dos \textit{slews} dentro das portas lógicas. A estratégia utilizada geralmente adotada é de propagar o maior \textit{slew} dentre os \textit{slews} dos \textit{timing arcs}, para o pino de saída da porta lógica.
	
	\item \textbf{\textit{Driver:} } é a porta lógica, ou o pino que está ligado imediatamente na entrada de uma interconexão.
	
\end{itemize}

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\linewidth, trim=3cm 8cm 0 0]{imagens/arco_de_timing_fall_rise_slew_delay.pdf}
\caption{Acima: Uma porta lógica \textit{CMOS} $u1$, de função \textbf{não-e}, com duas entradas é \textit{driver} da interconexão \textit{n1}. Abaixo: As características temporais (\textit{delay} e \textit{slew}) da porta lógica $u1$.}
\label{fig:informacoes_temporais_porta_logica}
\end{center}
\end{figure}



\subsection{Modelo de atraso adotado em fluxo \textit{standard cell}}
%
%\afazer{apresentar lookup table
%
%falar da interpolaç~ao
%
%modelo n~ao linear}	

%Na Análise de \textit{Timing} Estática, os cicuitos são modelados considerando duas partes principais, as portas lógicas e as interconexões. As portas lógicas são modeladas a nível de seus arcos de \textit{timing}, e seus modelos são fornecidos pelas bibliotecas de célula, através de elementos conhecidas como \textit{lookup tables}. As interconexões, podem receber um modelo simplista ou mais sofisticado, dependendo da etapa que o projeto se encontra no fluxo \textit{standard cell}. Para etapas mais preliminares, as interconexões são modeladas como capacitâncias, sem atraso. Nas etapas seguintes, as interconexões são representadas por suas árvores RC.
%	
%	Nesta seção, serão apresentados detalhes sobre a modelagem das portas lógicas, e seu mapeamento para a biblioteca de célula, e posteriormente, como é calculado o atraso de propagação nas interconexões, dependendo do modelo empregado.
	
	%\includegraphics[width=0.8 \linewidth]{imagens/methodology_for_rc_delay_calculation.png} 



Nas bibliotecas de \textit{standard cell} atuais, modelos de atrasos não-lineares são fornecidos para os \textit{timing arcs} das células disponíveis. Esses modelos, que geralmente são obtidos através de simulações em nível elétrico, são registrados na forma de \textit{lookup tables}, como a da Figura \ref{fig:lookup_table}. Uma \textit{lookup table} descreve o \textit{delay} ou o \textit{slew} de um \textit{timing arc} em função de dois fatores: o \textit{slew} na entrada do arco (colunas), e a capacitância vista na saída (\textit{load}) (linhas).

\begin{figure}
\lstset{basicstyle=\footnotesize}
\begin{lstlisting}[frame=single]
rise_delay (delay_table) {
 load (0.0, 0.1, 0.2, 0.4, 0.8, 1.6, 3.2) ;
 input_slew (0.5, 3.0, 5.0, 8.0, 14.0, 20.0, 30.0, 50.0) ;
 values (
   1.17, 1.82, 2.26, 2.76, 3.48, 4.04, 4.82, 6.12,
   1.69, 2.34, 2.86, 3.49, 4.41, 5.11, 6.06, 7.58,
   2.21, 2.86, 3.38, 4.12, 5.22, 6.05, 7.16, 8.90,
   3.25, 3.90, 4.42, 5.20, 6.60, 7.67, 9.08, 11.23,
   5.33, 5.98, 6.50, 7.28, 8.84, 10.30, 12.24, 15.14,
   9.50, 10.15, 10.67, 11.45, 13.01, 14.57, 17.15, 21.33,
   17.83, 18.48, 19.00, 19.78, 21.34, 22.90, 25.50, 30.70
  );
}
\end{lstlisting}
\caption{Uma \textit{lookup table} para atraso de subida (\textit{rise delay}) de um arco de \textit{timing}. As linhas são endereçadas por \textit{load} (capacitância vista pelo \textit{timing arc}) e as colunas por \textit{input slew} (\textit{slew} aplicado na entrada do \textit{timing arc}). Adaptada de \cite{Contest2013}.}
\label{fig:lookup_table}
\end{figure}

Utilizando a \textit{lookup table} da Figura \ref{fig:lookup_table} para estimar o \textit{delay} de um dos \textit{timing arcs} de uma porta \textit{CMOS} e supondo que o \textit{slew} na entrada deste \textit{timing arc} seja de $8.0$, e a capacitância vista na saída seja $0.1$, obtém-se que $delay = 3.49$, pois $3.49$ é o valor endereçado pelos índices da função (\textit{slew} e \textit{load}). Caso os valores de \textit{slew} ou \textit{load} não existam na tabela, uma interpolação linear é realizada. Da mesma forma, o cálculo do \textit{slew} do \textit{timing arc} é realizado com base na \textit{lookup table}.

\section{Características Temporais das Interconexões}
\label{sec:caracteristicas_temporais_interconexoes}

Uma interconexão tem sua contribuição para o desempenho do circuito atribuida a três fatores:
\begin{itemize}
	\item \textbf{Capacitância Vista Pelo \textit{Driver}: } É necessário se modelar a carga capacitiva a ser carregada pelo \textit{driver} da interconexão com o objetivo de se obter a informação de \textit{load}, a qual é utilizada no cálculo do \textit{delay} e \textit{slew} dos \textit{timing arcs} das portas lógicas, como visto anteriormente. Os modelos utilizados neste cálculo serão apresentados na Seção \ref{sec:calculo_capacitancia}.

	\item \textbf{Atraso da Própria Interconexão: } Além do impacto local nos \textit{delays} e \textit{slews} dos \textit{timing arcs} de seus \textit{drivers}, as interconexões exercem impacto global no circuito, com seu próprio atraso de propagação, devido sua característica resistiva. Com a alta frequência de operação dos circuitos digitais atuais e o dimensionamento dos transistores para escalas nanométricas, os atrasos das interconexões que antes não eram significativos, hoje chegam consumir de 50 a 70\% do ciclo dos relógios, e esta percentagem tende a aumentar na medida que os transistores diminuem \cite{Cong96}.
	
	\item \textbf{Degradação do \textit{Slew}: } O cálculo do \textit{slew} é crucial para determinar a precisão de uma avaliação de \textit{timing} em um circuito digital \cite{Zhou2007}. Os \textit{delays} dos \textit{timing arcs} dependem do \textit{slew} de entrada e o \textit{slew} de saída, ao se propagar em uma interconexão, sofre uma degradação. A não-modelagem desta degradação pela interconexão, acarreta em erros de até 50\% \cite{Sheehan2002}.
\end{itemize}
%
%Na Figura \ref{fig:modelos_driver_interconexao}-a é apresentado um circuito combinacional simples, com as portas lógicas $u1$ e $u2$, seus respectivos \textit{Timing Arcs} e a interconexão que liga a saída da porta $u1$ na entrada da porta $u2$. Na Figura \ref{fig:modelos_driver_interconexao}-b, é mostrada em blocos, a modelagem utilizada para o circuito da Figura \ref{fig:modelos_driver_interconexao}-a. Neste caso, a interconexão é representada na forma de uma capacitância, que é vista pelos \textit{Timing Arc} de $u1$. O cálculo dessa capacitância pode ser realizado de diversas maneiras, que serão apresentadas na Seção \ref{sec:calculo_capacitancia}. Esta informação, juntamente com os \textit{slews} de entrada correspondente aos pinos $a$ e $b$, são utilizadas para calcular o \textit{delay} e o \textit{slew} através dos arcos de $u1$. Por exemplo, o cálculo de atraso no arco $b\to o$ da porta lógica $u1$, é realizado com base na sua \textit{Lookup Table}, em função do \textit{slew} aplicado em $b$ (vindo da entrada primária $inp2$) e da carga de saída ($load$), a qual foi obtida na modelagem da interconexão.
%
%\begin{figure}[ht]
%\begin{center}% TRIM = L D R U
%\includegraphics[width=\linewidth, trim=0 7cm 0 0]{imagens/modelos_driver_interconexao.pdf}
%\caption{XXXXXXXXXXXXXXxx}
%\label{fig:modelos_driver_interconexao}
%\end{center}
%\end{figure}







%
%A medida que os dispositivos eletrônicos operam em frequências maiores, o atraso das interconexões torna-se muito mais significante. Quando os dispositivos são reduzidos nas três dimensões por um fator $S$, o \textit{delay} intrínsico da porta lógica é reduzido por um fator de $S$, o atraso de interconexões locais continua o mesmo, porém, o atraso das interconexões globais aumenta por um fator de $S^2$.


\section{Modelos de Interconexão}
\label{sec:modelos_interconexoes}

%\afazer{Fazer um link: Motivação: Primeiro parágrafo de introdução do paper ``Performance Optimization of VLSI Interconnect Layout''}


Modelos de interconexão devem ser adotados de acordo com a etapa que o projeto se encontra no fluxo. Nas etapas iniciais, ou de \textit{pre-layout}, as informações de posicionamento e roteamento ainda não foram obtidas. Assim, as interconexões recebem modelos simplistas, possibilitando que as otimizações necessárias sejam realizadas, sem degradação no desempenho, para que as informações reais dos parasitas sejam apuradas. Nas etapas mais próximas da síntese física, ou \textit{pos-layout}, as interconexões são modeladas em função de suas capacitâncias e resistências, com o intuito de fornecer uma simulação mais precisa possível.

Esta seção tem por objetivo, apresentar alguns modelos de representação de interconexões, suas vantagens e desvantagens. Também será apresentado, o formato de representação de parasitas mais utilizado no projeto de circuitos digitais.

%	\subsection{Modelo de Interconexão Ideal}
%
%		Nos projetos, fios são representados como linhas que não fornecem impacto algum sobre o sistema. Uma diferença na tensão em um ponto deste fio reflete instantaneamente em todos os outros pontos, mesmo se o fio tiver um comprimento muito grande. Este modelo ideal de interconexão não é utilizado para representar interconexões reais, mas ele é bastante utilizado nas fases iniciais dos projetos, quando é necessário observar o comportamento dos transistores e portas lógicas que estão sendo conectadas \cite{Rabaey08}.
%
%	A medida em que o fluxo de projeto atinge fases mais avançadas, as interconexões necessitam ser abordadas em outro nível, considerando seu efeito e comportamento elétrico.



	\subsection{Modelo RC Distribuído (\textit{Distributed RC Model})}

Uma interconexão pode ser representada idealmente como uma linha distribuída (Figura \ref{fig:distributed_rc}). Uma linha é dividida em segmentos de tamanho $\Delta L$, com $\Delta L \to 0$, e cada segmento é representado por um $r$ e um $c$. Assim, a resistência e a capacitância total da interconexão é $r \times \Delta L$ e $c \times \Delta L$, respectivamente. O cálculo dos atrasos em um Modelo RC Distribuido reflete na resolução de equações diferenciais, que por sua vez, não possuem fórmula fechada. Isto resulta em um custo computacional muito elevado, não tornando viável sua adoção em fluxo \textit{standard cell}. Para tal objetivo, utilizam-se modelos de interconexão simplificados.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.8 \linewidth]{imagens/distributed_rc.png}
% \includegraphics{sta.png}
\caption{(a) Modelo RC Distribuído; (b) Seu símbolo de esquemático. Obtida de \cite{Rabaey08}.}
\label{fig:distributed_rc}
\end{center}
\end{figure}


	\subsection{Modelo de Capacitância Concentrada (\textit{Lumped C Model})}
	
		O Modelo de capacitância concentrada foi amplamente utilizado, pois se trata de um modelo simples e fácil de simular.
Quando a resistência da interconexão é despresível, devido o fato de que a resistência do \textit{driver} é substancialmente maior, ou quando as informações parasitas ainda não foram obtidas com detalhe, o fio pode ser representado como um capacitor $C$, que corresponde à capacitância total da interconexão. Seu atraso de propagação é desconsiderado, já que o fio não possui resistências. Seu único impacto no desempenho é a sua contribuição na capacitância vista pelo \textit{driver} \cite{Rabaey08}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.8 \linewidth]{imagens/lumped_model.jpg}
% \includegraphics{sta.png}
\caption{Modelo de Capacitância Concentrada (\textit{Lumped C Model}). Obtida de \cite{Rabaey08}.}
\label{fig:lumped_model}
\end{center}
\end{figure}

	\subsection{Modelo RC Concentrado (\textit{Lumped RC Model})}

		No modelo RC concentrado (\textit{lumped RC model}), concentra-se toda a resistência de cada segmento da interconexão em um único resistor $R$ e similarmente combina-se a capacitância total em um único capacitor $C$. A rede resistor-capacitor é representada como uma árvore RC (Figura \ref{fig:rc_tree}). De acordo com \citeonline{Rabaey08}, uma árvore RC possui as seguintes propriedades:
		
\begin{itemize}
\item A rede tem apenas um nodo de entrada, chamado de \textbf{fonte} (\textit{source});
\item Todos os capacitores são entre um nodo e o terra;
\item A rede não possui \textit{loops} resistivos, por isso é chamada de Árvore.
\end{itemize}


		\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7 \linewidth]{imagens/rc_tree.jpg}
% \includegraphics{sta.png}
\caption{Uma árvore RC. Obtida de \cite{Rabaey08}.}
\label{fig:rc_tree}
\end{center}
\end{figure}

		

%		\subsubsection{Limitações do Modelo RC Concentrado}
%
%			Com a utilização do atraso de Elmore, ignora-se o fato de que algumas resistências influenciam nas capacitâncias dos nodos da Árvore RC, ponderando de forma diferente a soma da Equação \ref{eq:tau}. Ao se obter a resistência compartilhada entre dois nodos $i$ e $k$ e o nodo fonte $s$, o impacto da resistência nas capacitâncias \textit{downstream} de $i$ e $k$ não são considerados, resultando em uma perda de precisão no modelo de atraso de Elmore. Por exemplo, a influência de $R_2$ em $C_2$ não é considerada no atraso $\tau_{D4}$ (Figura \ref{fig:rc_tree}). Esse efeito é conhecido como \textit{resistive shield} \cite{Kashyap00}. Considerando um caso hipotético, nesta topologia, se $R_2 = \infty$, o atraso de Elmore $\tau_{D4}$ continuaria sendo dado pela Equação \ref{eq:delay_4}, mesmo que $R_2$ impedisse $C_4$ de ser carregado ou descarregado.




\subsection{Extração de Elementos Parasitas no Projeto de Circuitos Digitais}

Quando se tem as informações de capacitância e resistência totais de uma interconexão, $C_{wire}$ e $R_{wire}$ respectivamente, em uma fase de \textit{pre-layout}, é necessário criar uma topologia para este fio, uma vez que o atraso da interconexão depende de como ela está estruturada. Existem três topologias (Figura \ref{fig:interconnect_tree}) que podem ser utilizadas a fim de representar a interconexão \cite{BhaskerChadha09}:



\begin{itemize}
\item \textbf{Árvore de melhor caso (\textit{Best-case tree}): } (Figura \ref{fig:interconnect_tree}-a) Assume-se que cada pino de destino é fisicamente adjacente ao \textit{driver}. Assim, nenhuma resistência estará no caminho entre \textit{driver} e destino, e todos os pinos de destino atuarão como \textit{load} na saída da interconexão.

\item \textbf{Árvore balanceada (\textit{Balanced tree}): } (Figura \ref{fig:interconnect_tree}-b) Na árvore balanceada, todos os pinos de destino se encontram na mesma distância do \textit{driver}, e o caminho para cada destino corresponde a mesma quantidade de capacitância e resistência que os outros caminhos.

\item \textbf{Árvore de pior caso (\textit{Worst-case tree}): } (Figura \ref{fig:interconnect_tree}-c) Neste caso, todos os destinos se encontram no fim da interconexão. Assim, cada pino de destino vê a resistência e a capacitância total da interconexão.
\end{itemize}

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.8 \linewidth]{imagens/interconnect_tree.png}
% \includegraphics{sta.png}
\caption{Representações utilizadas para as árvores RC em um contexto de \textit{pre-layout}. Obtida de \cite{BhaskerChadha09}.}
\label{fig:interconnect_tree}
\end{center}
\end{figure}

		Em projetos de circuitos digitais, as capacitâncias parasitas são geralmente descritas no formato SPEF \footnote{Existem outros formatos como SPF (\textit{standard parasitic format}), DSPF (\textit{detailed standard parasitic format}), RSPF (\textit{reduced standard parasitic format}) e SBPF (\textit{Synopsys binary parasitic format})} (\textit{Standard Parasitic Exchange Format}) do \textit{IEEE} (\textit{Institute of Electrical and Electronics Engineers}). O formato SPEF é um padrão feito para garantir a interoperabilidade entre ferramentas de Automação de Projeto Eletrônica (\textit{EDA}). Os parasitas podem ser representados em diferentes níveis de sofisticação, desde o simplista modelo de capacitância concentrada, até uma representação mais precisa de Árvores RC.

		Um exemplo de interconexão descrita no formato SPEF \cite{IEEE99} pode ser visualizado nas Figuras \ref{fig:spef_example} e \ref{fig:spef_example_code}. A linha 1 no código SPEF da Figura \ref{fig:spef_example_code} apresenta o nome da interconexão (inp1) e o valor de sua capacitância total (5.4). As linhas 2, 3 e 4 indicam que existe uma conexão entre uma entrada primária \textit{inp1}, indicado por \textit{*P inp1 I}, e a entrada de um pino interno \textit{a} da porta \textit{u1}, indicado por \textit{*I u1:a I}. Da linha 6 até a linha 9 são representadas as capacitâncias da Árvore RC.

		A representação um capacitor num arquivo SPEF se dá pelo formato:

		\begin{verbatim}
		[Número] [Nome] [Capacitância]
		\end{verbatim}

		De maneira semelhante, os resistores, como pode ser visto nas linhas 11 até 13, são descritas no formato:

		\begin{verbatim}
		[Número] [Capacitor Fonte] [Capacitor Destino] [Resistência]
		\end{verbatim}

		O valor *END (linha 14) é utilizado para determinar o fim da descrição de uma interconexão.

		\begin{figure}[ht]
		\begin{center}
		\includegraphics[clip=true, trim=2cm 7cm 2cm 6cm, scale=0.35]{imagens/spef_example}
		\caption{Interconexão RC}
		\label{fig:spef_example}
		\end{center}
		\end{figure}

		\begin{figure}[ht]
		\begin{center} % TRIM = L D R U
		\includegraphics[scale=0.25, trim=0 5cm 0 5cm]{recursos/spef_example_code.pdf}
		\caption{SPEF referente à Figura \ref{fig:spef_example}.}
		\label{fig:spef_example_code}
		\end{center}
		\end{figure}
		


		
	
\section{Cálculo da Capacitância de Saída do \textit{Driver}}
\label{sec:calculo_capacitancia}
	
	
	
		\afazer{
		
		%figura mostrando os modelos de driver,  capacitancia de interconexão, receiver

		%atraso e slew na sa´ida do driver <-> lookup table
		
		%encontrar a capacitancia a ser mapeada no calculo de atraso: capacitancia total capacitancia efetiva.
		
		Falta falar da redução para o modelo Pi que é utilizada \cite{Brien03}
		
		Talvez separar entre iterativos e não-iterativos
		}
		
			
Conforme explicado anteriormente, o impacto local de uma interconexão no seu \textit{driver} se dá pela contribuição no valor da capacitância vista pelo mesmo. Nesta capacitância são incluídos também, o impacto causado pelos pinos de destino da interconexão \footnote{Um pino de destino de uma interconexão é um pino que se liga na interconexão, que não é o pino \textit{driver}. Por exemplo, na Figura \ref{fig:circuito_exemplo_modelagem_interconnect}, os pinos de destino da interconexão são o segundo pino de entrada da porta $u2$, o pino de entrada da porta $u3$ e o pino $d$ do \textit{flip-flop} f1.}.

Para se realizar os cálculos de atrasos com precisão e eficiência, modelos são utilizados para o \textit{driver}, para a interconexão e para os destinos. Cada arco de \textit{timing} é modelado de modo a fazer com que os atrasos correspondam com a simulação elétrica. A interconexão, da mesma maneira, é modelada geralmente com modelos simplificados, que capturam o comportamento elétrico da descrição original da Árvore RC.

Na Figura \ref{fig:circuito_exemplo_modelagem_interconnect} é mostrado um circuito de exemplo composto por três portas lógicas ($u1$, $u2$ e $u3$), uma célula sequencial ($f1$) e a interconexão que liga a saída de $u1$ nas entradas de $u2$, $u3$ e $f1$. Na Figura \ref{fig:circuito_exemplo_modelagem_interconnect2} é ilustrada a modelagem deste circuito de exemplo.

Existem algumas maneiras conhecidas de estimar o valor de capacitância visto na saída do \textit{driver}. Na fase \textit{pre-layout}, essa estimativa é realizada somando a capacitância total da interconexão com a capacitância de cada pino de destino dela. Porém, ao se tratar de interconexões com característica resistiva, o uso da abordagem de capacitância concentrada é impreciso. Para que os modelos de atraso não-lineares, que dependem do valor de capacitância de saída, sejam utilizados para os \textit{drivers} diretamente, o uso de uma abordagem conhecida como ``Capacitância Efetiva'' é necessário.

A abordagem de ``Capacitância Efetiva'' tenta encontrar um valor de capacitância que pode ser utilizado como carga equivalente em termos de \textit{timing} para a saída do \textit{driver}. Essa capacitância equivalente é chamada de \textbf{Capacitância Efetiva} \cite{BhaskerChadha09}.

A necessidade de uma abordagem de capacitância efetiva se dá pelo fato de que algumas resistências na interconexão alteram o tempo que certas capacitâncias são carregadas ou descarregadas, este efeito é chamado de \textit{resistive shielding}. Considerando a interconexão da Figura \ref{fig:circuito_exemplo_modelagem_interconnect}, no caso extremo em que $R4 = \infty$, o capacitor $C4$ nunca seria carregado, portanto a capacitância efetiva não deveria levar em consideração seu valor de capacitância, diminuindo assim, o \textit{delay} e o \textit{slew} do \textit{driver}. Note que na abordagem de capacitância concentrada, o valor de $C4$ ainda seria considerado, mesmo que o capacitor $C4$ nunca fosse carregado ou descarregado.

A Figura \ref{fig:effective_capacitance_vs_actual_vs_total} mostra formas de onda na saída de uma porta lógica que é \textit{driver} de uma interconexão. Pode se observar que para o valor escolhido de capacitância efetiva, no ponto médio da curva (\textit{$V_{dd} = 50\%$}), este valor é igual ao valor de capacitância real, obtido por simulação. Note a diferença neste ponto em relação à curva de capacitância concentrada, mostrando a imprecisão de se utilizar este modelo em certos casos.

\begin{figure}[ht]
\begin{center} % TRIM = L D R U
\includegraphics[width=\linewidth]{imagens/effective_capacitance_vs_actual_vs_total.png} 
\caption{Formas de onda na saída de uma porta lógica em função da abordagem utilizada para cálculo da capacitância. Adaptada (\afazer{Passar para português}) de \cite{BhaskerChadha09}.}
\label{fig:effective_capacitance_vs_actual_vs_total}
\end{center}
\end{figure}

Diversas técnicas são utilizadas para cálculo da Capacitância Efetiva \cite{Kashyap00} \cite{Qian1994}, em especial \cite{PURI02} que será abordada neste trabalho.

		
\begin{figure}[H]
\begin{center} % TRIM = L D R U
\includegraphics[width=0.8 \linewidth]{imagens/circuito_exemplo_modelagem_interconnect.png} 
\caption{Um circuito composto por três portas lógicas ($u1$, $u2$ e $u3$), uma célula sequencial ($f1$) e a interconexão, em forma de Árvore RC, que liga a saída de $u1$ nas entradas de $u2$, $u3$ e $f1$}
\label{fig:circuito_exemplo_modelagem_interconnect}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center} % TRIM = L D R U
\includegraphics[width=0.8 \linewidth]{imagens/circuito_exemplo_modelagem_interconnect2.png} 
\caption{Modelagem para o circuito da Figura \ref{fig:circuito_exemplo_modelagem_interconnect}. Em amarelo, são mostrados os \textit{Timing Arcs} da porta lógica u1; Em azul, o modelo da interconexão é abstraído, recebendo um valor de capacitância efetiva; Em verde, cada destino da interconexão, representado como um valor de capacitância de seus pinos de entrada.}
\label{fig:circuito_exemplo_modelagem_interconnect2}
\end{center}
\end{figure}
		

\section{Cálculo do Atraso de Interconexão}		
\label{sec:atraso_interconexao}
\afazer{

Citar outros modelos (citar second moment, third moment)

%descrever o elmore em cima de uma RC tree
}


Uma das métricas mais populares para se calcular o atraso em interconexões é o atraso de \citeonline{Elmore48} (\textit{Elmore Delay}), pela simplicidade e razoável correlação com os atrasos reais. Esta técnica é bastante utilizada, pois além de ser de fácil implementação, fornece uma análise rápida e garante um \textit{upper-bound} para o valor do atraso \cite{Gupta97}.
		
Em um nodo $i$ da Árvore RC, o atraso de Elmore ($\tau_{Di}$) pode ser facilmente calculado como:
\begin{equation}
\tau_{Di} = \sum_{k=1}^{N} C_k R_{ik} \label{eq:tau}
\end{equation} Onde $C_k$ é a capacitância do nodo $k$ da Árvore e $R_{ik}$ é a resistência compartilhada entre os caminhos desde o nodo fonte $s$ até os nodos $i$ e $k$. $R_{ik}$ é definida por:
\begin{equation}
R_{ik} = \sum R_j \Rightarrow (R_j \in [caminhos(s \to i)\cap caminhos(s \to k)])
\label{eq:rik}
\end{equation}

		Nesta topologia, em particular, a resistência entre o nodo fonte $s$ e nodo $4$ é dada por:
\begin{equation}
R_{44} = R_1 + R_3 + R_4
\end{equation}

		E a resistência entre o nodo fonte $s$ e os nodos $2$ e $4$:
\begin{equation}
R_{42} = R_1
\end{equation}

		Assim, utilizando o atraso de Elmore, o atraso no nodo $4$ ($\tau_{Di}$) é equivalente a:
\begin{equation}
\tau_{D4} = C_1\ R_1 + C_2\ R_1 + C_3(R_1+R_3) + C_4(R_1+R_3+R_4) + C_i(R_1+R_3) 
\label{eq:delay_4}
\end{equation}

\section{Cálculo da Degradação do \textit{Slew} na Interconexão}
\label{sec:degradacao_slew}
	\afazer{Destacar na figura do modelo

mostrar que acontece a degradacao no slew		
}

\afazer{todos os conceitos abordados neste capitulo sao caracteristicas temporais locais}

\chapter{Técnica Utilizada para Cálculo das Características Temporais da Interconexão}
	
		\afazer{
			\cite{PURI02}		
		
		}
	
\section{Atraso das Interconexões}
		% \label{cap:atraso}
		% \afazer{Neste capítulo, serão apresentados detalhes sobre a implementação dos modelos de atrasos de interconexões, complementando a informação já obtida no Capítulo \ref{cap:sta}.}

		Para que o atraso de uma interconexão seja estimado com precisão, um modelo de grafo (Figura \ref{fig:grafo_interconexao}) é utilizado para representar o fio em relação a suas capacitâncias e resistências.

		No modelo de grafo $I(C, R)$ proposto, o conjunto dos vértices, ou capacitores $C$, é composto pelos nodos internos da interconexão, ou capacitores, juntamente com seus valores de capacitâncias. As arestas do grafo representam os resistores, onde cada resistor conecta dois capacitores com um valor de resistência. Sendo assim:
		\begin{equation}
			C = \{((u, c) | c > 0\}.
		\end{equation}
		\begin{equation}
			R = \{((u_1, c_1), (u_2, c_2), r) | (u_1, c_1), (u_2, c_2) \in C \land c1, c2, r > 0\}.
		\end{equation}

		
		\begin{figure}[ht]
		\begin{center}% TRIM = L D R U
		\includegraphics[width=1 \linewidth, trim=0cm 15cm 0 0]{imagens/grafo_interconexao.pdf}
		\caption{a) Uma interconexão com três capacitores, \textit{u1:o, u1:1 e u2:a}, e dois resistores, \textit{r1 e r2}, ligando duas portas lógicas, \textit{u1 e u2}; b) O grafo correspondente, com três vértices e duas arestas.}
		\label{fig:grafo_interconexao}
		\end{center}
		\end{figure}


		\section{Técnica de Elmore} 
		% \afazer{Nesta seção, será descrito em forma de Algoritmo ou Fluxograma, o algoritmo utilizado para cálculo do atraso de Elmore utilizado neste trabalho.}

		A técnica de \citeonline{Elmore48}, amplamente conhecida na literatura é de fácil implementação. O algoritmo para cálculo do atraso de Elmore (Algorítmo \ref{algo:elmore}) recebe como entrada o grafo $I(C, R)$ da interconexão e é executado após a inicialização das capacitâncias totais ($c_{tot_i}$) de cada nodo interno. Em ordem topológica reversa, os nodos são inicializados da seguinte maneira:
		
		\begin{equation}
			 c_{tot_i} = \left\{
			\begin{array}{l l}
				c_i & \quad \text{se $(u_i, c_i)$ é um capacitor terminal} \\
				\sum_{j \in filhos(i)} c_{tot_j} & \quad \text{caso contrário}
			\end{array} \right. 
		\end{equation}

		Onde o conjunto $filhos(i)$ é o conjunto de capacitores que estão interligados diretamente com o capacitor ($u_i, c_i$) através de um resistor $r$, que tenham um nível topológico maior que este. Analogamente, o $pai(i)$ é um capacitor que precede ($u_i, c_i$) e se conecta com ele, também, através de um resistor.

		A função $r(i, j)$ retorna o valor da resistência que liga dois capacitores $(u_i, c_i)$ e $(u_j, c_j) \in C$. O atributo $c_{tot_i}$ é a capacitância total de um nodo $u_i$, obtida a partir da soma de todas as capacitâncias a partir do capacitor $(u_i, c_i)$.

		Para determinar os atrasos da interconexão utilizando o modelo de Elmore, basta obter os valores T = \{$\tau_i | u_i$ que é um nodo terminal da árvore RC\}.

		\begin{algorithm}[H]
		\Entrada{Árvore RC $I(C, R)$}

		$\tau_1 = 0$

		\Para{todo $(u_i, c_i) \in C\ |\ i > 1$ em ordem topológica}{
			$\tau_i = \tau_{pai(i)} + r(pai(i), i) * c_{tot_i}$
		}
		\label{algo:elmore}
		\caption{Atraso de Elmore}
		\end{algorithm}

		

\section{Cálculo da Capacitância Efetiva e Degradação do \textit{Slew}}

%\afazer{Aqui, será descrito em forma de Algoritmo ou Fluxograma, o algoritmo utilizado para cálculo do atraso, na abordagem de Capacitância Efetiva \citeonline{PURI02}, que será implementado neste trabalho.}	

Como já mencionado anteriormente, estimar a capacitância vista por um \textit{driver}, com a soma da capacitância total da interconexão com as capacitâncias dos pinos de destino desta, é uma abordagem pessimista. Estimar o atraso da interconexão utilizando a técnica de Elmore também \cite{Gupta97}.

O fato de que a técnica de \citeonline{Elmore48} ignora o efeito de \textit{resistive shielding} gera erros significantes nos nodos mais próximos do fonte em interconxões grandes.

Em \citeyear{Kashyap00}, \citeauthor{Kashyap00} propuseram uma técnica para calcular o atraso de interconexão, levando em conta o efeito de \textit{resistive shielding}. Com a mesma complexidade da técnica de Elmore, a técnica proposta para cálculo de atraso em uma árvore RC reflete no cálculo da capacitância efetiva.

Porém, \cite{Kashyap00} não tratava \textit{driver} da interconexão como sendo uma porta lógica \textit{CMOS}. Sua aproximação para o \textit{slew} na entrada da Árvore RC era imprecisa. Como o cálculo da capacitância efetiva de uma árvore depende do \textit{slew} que incide nesta, e o \textit{slew} depende da capacitância vista pelo \textit{driver}, em \cite{PURI02} é proposta uma técnica que leva em consideração o impacto da capacitância no \textit{slew} do driver, e também, do \textit{slew} no cálculo da capacitância efetiva.

		Para simular a interdependência entre o \textit{slew} e a Capacitância Efetiva, o \textit{slew} no nodo fonte da Árvore RC é refinado iterativamente, para obtenção de seus atrasos.

		Dada uma Árvore RC | com os nodos enumerados em ordem topológica de $0$ até $n$, onde $0$ é o nodo fonte e $n$ é o nodo terminal | o nodo fonte tem como \textit{driver} uma porta combinacional \textit{CMOS}, de modo em que $S_{driver}$  é função da carga capacitiva da porta lógica. A capacitância \textit{downstream} total em um nodo $i$ é denotada por $C_{tot_i}$; o \textit{slew} em um nodo $i$, expresso por $S_i$; e a capacitância efetiva no mesmo nodo, por $C_{eff_i}$.

		O algoritmo para cálculo iterativo da Capacitância Efetiva de uma Árvore RC, como descrito em \cite{PURI02}, se dá em 5 passos:

		\begin{enumerate}

			\item Inicialização

				\begin{enumerate}

					\item A Capacitância Efetiva $C_{eff_i}$ de cada nodo da Árvore RC com o somatório de todas as Capacitâncias \textit{Downstream} $C_{tot_i}$

					\item O \textit{slew} no nodo fonte da Árvore RC $S_0$ é calculado diretamente, utilizando a Capacitância Concentrada da Árvore RC: $S_0 = f(C_{tot_0})$

				\end{enumerate}

			\item Em ordem topológica com origem no nodo fonte  \label{enum:algo_net_timing:1}

				\begin{enumerate}

					\item Atraso $T_{0-i}$ do nodo fonte $0$ para cada nodo $i$ da árvore é calculado utilizando o Atraso de Elmore, com a Capacitância Igual a Capacitância Efetiva de $i$.

					\begin{equation}
						T_{0-i} = \sum_{\forall \  nodos \ k} R_{k,i} \ C_{eff_i}
					\end{equation}


					\item A degradação do \textit{slew} em cada nodo $i$ é computada como
					\begin{equation}
						S_{i} = \frac{S_{i-1}}{1-\frac{R_i\ C_{eff_i}}{S_{i-1}} (1-e^{-\frac{S_{i-1}}{R_i\ C_{eff_i}}})}
					\end{equation}

				\end{enumerate}

			\item Em ordem topológica reversa com origem no nodo terminal
				\begin{enumerate}

					\item A Capacitância Efetiva ($C_{eff_i}$) de cada nodo é calculada como a soma da capacitância do nodo $C_i$ e todas as capacitâncias dos nodos filhos:

					\begin{equation}
						C_{eff_i}=C_i + \sum_{\forall\ filhos\ j}\ K_j \times C_{tot_j}
					\end{equation}

					Onde o fator de \textit{shielding} é definido por

					\begin{equation}
						K_j=1-\frac{2R_jC_{eff_j}}{S_i}(1-e^{-\frac{S_i}{2R_jC_{eff_j}}})
					\end{equation}

				\end{enumerate}


			\item O \textit{slew} no nodo fonte é calculado diretamente, utilizando o $C_{eff_0}$ atual  \label{enum:algo_net_timing:2}

			\item Os passos de \ref{enum:algo_net_timing:1} até \ref{enum:algo_net_timing:2} são repetidos até que $S_0$ convirja, dada uma precisão $\epsilon$

		\end{enumerate}

		Após a execução do algoritmo, pode-se obter a degradação de \textit{slew} e de atraso do \textit{driver} em todos os \textit{fanouts} da interconexão em questão.

\chapter{Análise de \textit{Timing} Estática}
	\label{cap:sta}
Análise de \textit{Timing}, ou \textit{Timing Analysis} \cite{Guntzel00} \cite{BhaskerChadha09}, é uma das técnicas utilizadas para se estimar atrasos das células e interconexões em circuitos digitais. A Análise de \textit{Timing} é chamada de estática (\textit{STA: Static Timing Analysis}), quando não depende dos valores aplicados nas entradas primárias do circuito, ou seja, apenas considera o comportamento estático das portas lógicas e interconexões. É um processo completo e exaustivo \cite{BhaskerChadha09} que verifica as mais diversas informações de \textit{timing} em um circuito, como os \textit{delays}, \textit{slews}, \textit{slacks} (folgas), \textit{required times} (tempos requeridos) e diversas violações de restrições de projeto.

Dado um \textit{design} de entrada, descrito em uma linguagem de descrição de hardware (\textit{HDL: Hardware description language}), restrições de projeto e uma biblioteca de células, o objetivo da Análise de \textit{Timing} é apresentar informações temporais em todos os pontos do circuito, e apontar suas possíveis violações (Figura \ref{fig:STA}). Essas informações são utilizadas para validar se o projeto sob verificação pode operar no desempenho estipulado, ou seja, se o circuito final poderá funcionar, com segurança, na frequência de relógio escolhida, sem que existam violações nas restrições de projeto.

	O fluxo básico de uma ferramenta de análise de \textit{timing} é:

	\begin{enumerate}

		\item Leitura dos arquivos de entrada (biblioteca de células, \textit{netlist}, restrições, etc);
		\item Geração de um modelo de grafo;
		\item \label{enum:etapa_sta} Atualização de informações temporais.

	\end{enumerate}

	Onde a etapa \ref{enum:etapa_sta} é repetida quantas vezes for necessário durante um processo de otimização.


\begin{figure}[H]
\begin{center}% TRIM = L D R U
\includegraphics[width=0.5 \linewidth, trim=0 3cm 0 0]{imagens/sta.pdf}
% \includegraphics{sta.png}
\caption{Análise de \textit{Timing} Estática. Adaptado de \cite{BhaskerChadha09}}
\label{fig:STA}
\end{center}
\end{figure}


	% 

	% \afazer{
	% 	Neste capitulo será apresentado também:
	% 	\begin{itemize}

	% 		\item Definições dos termos utilizados na Análise de \textit{Timing} Estática (slack, slew, required, ...) OK;
			
	% 		\item Representação dos circuitos digitais no processode Análise de \textit{Timing} Estática (definição do modelo de grafo);

	% 		\item Funcionamento da Análise de Timing Estática, descrita em pseudo código.

	% 		\item O atraso das portas lógicas é dependente do modelo de interconexão, então, certas informações ficaram a cargo do capítulo \ref{cap:atraso}

	% 	\end{itemize}
	% }

	\section{Representação de Circuitos Digitais}

Um circuito combinacional pode ser representado por um grafo de \textit{timing}. Neste grafo, as portas lógicas são os vértices e as interconexões são as arestas (Figuras \ref{fig:exemplo_circuito_simple} e \ref{fig:exemplo_grafo_simple}) \cite{BhaskerChadha09}.


\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\linewidth, trim=0 16cm 0 0]{imagens/exemplo_circuito_simple.pdf}
\caption{Circuito \textit{simple} retirado do banco de \textit{benchmarks} da competição de \textit{sizing} \cite{Contest2013}.}
\label{fig:exemplo_circuito_simple}
\end{center}
\end{figure}

		\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\linewidth, trim=0 17cm 0 0]{imagens/exemplo_grafo_simple.pdf}
\caption{Grafo correspondente ao circuito da Figura \ref{fig:exemplo_circuito_simple}.}
\label{fig:exemplo_grafo_simple}
\end{center}
\end{figure}

%Um par de vértices, $v_i$ e $v_j \in V$ são conectados por uma aresta direcionada $a(v_i, v_j) \in E$ se existe uma interconexão da saída do elemento representado pelo vértice $v_i$ para a entrada do elemento representado pelo vértice $v_j$. Dois vértices especiais, fonte (\textit{source}) e terminal (\textit{sink}), juntamente de suas arestas,  são inseridos antes das entradas e depois das saídas primárias, respectivamente, a fim de fornecer ao grafo, um único ponto de entrada e de saída.
%
%Um exemplo de circuito e seu grafo correspondente é ilustrado nas Figuras \ref{fig:exemplo_circuito_simple} e \ref{fig:exemplo_grafo_simple}, em que as cores utilizadas para representar as entradas primárias, células combinacionais, células sequenciais e saídas primárias são respectivamente: azul, laranja, amarelo e verde. Note que neste caso, a entrada primária de \textit{clock} e sua interconexão não são representados no modelo de grafo, visto que neste trabalho, a abordagem será restringida a análise de timing em circuitos combinacionais, ou seja, não serão considerados tempos de \textit{setup} e \textit{hold} nas células sequenciais.

Um circuito que consiste de células combinacionais e sequenciais (\textit{flip-flops} e \textit{latches}) pode ser representado como um conjunto de blocos combinacionais, divididos pelos latches (Figura \ref{fig:subcircuitos}), assim, a entrada de uma célula sequencial pode ser tratada como uma saída primária do circuito, e a saída dessa pode ser tratada como uma entrada primária do circito (Figura \ref{fig:grafo_refinado}).

\begin{figure}[H]
\begin{center}% TRIM = L D R U
\includegraphics[width=\linewidth, trim=0 13cm 0 0]{imagens/subcircuitos.pdf}
\caption{Grafo de timing dividido em dois subcircuitos devido a existência de uma célula sequencial.}
\label{fig:subcircuitos}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center}% TRIM = L D R U
\includegraphics[width=\linewidth, trim=0 13cm 0 0]{imagens/grafo_refinado.pdf}
\caption{Grafo de \textit{timing} com célula sequencial atuando como entrada e saída primária do circuito.}
\label{fig:grafo_refinado}
\end{center}
\end{figure}

Em um contexto de projeto em fluxo \textit{standard cell}, é interessante que o grafo modele também os \textit{timing arcs} das portas lógicas. Assim, o grafo de \textit{timing} é definido pelo conjunto de pinos dos circuitos (\textit{timing points}), entradas e saídas primárias, constituindo o conjunto dos vértices, e a união do conjunto das interconexões com o conjunto dos arcos de \textit{timing}, formando assim, o conjunto das arestas.

		As entradas primárias e registradores geralmente são mapeados para células presentes na biblioteca \textit{standard-cells}, por isso é necessário criar \textit{timing points} também para os pinos de entrada e seus respectivos \textit{timing arcs}. Um grafo representando o modelo escolhido pode ser visualizado na Figura \ref{fig:grafo_timing_points}.

		 % Um circuito combinacional pode ser representado como um grafo direcionado $G(V, A)$, onde em $V$, o conjunto de vértices, são encontrados os pinos do circuito, e nas arestas ($E$), a união de dois conjuntos: as interconexões, denotado pela letra $I$, e os arcos de \textit{timing}, neste caso denominado $A$.

		A seguir, é apresentada a nomenclatura utilizada no modelo do grafo direcionado $G(V, E)$:

\begin{itemize}

\item V  = \{ $v_i | v_i$ é um \textit{timing point} (pino de \textit{timing}), que pode ser a entrada ou saída de uma porta lógica, aqui referenciado como pino. Um \textit{timing point} pode representar uma entrada ou saída primária do circuito. \}

\item I = \{ $(v_i, v_j) | v_i, v_j \in V$ e $(v_i, v_j)$ é uma interconexão do circuito, que conecta $v_i$ em $v_j$. $v_i$ é um pino de saída de uma porta lógica ou uma entrada primária, e $v_j$ pode ser a entrada de uma porta lógica ou uma saída primária. \}

\item A = \{ $(v_i, v_j) | v_i, v_j \in V$ e $(v_i, v_j)$ é um \textit{timing arc}. Portanto, $v_i$ e $v_j$ são pinos de entrada e saída (respectivamente) de uma mesma porta lógica. \}

\item Por fim, o conjunto das arestas E = I $\cup$ A.

\end{itemize}

\begin{figure}[H]
\begin{center}% TRIM = L D R U
\includegraphics[width=1.1 \linewidth, trim=2cm 13cm 0 0]{imagens/grafo_timing_points.pdf}
% \includegraphics{sta.png}
\caption{Grafo de \textit{timing} com representação dos \textit{timing points}, \textit{timing arcs} e \textit{timing nets}.}
\label{fig:grafo_timing_points}
\end{center}
\end{figure}

Nos vértices, ou \textit{timing points}, são armazenadas as informações temporais para os pinos do circuito, tais como os \textit{arrival times}, \textit{slews} e \textit{slacks} que serão apresentadas na Seção \ref{sec:calculo_desempenho}.






		% \begin{figure}[ht]
		% \begin{center}
		% \includegraphics[scale=0.35]{imagens/circuit_graph.png}
		% % \includegraphics{sta.png}
		% \caption{(a) Um exemplo de circuito combinacional, e (b) é o grafo de \textit{timing} correspondente}
		% \label{fig:circuit_graph}
		% \end{center}
		% \end{figure}

	
		
\section{Cálculo do Desempenho do Circuito}
\label{sec:calculo_desempenho}
O cálculo do desempenho do circuito é realizado propagando os \textit{arrival times} (tempos de chegada) das portas lógicas em ordem topológica através de um método conhecido como PERT CPM. Para o entendimento das políticas de propagação dos atrasos na avaliação do desempenho de um circuito, os termos a seguir são importantes:

\begin{itemize}

\item \textit{Caminho: } uma sequência de vértices (\textit{timing points}) tal que cada um de seus vértices há uma aresta (\textit{timing arc} ou interconexão) para o próximo vértice da sequência. O primeiro \textit{timing point} da sequência é uma entrada primária e o último é uma saída primária;

\item $input(v_i)$: conjunto de \textit{timing points} que se ligam com $v_i$ através de um \textit{timing arc}. Todo $v_j \in input(v_i)$ é necessariamente um pino de entrada de uma porta lógica, e $v_i$ é um pino de saída;

\item $arr_{v_i}$: \textit{arrival time}, ou tempo de chegada no pino $v_i$. O arrival time é definido pela soma dos \textit{delays} e dos atrasos das interconexões desde uma entrada primária, até $v_i$;

\item $slew_{v_i}$: o \textit{slew} no pino $v_i$;

\item $delay_{v_j \to v_i}$: o \textit{delay} do \textit{timing arc} que vai do pino $v_j$ até o pino $v_i$;

\item $slew_{v_j \to v_i}$: o \textit{slew} do \textit{timing arc} que vai do pino $v_j$ até o pino $v_i$;

\item $iDelay_{v_j \to v_i}$: o atraso de propagação na interconexão que liga o pino $v_j$ até o pino $v_i$. No modelo de capacitância concentrada, $iDelay_{v_j \to v_i} = 0$;

\item $iSlew_{v_j \to v_i}$: degradação do \textit{slew} através da interconexão que liga $v_i$ em $v_j$;

\item $fanout(v_i)$: conjunto dos pinos que são destino da interconexão que $v_i$ é \textit{driver};

\item $req_{v_i}$: tempo máximo que o valor de $arr_{u_i}$ pode assumir para que a restrição de desempenho respeitada. Se $v_i$ é uma saída primária do circuito, então $required_{v_i} = T$, onde $f = \frac{1}{T}$ é a frequência mínima de operação do circuito digital;

\item $slack_{v_i}$: folga de tempo no ponto $v_i$, ou seja, quanto o \textit{arrival time} pode atrasar neste ponto, para que o período máximo continue sendo respeitado. Se em um determinado ponto do circuito, o \textit{slack} é negativo, então o caminho em questão está violando a restrição de atraso máximo do sistema. 
\end{itemize}
		
Na Análise de Timing Estática, os piores atrasos de cada porta lógica são propagados visitando o grafo direcionado em ordem topológica. Para cada $v_i \in V$ que são pinos de saída de portas lógicas, os \textit{arrival times}, bem como os \textit{slews} são determinados de modo a respeitar as seguintes restrições:

\begin{equation}
arr_{v_i} = \max_{\forall v_j \in input(v_i)}(arr_{v_j} + delay_{v_j \to v_i})
\end{equation}

\begin{equation}
slew_{v_i} = \max_{\forall v_j \in input(v_i)}(slew_{v_j \to v_i})
\end{equation}

Se $v_i \in V$ é um pino de entrada de uma porta lógica e $v_j \in V$ é o \textit{driver} da interconexão que conecta $v_j$ em $v_i$, o \textit{arrival time} e o \textit{slew} em $v_i$ são definidos por:

\begin{equation}
arr_{v_i} = arr_{v_j} + iDelay_{v_j \to v_i}
\end{equation}

\begin{equation}
slew_{v_i} = slew_{v_j} + iSlew_{v_j \to v_i}
\end{equation}


%	\section{Tempos Requeridos (\textit{required times}) e Folgas (\textit{slacks})}
Após a propagação dos \textit{arrival times} em todos os pinos, é necessário realizar a propagação dos tempos requeridos e dos \textit{slacks} em ordem topológica reversa. Em um pino de saída $v_i$ de uma porta lógica, o tempo requerido pode ser obtido facilmente, observando o menor dos tempos requeridos dentre os seus \textit{fanouts} e suas interconexões.

\begin{equation}
req_{v_i} = \min_{\forall v_j \in fanouts(v_i)}(req_{v_j} - iDelay_{v_i \to v_j})
\end{equation}

Para se propagar o \textit{required time} do pino $v_j$ de saída de uma porta lógica, para uma entrada $v_i$, utitliza-se o valor de \textit{delay} do arco que liga $v_i$ em $v_j$ que já foi calculado previamente:

\begin{equation}
req_{v_i} = req_{v_j} - delay_{vi \to v_j}
\end{equation}

A partir dos \textit{required times} e \textit{arrival times}, podemos determinar os \textit{slacks} nos  diversos pontos do circuito, através da equação:

\begin{equation}
slack_{v_i} = req_{v_i} - arr_{v_i}
\end{equation}

Se em algum ponto $v_i$, $slack_{v_i} = 0$, então $v_i$ se encontra em um caminho crítico. Se $slack_{v_i} < 0$, então $v_i$ se encontra em um caminho que viola a restrição de desempenho.

O \textbf{pior slack} é definido como o menor valor de \textit{slack} entre as saídas primárias. O valor de \textbf{total de slack negativo} é o somatório dos \textit{slacks} negativos das saídas primárias.

\section{Implementação da Ferramenta de STA}
	
	Este capítulo apresentará as estratégias utilizadas para o desenvolvimento da ferramenta de análise de \textit{timing}. Serão ilustradas as principais estruturas de dados, modelos de grafo, e serão apresentados também, os algoritmos implementados na ferramenta desenvolvida.

	\subsection{O Modelo de Grafo Adotado}


As estruturas de dados utilizadas para armazenar os elementos do grafo são essencialmente listas ordenadas topologicamente. À esquerda de um elemento, necessariamente se encontram os elementos de mesmo ou menor nível lógico, e à direita, de nível igual ao maior, como na Figura \ref{fig:grafo_lista_nivel_logico}. Da mesma maneira, os \textit{timing arcs} e as \textit{timing nets} também são ordenados topologicamente. Com essa escolha, o algoritmo de análise de timing estática passa a ser apenas de uma varredura em ordem, na lista de \textit{timing points}, atualizando a informação de \textit{timing} acumulada para cada vértice do grafo.

		\begin{figure}[ht]
		\begin{center}% TRIM = L D R U
		\includegraphics[width=1.1 \linewidth, trim=2cm 10cm 0 0]{imagens/grafo_lista_nivel_logico.pdf}
		\caption{Na lista ordenada, observando o elemento \textit{u1:o}, os elementos de menor nível lógico (\textit{fonte, inp1:a, inp1, inp2:a, inp2, f1:ck, f1:q, u1:a, u1:b, u2:a}) se encontram à esquerda, e os de maior (\textit{u2:o, f1:d, out, terminal}) se encontram à esquerda.}
		\label{fig:grafo_lista_nivel_logico}
		\end{center}
		\end{figure}

	% , onde V é o conjunto dos pinos do circuito, ou \textit{timing points}. Um par de vértices, ou pinos, $v_i$ e $v_j \in V$, são conectados por uma aresta direcionada $(v_i,v_j) \in A$ se existe uma interconexão que liga $v_i$ em $v_j$, sendo que $v_i$ é um pino de saída de uma porta lógica e $v_j$ é o pino de entrada de outra porta lógica.

\subsection{Algoritmo de Análise de \textit{Timing} Estática}

Com o modelo de grafo definido e implementado em suas devidas estruturas de dados, a análise de \textit{timing} estática já pode ser realizada. Basta chamar a rotina \textit{update\_timing}.

O algorítmo de Análise de Timing Estática é representado, em alto nível, pelo que segue:

\begin{algorithm}[H]
\Entrada{Grafo de \textit{timing} $G(V, E)$}
\Saida{Informações de \textit{timing} para os elementos do grafo (\textit{timing points, timing nets} e \textit{timing arcs})}
\Para{ todos $v_i \in V$ em ordem topológica}{
$atualiza\_timing(v_i)$
}
\Para{ todos $v_i \in V$ em ordem topológica reversa}{
$atualiza\_folgas(v_i)$
}
\caption{Análise de \textit{Timing} Estática}
\end{algorithm}

Onde no procedimento $atualiza\_timing$ os \textit{slews} e \textit{arrival times} são propagados seguindo a política apresentada na Seção \ref{sec:calculo_desempenho}.

Após todos os \textit{arrival times} serem calculados, as folgas são obtidas propagando os \textit{required times} em ordem topológica reversa, como foi apresentado também  na Seção \ref{sec:calculo_desempenho}, e corresponde ao procedimento $atualiza\_folgas$.


\chapter{Experimentos}

Esse capítulo tem por objetivo apresentar os experimentos realizados, bem como os resultados obtidos por estes. Como parte dos experimentos é realizada comparando as informações calculadas pela ferramenta implementada com as informações reportadas pelo \textit{PrimeTime}, a seção \ref{sec:erro} apresentará a métrica para cálculo dos erros que foi utilizada no presente trabalho. Na seção  \ref{sec:validacao_lumped}, é apresentado o primeiro experimento, que trata da validação da ferramenta perante o \textit{PrimeTime}, utilizando o modelo de interconexões de capacitância concentrada. Na seção \ref{sec:sta_industrial} será apresentada a maneira como o \textit{PrimeTime} modela o circuito, e como as informações de \textit{timing} são calculadas. A seção \ref{sec:validacao_ceff} tem por objetivo mostrar os resultados obtidos com a técnica de cálculo de capacitância efetiva e degradação do \textit{slew} implementadas neste trabalho. E por fim, serão apresentados os resultados obtidos utilizando algumas variações nos modelos de atraso.

	\section{Erro Relativo}
	\label{sec:erro}
	
	O erro relativo foi adotado como métrica para a qualidade das informações de \textit{timing} reportadas, pela ferramenta implementada neste trabalho, usando os valores reportados pelo \textit{PrimeTime} como referência.
	
\begin{equation}
\label{eq:erro_relativo}
Erro Relativo = \frac{|x - x^*|}{max(|x|, |x^*|)}
\end{equation}

O erro relativo, expresso pela equação \ref{eq:erro_relativo}, é  magnitude da diferença entre o valor exato ($x$) e o valor aproximado ($x^*$) dividido pela magnitude do maior valor. Nas seguintes comparações, a solução fornecida pelo \textit{PrimeTime} é adotada como a solução exata, e a obtida pela ferramenta implementada no trabalho, a aproximada.

O erro percentual, é obtido multiplicando o erro relativo por $100$. Por exemplo, supondo que $x = 3.12534$ e $x^* = 3.12566$, aplicando a equação \ref{eq:erro_relativo}, obtemos $Erro Relativo = 0.000102378$ refletindo em um erro percentual de $0.0102378\%$.


	\section{Validação do Modelo de Capacitância Concentrada Perante Ferramenta Industrial}
	\label{sec:validacao_lumped}

Neste experimento, os valores de tempo de execução (\textit{runtime}), erro médio, erro mínimo e erro máximo foram obtidos para os 7 circuitos da competição de \textit{sizing} do \textit{ISPD} \cite{Contest2013}. Esses valores comparados podem ser visualizados na tabela \ref{tab:lumped_capacitance_vs_primetime}. Nesta tabela, a informação de \textit{runtime} se refere ao tempo gasto para se realizar uma análise de \textit{timing} estática, desconsiderando os tempos de inicialização das ferramentas comparadas \footnote{O tempo  de inicialização neste contexto se refere ao tempo de leitura dos arquivos de entrada, e inicialização das estruturas de dados necessárias para a análise de \textit{timing} estática.}.

\begin{table}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth, trim=2cm 20cm 5cm 1cm]{imagens/comparacoes/lumped_capacitance_vs_primetime.pdf}
\caption{Comparação das informações de \textit{timing} calculadas pela ferramenta implementada \textit{versus} informações fornecidas pelo \textit{PrimeTime}, utilizando o modelo de interconexões de capacitância concentrada.}
\label{tab:lumped_capacitance_vs_primetime}
\end{center}
\end{table}

Note que na tabela \ref{tab:lumped_capacitance_vs_primetime}, os erros estão muito próximos de $0$, exceto no circuito $cordic$, onde o erro de $12\%$ se justifica por se tratar de valores muito pequenos, quando comparados, podem apresentar um erro relativo muito grande \footnote{No circuito $cordic$, nos pinos $g744540:a$, $g744569:o$, $g744569:a$, $g744621:o$ e $g744621:b$, a ferramenta reporta $0.00397127$ para \textit{slack} contra $0.004517$ do \textit{PrimeTime}. Aplicando a equação \ref{eq:erro_relativo}, obtém-se $erro = 0.1208169139$. Porém, ao avaliar o erro absoluto, conclui-se que as duas ferramentas fornecem valores iguais até a $3^{\underline{a}}$ casa decimal, sendo uma precisão aceitável neste contexto.}.

A partir das informações de \textit{runtime} obtidas na tabela \ref{tab:lumped_capacitance_vs_primetime}, observa-se que a média dos \textit{runtimes} da ferramenta desenvolvida é de cerca de 50 vezes menor que a média dos \textit{runtimes} do \textit{PrimeTime}, sendo que no circuito $usb\_phy$, a diferença é de 20 vezes, e no circuito $fft$, a diferença chega a ser de aproximadamente 98 vezes.


	\section{Análise de \textit{Timing} Estática em Ferramenta Industrial}
	\label{sec:sta_industrial}
			
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc erat odio, commodo tincidunt vehicula a, aliquam non dui. Vestibulum in pretium sapien, sit amet mollis neque. Duis ullamcorper, mauris at iaculis scelerisque, diam eros lobortis sapien, at luctus nisi dolor ac ligula. Mauris blandit ut sem vitae suscipit. Etiam at sem eu purus fringilla congue. Cras hendrerit dolor non sem ullamcorper elementum. In non magna interdum, malesuada dui a, cursus mi. Duis ut dui lectus. Nullam euismod eget lectus nec eleifend.			
			
\begin{table}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth, trim=1.8cm 20cm 7cm 1cm]{imagens/comparacoes/primetime.pdf}
\caption{XXXXXXXXXXXXXXXXXXXX}
\label{tab:comparacoes_primetime}
\end{center}
\end{table}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc erat odio, commodo tincidunt vehicula a, aliquam non dui. Vestibulum in pretium sapien, sit amet mollis neque. Duis ullamcorper, mauris at iaculis scelerisque, diam eros lobortis sapien, at luctus nisi dolor ac ligula. Mauris blandit ut sem vitae suscipit. Etiam at sem eu purus fringilla congue. Cras hendrerit dolor non sem ullamcorper elementum. In non magna interdum, malesuada dui a, cursus mi. Duis ut dui lectus. Nullam euismod eget lectus nec eleifend.

	\section{Validação da Técnica Implementada Perante Ferramenta Industrial}
	\label{sec:validacao_ceff}
\begin{table}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth, trim=1.8cm 20cm 7cm 1cm]{imagens/comparacoes/ceff_elmore_slew.pdf}
\caption{XXXXXXXXXXXXXXXXXXXX}
\label{tab:ceff_elmore_slew}
\end{center}
\end{table}

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/matrix_mult_logic-level_x_relative-error.pdf}
\caption{Erro relativo dos \textit{arrival times} em relação aos resultados obtidos pelo \textit{PrimeTime}, ao decorrer dos níveis lógicos, no \textit{benchmark} $matrix\_mult$. O \textit{arrival time} utilizado na comparação é o \textit{arrival time} no \textit{timing point} de saída de cada porta lógica. Em azul, cada ponto representa uma porta lógica. Em vermelho, é a curva referente às portas lógicas pertencentes ao caminho crítico. A curva em verde, é referente às portas lógicas pertencentes ao maior caminho, ou seja, ao caminho com maior número de portas.}
\label{tab:matrix_mult_logic-level_x_relative-error}
\end{center}
\end{figure}

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/pci_bridge32_logic-level_x_relative-error.pdf}
\caption{Erro relativo dos \textit{arrival times} em relação aos resultados obtidos pelo \textit{PrimeTime}, ao decorrer dos níveis lógicos, no \textit{benchmark} $pci\_bridge32$. O \textit{arrival time} utilizado na comparação é o \textit{arrival time} no \textit{timing point} de saída de cada porta lógica. Em azul, cada ponto representa uma porta lógica. Em vermelho, é a curva referente às portas lógicas pertencentes ao caminho crítico. A curva em verde, é referente às portas lógicas pertencentes ao maior caminho, ou seja, ao caminho com maior número de portas.}
\label{tab:pci_bridge32_logic-level_x_relative-error}
\end{center}
\end{figure}

A Figura \ref{fig:pci_bridge32_slew} mostra a distribuição das frequências da relação $C_{eff}/C_{total}$ de cada interconexão no circuito $pci\_bridge32$. Os dois gráficos representam o mesmo conjunto de dados, sendo que no gráfico da letra (a) todos os valores de frequência são mostrados, e no gráfico da letra (b), o valor de frequência é limitado em 100. Cada gráfico é dividido em três partes, sendo que na primeira, em verde, é mostra a distribuição de frequências para o primeiro \textit{terço} das interconexões, ordendadas pelo \textit{slew} de entrada, ou seja, as interconexões com os menores valores de \textit{slew} na saída de seus \textit{drivers}. A segunda parte, em vermelho, mostra a distribuição de frequências para segundo terço das interconexões. E a última parte, em azul, mostra as frequências para o terceiro terço, ou seja, das interconexões com os maiores valores de \textit{slew} na saída de seus \textit{drivers}.

\begin{figure}[ht]
%\begin{center}% TRIM = L D R U
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/experimentos/pci_bridge32_slew_full.pdf}
\label{fig:pci_bridge32_slew_full}
}
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/experimentos/pci_bridge32_slew_zoom.pdf}
\label{fig:pci_bridge32_slew_zoom}
}

\caption{}
\label{fig:pci_bridge32_slew}

\end{figure}

\begin{figure}[ht]
%\begin{center}% TRIM = L D R U
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/experimentos/pci_bridge32_resistance_full.pdf}
\label{fig:pci_bridge32_resistance_full}
}
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/experimentos/pci_bridge32_resistance_zoom.pdf}
\label{fig:pci_bridge32_resistance_zoom}
}
\caption{$pci\_bridge32$ resistance}
\end{figure}

\begin{figure}[ht]
%\begin{center}% TRIM = L D R U
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/experimentos/matrix_mult_slew_full.pdf}
\label{fig:matrix_mult_slew_full}
}
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/experimentos/matrix_mult_slew_zoom.pdf}
\label{fig:matrix_mult_slew_zoom}
}
\caption{$matrix\_mult$ \textit{slew}}
\end{figure}

\begin{figure}[ht]
%\begin{center}% TRIM = L D R U
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/experimentos/matrix_mult_resistance_full.pdf}
\label{fig:matrix_mult_resistance_full}
}
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/experimentos/matrix_mult_resistance_zoom.pdf}
\label{fig:matrix_mult_resistance_zoom}
}
\caption{$matrix\_mult$ resistance}
\end{figure}

	\section{Variações no Modelo de Atraso Comparadas à Ferramenta Industrial}

\begin{table}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth, trim=1.8cm 20cm 7cm 1cm]{imagens/comparacoes/lump_elmore_slew.pdf}
\caption{XXXXXXXXXXXXXXXXXXXX}
\label{tab:lump_elmore_slew}
\end{center}
\end{table}

\begin{table}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth, trim=1.8cm 20cm 7cm 1cm]{imagens/comparacoes/lump_elmore_no_slew.pdf}
\caption{XXXXXXXXXXXXXXXXXXXX}
\label{tab:lump_elmore_no_slew}
\end{center}
\end{table}


\begin{table}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth, trim=1.8cm 20cm 7cm 1cm]{imagens/comparacoes/ceff_elmore_no_slew.pdf}
\caption{XXXXXXXXXXXXXXXXXXXX}
\label{tab:ceff_elmore_no_slew}
\end{center}
\end{table}






\chapter{Conclusão}
	\afazer{A FAZER}

% \chapter{Anexos}
% 	\section{Código Fonte em C++ da Ferramenta Desenvolvida}

% 		\lstinputlisting[label=timing_analysis.cpp,caption=timing\_analysis.cpp]{../implementacao/TimingAnalysis/src/timing_analysis.cpp}


%--------------------------------------------------------
% Elementos pós-textuais
\bibliography{Relatorio}

\end{document}
