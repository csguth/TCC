%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Universidade Federal de Santa Catarina             
% Biblioteca Universitária                     
%----------------------------------------------------------------------
% Exemplo de utilização da documentclass ufscThesis
%----------------------------------------------------------------------                                                           
% (c)2010 Roberto Simoni (roberto.emc@gmail.com)
%         Carlos R Rocha (cticarlo@gmail.com)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{ufscThesis} % Definicao do documentclass ufscThesis

%----------------------------------------------------------------------
% Pacotes usados especificamente neste documento
\usepackage{graphicx} % Possibilita o uso de figuras e gráficos
\usepackage{color, colortbl}    % Possibilita o uso de cores no documento
\usepackage{multirow}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage[labelsep=endash]{caption}
\usepackage{mathtools}
\usepackage{listings}
\usepackage[portuguese, lined, linesnumbered, boxed,ruled,commentsnumbered]{algorithm2e}
\usepackage{float}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{pdfpages}




\definecolor{BLUE}{rgb}{0, 0, 1}
\definecolor{BLACK}{rgb}{0, 0, 0}

\everymath{\color{green!20!black}}
\everydisplay{\color{green!20!black}}
\DeclareTextFontCommand{\emph}{\ttfamily}



%----------------------------------------------------------------------
% Comandos criados pelo usuário
\newcommand{\afazer}[1]{{\color{red}{#1}}} % Para destacar uma parte a ser trabalhada
\newcommand{\citacaoAzul}[1]{{\color{blue!40!black}{\cite{#1}}}}
%\newcommand{\citacaoAzul}[1]{\cite{#1}}

\newcommand{\citacaoInline}[1]{{\color{blue!40!black}{\citeonline{#1}}}}

\newcommand{\emfase}[1]{\emph{#1}}

%----------------------------------------------------------------------
% Identificadores do trabalho
% Usados para preencher os elementos pré-textuais
\instituicao[a]{Universidade Federal de Santa Catarina} % Opcional
\departamento[a]{Departamento de Informática e Estatística}
\curso[o]{Curso de Bacharelado em Ciências da Computação}
%\documento[a]{TCC} % Opcional (Tese é o padrão)
\titulo{Análise de \textit{Timing} Estática e a Avaliação do Impacto do Atraso das Interconexões em Circuitos Digitais}
%\subtitulo{Considerando Atraso de Interconexões} % Opcional
\autor{Chrystian de Sousa Guth}
\grau{Bacharel em Ciências da Computação}
\local{Florianópolis - Santa Catarina} % Opcional (Florianópolis é o padrão)
\data{09}{Dezembro}{2013}
\orientador[Orientador]{M.Sc. Vinícius dos Santos Livramento}
\coorientador[Coorientador]{Prof. Dr. José Luís Almada Güntzel}
\coordenador[Coordenador]{Prof. Dr. Renato Cislaghi}

\numerodemembrosnabanca{3} % Isso decide se haverá uma folha adicional
\orientadornabanca{sim} % Se faz parte da banca definir como sim
\coorientadornabanca{sim} % Se faz parte da banca definir como sim
%\bancaMembroA{Vinicius dos Santos Livramento} %Nome do presidente da banca
\bancaMembroB{Dr. Renan Alves Fonseca}      % Nome do membro da Banca
%\bancaMembroC{Prof. Dr. Luiz Cláudio Villar dos Santos}     % Nome do membro da Banca
%\bancaMembroD{Quarto membro}       % Nome do membro da Banca
%\bancaMembroE{Prof. quinto membro}       % Nome do membro da Banca
%\bancaMembroF{Prof. sexto membro}        % Nome do membro da Banca
%\bancaMembroG{Prof. sétimo membro}       % Nome do membro da Banca


\textoResumo {
Análise de \textit{timing} estática (\textit{STA: Static Timing Analysis}) é a técnica mais utilizada para estimar o atraso de circuitos digitais durante o fluxo de síntese física. Com o advento das tecnologias CMOS (Complementary Metal-Oxide Semiconductor) nanométricas, o atraso das interconexões passou a ser dominante em relação ao atraso das portas lógicas e por este motivo, não pode mais ser desprezado. A técnica de Elmore, baseada no primeiro momento da resposta ao impulso é amplamente utilizada para se calcular os atrasos das interconexões, porém, pode ser imprecisa por desconsiderar o efeito de \textit{resistive shielding}. Algumas técnicas modificam a técnica de Elmore, a fim de contornar o problema do efeito de \textit{resistive shielding}, obtendo resultados mais precisos, mantendo um baixo custo computacional. A consideração do efeito de \textit{resistive shielding} requer a implementação de uma técnica para obtenção da capacitância efetiva em cada segmento da interconexão, impactando também no atraso da porta lógica que a interconexão está ligada na saída (\textit{driver}). A ferramenta de STA implementada neste trabalho realiza o cálculo dos atrasos das interconexões gerando resultados que são, em média, $4,28\%$ mais otimistas do que aqueles gerados pela ferramenta Synopsys PrimeTime, porém com tempo de execução cerca de 8 vezes menor.

}
\palavrasChave {Automação de Projeto Eletrônico (EDA), Biblioteca \textit{Standard Cell}, Análise de \textit{Timing} Estática \textit{(STA)}, \textit{Complementary Metal-Oxide Semiconductor}}

\textAbstract {
Static timing analysis is the most used technique to calculate the critical path in digital circuits during the standard cell design flow. Since feature size of CMOS devices are reducing, the interconnect delay becomes much more significant than before. Elmore delay model, based on the first moment of the impulse response is widely used to compute the interconnect delay, but, the technique doesn't consider the effect called resistive shielding. Some techniques modify the Elmore delay model in order to workaround the problem caused by the resistive shielding effect, getting more acurately results, keeping a low computational cost. The consideration of the resistive shielding effect requires the implementation of a technique to obain the effective capacitance value in each interconnect segment. This effective capacitance value impacts in the driver delay and slew. The STA tool implemented in this work does the interconnect delay calculation, getting results that are, in average $4.28\%$ optimistics than those that are obtained by an industrial tool, with 8 times less runtime.
}

\keywords {Electronic Design Automation (EDA), Standard Cell Library, Static Timing Analysis, Complementary Metal-Oxide Semiconductor}

\dedicatoria{À minha família.}

\agradecimento{
À minha mãe, Ieda, pelo amor, apoio e dedicação que nunca faltaram. Também aos meus irmãos, Ralf e Elis Regina, pela força e confiança nesses 4 anos de graduação.

Agradeço à minha namorada Lígia pelo amor, compreensão e paciência, principalmente nos últimos meses em que me dediquei a este trabalho.

Ao meu orientador, Vinícius dos Santos Livramento, pela confiança, dedicação e aprendizado proporcionado desde o início de 2011, em que fui seu assistente, até a conclusão deste trabalho. Agradeço também por sua excelente orientação e rigor exigido, os quais foram fundamentais para o sucesso deste trabalho de conclusão de curso.

Ao meu coorientador, professor José Luís Almada Güntzel, pela grande co\-la\-bo\-ra\-ção, que muito contribuiu para a conclusão deste trabalho.

Ao membro da banca, Renan Alves Fonseca, pelo tempo dedicado para uma revisão rigorosa e pelas sugestões que contribuíram com este trabalho.

Aos colegas da graduação André Camargo e Cláudio Dettoni, Gabriel Gava, Lucas Pereira, Renan Netto e demais colegas do ECL que de alguma forma participaram deste trabalho. 

Ao CNPq pelo custeio parcial da execução deste trabalho, com bolsa na modalidade de iniciação tecnológica (Processo número: \\182980/2013-8).}

\epigrafe{}

%----------------------------------------------------------------------
% Início do documento                                
\begin{document}
%--------------------------------------------------------
% Elementos pré-textuais
\capa  
%\folhaderosto[comficha] % Se nao quiser imprimir a ficha, é só não usar o parâmetro
\folhaderosto
\includepdf[pages={1}]{ficha.pdf}
\folhaaprovacao
\paginadedicatoria
\paginaagradecimento
\paginaepigrafe
\paginaresumo
\paginaabstract
\listadefiguras
\listadetabelas
\listadeabreviaturas
\listadesimbolos
\sumario
%--------------------------------------------------------
% Elementos textuais
\chapter{Introdução}
	
Este capítulo tem por objetivo, apresentar uma visão geral sobre o fluxo de projeto \textit{standard cell} e a importância da análise de \textit{timing} estática no desenvolvimento de circuitos digitais. Serão apresentadas também a motivação e a justificativa deste trabalho.

\section{Fluxo de Projeto \textit{Standard Cell}}

O crescimento da complexidade dos circuitos digitais contemporâneos\footnote{Um processador para \textit{desktop} desenvolvido no ano de 2008 tem cerca de 731 milhões de transistores, excluindo a área de memória \citacaoAzul{Intel08}.} e a necessidade de um \textit{time-to-market} (tempo de entrega ao mercado) curto faz com que o projeto de tais circuitos adote o fluxo \textit{standard cell} (Figura \ref{fig:fluxo_standard_cell}).

No fluxo \textit{standard cell} as portas lógicas são caracterizadas e validadas previamente em uma dada tecnologia, originando as chamadas ``células''. Essas células \footnote{Célula é a instância de \textit{layout} para a implementação física de uma porta lógica.} são catalogadas com suas diversas características elétricas em uma biblioteca, podendo ser reutilizadas em diversos projetos que usem a mesma tecnologia. O reuso amortiza o custo dos projetos inseridos neste nodo tecnológico e possibilita um \textit{time-to-market} mais curto.

O fluxo \textit{standard cell} pode ser subdividido em etapas, e ao decorrer dessas etapas, a análise de \textit{timing} pode ser requisitada milhares de vezes. De acordo com \citacaoInline{BhaskerChadha09}, essas são algumas das etapas importantes no fluxo \textit{standard cell}:


\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.9\linewidth]{imagens/fluxo_standard_cell.pdf}
\caption{Fluxo de projeto \textit{Standard Cell}. Adaptado de \citacaoAzul{BhaskerChadha09}.}
\label{fig:fluxo_standard_cell}
\end{center}
\end{figure}



\begin{itemize}

\item \textbf{Síntese: } Responsável por criar uma representação em nível de portas lógicas, a partir de uma descrição no nível de transferência entre registradores (\textit{RTL: Register Transfer Level}\abreviatura{RTL}{Register Transfer Level}). A partir desta etapa, a análise de \textit{timing} estática (\textit{STA: Static Timing Analysis}\abreviatura{STA}{Static Timing Analysis}) é utilizada, para estimar as características \textit{temporais} do circuito;

\item \textbf{Otimização Lógica: } Responsável por minimizar a lógica do circuito sintetizado. A análise de \textit{timing} estática pode ser realizada antes desta etapa, para verificar os caminhos de maior atraso, também chamados de caminhos críticos. Se a análise de \textit{timing} for realizada depois desta etapa, o objetivo é identificar quais caminhos ainda precisam ser otimizados ou identificar os caminhos críticos;

\item \textbf{Posicionamento: } Define a localização espacial dos \textit{layouts} das células. Antes dessa etapa, modelos de interconexão ideais são adotados, pois ainda não se possui as informações necessárias de posicionamento. Uma maneira alternativa para se modelar as interconexões é utilizar um modelo de \textit{wireload}, que estima o tamanho das interconexões de acordo com o seu número de destinos, ou \textit{fanouts};

\item \textbf{Síntese da Árvore de \textit{Clock}: } No início da síntese física, as árvores dos relógios são consideradas como ideais, ou seja, não possuem atraso de propagação. O objetivo desta etapa é minimizar o \textit{clock skew}, que é a diferença entre os tempos de chegada do sinal de relógio nas entradas dos registradores. A análise de \textit{timing} estática é importante nesta etapa para avaliar essas diferenças nos tempos de chegada.

\item \textbf{Roteamento: } Responsável por criar as conexões entre as diferentes células incluídas no projeto, utilizando as diferentes camadas de metal. As mudanças nas topologias nesta etapa necessitam diversas avaliações das informações temporais.
\end{itemize}

Os projetos de circuitos digitais no fluxo \textit{standard cell} são realizados visando, além das funcionalidades requisitadas, a operação em uma frequência especificada. Por isso, diversas otimizações são efetuadas ao longo do fluxo, para que tais funcionalidades consigam ser realizadas na frequência definida. Nas primeiras etapas de um projeto no fluxo \textit{standard cell}, apenas as questões relacionadas à funcionalidade do projeto são verificadas, pois ainda não estão disponíveis informações detalhadas referentes ao comportamento elétrico do circuito. Nas etapas posteriores, as informações temporais precisam ser avaliadas com precisão, para que as etapas de otimização garantam a satisfação dos requisitos do projeto.

\section{Motivação}
%otimizações		como \textit{gate sizing} \citacaoAzul{Livramento13} \citacaoAzul{Hu12} \citacaoAzul{Mohammad12}
% \textit{Placement} \citacaoAzul{Shahookar91} 
No fluxo \textit{standard cell}, a partir da descrição RTL, uma série otimizações são realizadas ao decorrer de suas etapas. Como consequência dessas otimizações, as topologias das interconexões se alteram, levando à necessidade, ao decorrer do fluxo, de diversas avaliações de suas informações temporais. \citacaoInline{Markov13} trata do problema de \textit{gate sizing} utilizando diversas modelagens para os atrasos das interconexões, bem como seu impacto na propagação do \textit{slew} do circuito.

Em diversos sistemas projetados atualmente, entre 50\% a 70\% do ciclo de relógio é ``consumido'' pelo atraso de propagação de suas interconexões \citacaoAzul{Cong96}. Nas tecnologias com alta escala de integração (\textit{VLSI: Very-large-scale integration}\abreviatura{VLSI}{Very-large-scale integration}) atuais, onde diversas otimizações tem por objetivo reduzir a resistência dos \textit{drivers}, as interconexões passam a ser cada vez mais impactantes no desempenho do circuito digital.

Durante as otimizações nas etapas iniciais do fluxo (\textit{pre-layout}), a análise de \textit{timing} é requisitada milhares de vezes, sendo assim necessário que a ferramenta de análise de \textit{timing} tenha o melhor desempenho possível. Como as informações relacionadas ao aspecto físico do circuito, como posicionamento \citacaoAzul{Wang2000} e roteamento \citacaoAzul{Ryzhenko2012} nas etapas iniciais precisam ser aproximadas, a ferramenta de análise de \textit{timing} fornece estimativas pessimistas sobre o \textit{timing} do circuito.

Já nas etapas finais (\textit{pós-layout}), a análise de \textit{timing} precisa ser a mais precisa possível. Porém, a modelagem dos elementos dos circuitos digitais torna-se mais complexa, diminuindo o desempenho da ferramenta.

Como as informações de \textit{timing} precisam ser avaliadas centenas ou milhares de vezes durante os processos de otimização, ferramentas de análise de \textit{timing} eficientes e escaláveis precisam ser desenvolvidas e aperfeiçoadas para acompanhar a evolução da tecnologia \textit{CMOS} (\textit{Complementary Metal-Oxide Semiconductor})\abreviatura{CMOS}{Complementary Metal-Oxide Semiconductor}.
		


	\section{Justificativa}

Diversas otimizações são realizadas no decorrer do fluxo de projeto \textit{standard cell} e o uso de ferramentas para a automação de projeto eletrônico (\textit{EDA: Electronic Design Automation}\abreviatura{EDA}{Electronic Design Automation}) é indispensável em suas diferentes etapas. A inexistência de ferramentas de análise de \textit{timing} estática precisas de domínio público e a restrição no acesso à ferramentas industriais (devido ao alto custo de suas licenças) resultam em um problema de infraestrutura de pesquisa. Assim, este trabalho tem como resultado uma alternativa de ferramenta de análise de \textit{timing} para projetistas de circuitos digitais, bem como uma infraestrutura realista e precisa para desenvolvedores de ferramentas, que necessitam da análise de \textit{timing} em alguma etapa do fluxo de projeto \textit{standard cell}.

\section{Objetivos}

\subsection{Objetivo Geral}

Este trabalho tem por objetivo o projeto, validação, avaliação e documentação de uma ferramenta de análise de \textit{timing} estática voltada para o fluxo \textit{standard cell}. 

\subsection{Objetivos Específicos}

\begin{enumerate}

\item \label{objetivos:lumped} Avaliação e análise experimental do modelo de interconexão com capacitância concentrada, desprezando-se o impacto das resistências; 

\item \label{objetivos:elmore} Avaliação e análise experimental da técnica de Elmore para cálculo do atraso das interconexões baseando-se em um modelo de interconexão RC\abreviatura{RC}{Resistor-Capacitor}  concentrado;

\item  \label{objetivos:puri} Avaliação e análise experimental da técnica para cálculo do atraso de interconexões utilizando a abordagem de capacitância efetiva; 

\item Construção de uma ferramenta de análise de \textit{timing} estática incluindo as funcionalidades descritas nos objetivos \ref{objetivos:lumped}, \ref{objetivos:elmore} e \ref{objetivos:puri}, bem como sua validação empírica perante uma ferramenta de análise de \textit{timing} industrial.

\end{enumerate}

\section{Escopo}

Este trabalho aborda o problema da análise de \textit{timing} estática utilizando técnicas para estimação dos atrasos das interconexões. A análise de \textit{timing} é realizada propagando os atrasos de cada porta lógica em ordem topológica, a fim de estimar o desempenho do circuito. Os modelos de atraso (\textit{delay}) e \textit{slew} utilizados neste trabalho são os mesmos utilizados no \textit{fluxo standard cell}\footnote{O cálculo dos atrasos das portas lógicas será melhor apresentado na Seção \ref{sec:caracteristicas_temporais_portas_logicas}.}.

As interconexões serão modeladas de duas formas:
\begin{itemize}
\item \textbf{Modelo da capacitância concentrada}, impactando apenas nos \textit{atrasos} de seus \textit{drivers};

\item \textbf{Modelo RC concentrado}\footnote{Este modelo pode ser chamado de modelo RC distribuído em alguns trabalhos científicos, como na competição de \textit{sizing} do \textit{ISPD (International Symposium on Physical Design)\abreviatura{ISPD}{International Symposium on Physical Design}} de 2013 \citacaoAzul{Contest2013}.}, apresentando também, seus próprios atrasos como impacto no atraso do circuito.
\end{itemize}

Não faz parte do escopo deste trabalho a consideração dos tempos de \textit{setup} e \textit{hold} das células sequenciais, como os registradores. Eles serão modelados pelo \textit{timing arc}\footnote{O conceito de \textit{timing arc} será apresentado na Seção \ref{sec:caracteristicas_temporais_portas_logicas}.} da entrada de relógio até a saída.

			% \afazer{Talvez tirar a seção Objetivos e colocar essa como objetivos...}

%
%A ferramenta de Análise de \textit{Timing} desenvolvida será capaz de reportar informações de \textit{timing} de um circuito. As portas lógicas serão modeladas utilizando um modelo de atraso não-linear (NLDM: \textit{Non-Linear Delay Model}), onde seus atrasos são caracterizados por \textit{lookup tables}, fornecidas nas bibliotecas \textit{standard cells} atuais. As informações reportadas para as portas lógicas são: \textit{slacks, slews, arrival times}, caminho crítico, total de \textit{slack} negativo e pior \textit{slack}. Essas informações serão explicadas nos Capítulos \ref{cap:conceitos} e \ref{cap:sta}.
%
%Para as interconexões, dois modelos serão implementados: capacitância concentrada e o modelo RC concentrado. Seus atrasos serão calculados utilizando a técnica de \citeonline{Elmore48} e a técnica de capacitância efetiva de  \citeonline{PURI02}.
%			
%Os cada elemento sequencial será tratado como uma saída e uma entrada primária do circuito. Para simplificação do algoritmo de análise de \textit{timing}, tempos de \textit{setup}, \textit{hold} e carga não serão considerados.
%			
%Por fim, a qualidade das informações de \textit{timing} obtidas pela ferramenta serão comparadas com os dados obtidos pela ferramenta industrial PrimeTime \textregistered \ da \citeonline{PrimeTime12}.
		
\section{Organização Deste Trabalho}
Este trabalho está organizado da seguinte forma:

O Capítulo \ref{cap:conceitos} apresenta os conceitos básicos essenciais para o entendimento do presente trabalho.

No Capítulo \ref{cap:tecnica} é apresentada uma revisão bibliográfica acerca das técnicas utilizadas para cálculo do atraso das interconexões e da capacitância efetiva.

Já o Capítulo \ref{cap:sta} trata da análise de \textit{timing}, apresentando seus algoritmos e particularidades na implementação.

O Capítulo \ref{cap:experimentos} apresenta os experimentos realizados utilizando a ferramenta implementada neste trabalho.

Finalmente, as conclusões e algumas perspectivas de trabalhos futuros são apresentadas no Capítulo \ref{cap:conclusao}.
\chapter{Conceitos Fundamentais de Circuitos Digitais}
\label{cap:conceitos}

Este capítulo apresenta os conceitos básicos relacionados à temporização e modelagem de circuitos digitais, essenciais para o entendimento do presente trabalho. A Seção \ref{sec:caracteristicas_temporais_portas_logicas} apresenta as características temporais das portas, assim como os modelos de atraso adotados no fluxo \textit{standard cell}. Os modelos de interconexões e as suas características temporais serão apresentados nas Seções \ref{sec:modelos_interconexoes} e  \ref{sec:caracteristicas_temporais_interconexoes}, respectivamente.

\section{Características Temporais das Portas Lógicas}
\label{sec:caracteristicas_temporais_portas_logicas}

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\subfigure[]
{
\includegraphics[width=0.5 \linewidth]{imagens/portalogica_e_fio.pdf}
\label{fig:informacoes_temporais_porta_logica_a}
}
\subfigure[]
{
\includegraphics[width=0.9 \linewidth]{imagens/atrasos_nand.pdf}

}
\caption{(a) Uma porta lógica \textit{CMOS} $u1$, de função \textbf{NAND}, com duas entradas é \textit{driver} da interconexão \textit{n1}. (b) Algumas características temporais (\textit{delay} e \textit{slew}) da porta lógica $u1$.}
\label{fig:informacoes_temporais_porta_logica}
\end{center}
\end{figure}

As características temporais do circuito são derivadas das características temporais de suas partes, quais sejam, as portas lógicas e as interconexões que o compõem. Para as portas lógicas, as informações a seguir são relevantes \citacaoAzul{Livramento2013}:

\begin{itemize}
\item \textbf{\textit{Timing Arc} (Arco de Tempo):} é um conceito utilizado para associar um pino de entrada de uma porta com a saída dessa mesma porta. Uma porta \textit{NAND} de duas entradas, como a apresentada na Figura \ref{fig:informacoes_temporais_porta_logica_a} possui dois \textit{timing arcs}: um entre a entrada $a$ e a saída ($a \to o$) e outro entre a entrada $b$ e a saída ($b \to o$). Para elementos sequenciais, como os registradores, normalmente consideram-se como \textit{timing arcs} as conexões entre o sinal de relógio e as saídas. O arco é chamado \textit{positive unate} se uma transição de subida (descida) na entrada causa uma transição de subida (descida) na saída. Se uma transição de subida (descida) da entrada causa uma transição de descida (subida) na saída, o arco é chamado \textit{negative unate} \citacaoAzul{BhaskerChadha09}.

	\item \textbf{\textit{Delay} (Atraso de Propagação): } é o tempo que o sinal em um pino de saída $o$ leva para atingir um limiar\footnote{Este limiar geralmente é definido nas bibliotecas de célula como sendo 50\% do $Vdd$.} de sua transição total, devido a uma mudança no sinal em um pino de entrada. Se a transição em $o$ for do nível lógico 0 para 1, o atraso é chamado de atraso de subida (\textit{rise delay}), caso o contrário, é chamado de atraso de descida (\textit{fall delay}) (Figura \ref{fig:informacoes_temporais_porta_logica}).
	
	\item \textbf{\textit{Slew} (Tempo de Transição): } é o tempo que um sinal leva para transicionar de uma porcentagem do valor de referência ($V_{dd}$) à outra \citacaoAzul{BhaskerChadha09}\footnote{Nas bibliotecas de células, essas porcentagens geralmente são definidas como 20\% e 80\% ou 10\% e 90\%}. Se a transição for de um valor for de uma porcentagem menor para uma maior, ela é chamada de transição de subida (\textit{rise slew}), caso contrário, trata-se de ua transição de descida (\textit{fall slew}) (Figura \ref{fig:informacoes_temporais_porta_logica}).
	
	\item \textbf{Propagação do \textit{Slew: }} é a política utilizada para propagação dos \textit{slews} das entradas até as saídas das portas lógicas. A estratégia geralmente adotada é a de propagar para o pino de saída da porta lógica o maior dentre os \textit{slews} associados aos \textit{timing arcs}.
	
	\item \textbf{\textit{Driver:} } é a porta lógica (ou o pino de saída de uma porta lógica) que gera o sinal para uma interconexão. Cada interconexão possui apenas um \textit{driver}.
	
\end{itemize}





\subsection{Modelo de atraso adotado em fluxo \textit{standard cell}}
%
%\afazer{apresentar lookup table
%
%falar da interpolaç~ao
%
%modelo n~ao linear}	

%Na Análise de \textit{Timing} Estática, os cicuitos são modelados considerando duas partes principais, as portas lógicas e as interconexões. As portas lógicas são modeladas a nível de seus arcos de \textit{timing}, e seus modelos são fornecidos pelas bibliotecas de célula, através de elementos conhecidas como \textit{lookup tables}. As interconexões, podem receber um modelo simplista ou mais sofisticado, dependendo da etapa que o projeto se encontra no fluxo \textit{standard cell}. Para etapas mais preliminares, as interconexões são modeladas como capacitâncias, sem atraso. Nas etapas seguintes, as interconexões são representadas por suas árvores RC.
%	
%	Nesta seção, serão apresentados detalhes sobre a modelagem das portas lógicas, e seu mapeamento para a biblioteca de célula, e posteriormente, como é calculado o atraso de propagação nas interconexões, dependendo do modelo empregado.
	
	%\includegraphics[width=0.8 \linewidth]{imagens/methodology_for_rc_delay_calculation.png} 



Nas bibliotecas \textit{standard cell} atuais, modelos de atrasos não-lineares\footnote{Conhecidos na indústria por \textit{NLDM} (\textit{Non-Linear Delay Model})\abreviatura{NLDM}{Non-Linear Delay Model}} são fornecidos para os \textit{timing arcs} das células disponíveis. Esses modelos, que geralmente são obtidos através de simulações em nível elétrico, são armazenados na forma de \textit{lookup tables}, como a da Figura \ref{fig:lookup_table}. Uma \textit{lookup table} descreve o \textit{delay} ou o \textit{slew} de uma célula em função de dois fatores: o \textit{slew} na entrada do \textit{timing arc} (colunas), e a capacitância de saída (\textit{load}) (linhas).



Utilizando a \textit{lookup table} da Figura \ref{fig:lookup_table} para estimar o \textit{delay} de um dos \textit{timing arcs} de uma célula \textit{CMOS} e supondo que o \textit{slew} na entrada deste \textit{timing arc} seja de $8.0$, e a capacitância vista na saída seja $0.1$, obtém-se que $delay = 3.49$, pois $3.49$ é o valor endereçado pelos índices da função (\textit{slew} e \textit{load}). Caso os valores de \textit{slew} ou \textit{load} não existam na tabela, uma interpolação linear é realizada. Da mesma forma, o cálculo do \textit{slew} do \textit{timing arc} é realizado com base na \textit{lookup table} específica para o \textit{slew}.


\begin{figure}[ht]
\lstset{basicstyle=\footnotesize}
\begin{lstlisting}[frame=single]
rise_delay (delay_table) {
 load (0.0, 0.1, 0.2, 0.4, 0.8, 1.6, 3.2) ;
 input_slew (0.5, 3.0, 5.0, 8.0, 14.0, 20.0, 30.0, 50.0) ;
 values (
   1.17, 1.82, 2.26, 2.76, 3.48, 4.04, 4.82, 6.12,
   1.69, 2.34, 2.86, 3.49, 4.41, 5.11, 6.06, 7.58,
   2.21, 2.86, 3.38, 4.12, 5.22, 6.05, 7.16, 8.90,
   3.25, 3.90, 4.42, 5.20, 6.60, 7.67, 9.08, 11.23,
   5.33, 5.98, 6.50, 7.28, 8.84, 10.30, 12.24, 15.14,
   9.50, 10.15, 10.67, 11.45, 13.01, 14.57, 17.15, 21.33,
   17.83, 18.48, 19.00, 19.78, 21.34, 22.90, 25.50, 30.70
  );
}
\end{lstlisting}
\caption{Uma \textit{lookup table} para atraso de subida (\textit{rise delay}) de um arco de \textit{timing}. As linhas são endereçadas por \textit{load} (capacitância de saída da porta lógica) e as colunas por \textit{input slew} (\textit{slew} aplicado na entrada do \textit{timing arc}). Adaptada de \citacaoAzul{Contest2013}.}
\label{fig:lookup_table}
\end{figure}

\section{Modelos de Interconexão}
\label{sec:modelos_interconexoes}

%\afazer{Fazer um link: Motivação: Primeiro parágrafo de introdução do paper ``Performance Optimization of VLSI Interconnect Layout''}


Modelos de interconexão devem ser adotados de acordo com a etapa que o projeto se encontra no fluxo. Nas etapas iniciais, ou de \textit{pre-layout}, ainda não há informações sobre o posicionamento e sobre o roteamento. Assim, as interconexões recebem modelos simplistas, possibilitando que as otimizações necessárias sejam realizadas, sem degradação no desempenho, para que as informações reais dos parasitas sejam apuradas. Nas etapas mais próximas da síntese física, ou \textit{pos-layout}, as interconexões são modeladas em função de suas capacitâncias e resistências, com o intuito de fornecer uma simulação mais precisa possível.

Esta seção tem por objetivo, apresentar alguns modelos de representação de interconexões, suas vantagens e desvantagens. Também será apresentado o formato de representação de parasitas mais utilizado no projeto de circuitos digitais.

	\subsection{Modelo RC Distribuído (\textit{Distributed RC Model})}

Uma interconexão pode ser representada idealmente como uma linha distribuída (Figura \ref{fig:distributed_rc}): a linha de comprimento $L$ é dividida em segmentos de tamanho $\Delta L$, com $\Delta L \to 0$, e cada segmento é representado por um valor de resistência $r$ e um valor de capacitância $c$. Assim, a resistência e a capacitância total da linha são $r \times L$ e $c \times L$, respectivamente. O cálculo dos atrasos no modelo RC distribuído implica na resolução de equações diferenciais, as quais possuem soluções complexas. Uma solução numérica seria realista, porém resulta em um custo computacional muito elevado, tornando inviável sua adoção em fluxo \textit{standard cell}. Para tal objetivo, utilizam-se modelos de interconexão simplificados.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\linewidth]{imagens/distributed_rc.pdf}
% \includegraphics{sta.png}
\caption{Modelo RC Distribuído. Obtida de \citacaoAzul{Rabaey08}.}
\label{fig:distributed_rc}
\end{center}
\end{figure}


	\subsection{Modelo de Capacitância Concentrada (\textit{Lumped C Model})}
	
		O Modelo de capacitância concentrada é geralmente utilizado nas etapas iniciais do projeto, pois se trata de um modelo simples com fácil simulação. Quando a resistência da interconexão é desprezível, devido o fato de que a resistência do \textit{driver} é substancialmente maior que a resistência total da interconexão, ou quando as informações parasitas ainda não foram obtidas com detalhe, o fio pode ser representado como um capacitor $C$, que corresponde à capacitância total da interconexão. Seu atraso de propagação é desconsiderado, já que o fio não possui resistências. Seu único impacto no desempenho é a sua contribuição na capacitância vista pelo \textit{driver} \citacaoAzul{Rabaey08}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\linewidth]{imagens/lumped_c.pdf}
% \includegraphics{sta.png}
\caption{Modelo de Capacitância Concentrada. Adaptada de \citacaoAzul{Rabaey08}.}
\label{fig:lumped_model}
\end{center}
\end{figure}

	\subsection{Modelo RC Concentrado (\textit{Lumped RC Model})}

O modelo RC concentrado é amplamente adotado no fluxo \textit{standard cell} para modelagem das interconexões. No modelo RC concentrado, concentra-se toda a resistência de cada segmento da interconexão em um único resistor $R$ e similarmente, combina-se a capacitância total em um único capacitor $C$. A rede resistor-capacitor é normalmente representada como uma árvore RC (Figura \ref{fig:rc_tree}). De acordo com \citacaoInline{Rabaey08}, uma árvore RC possui as seguintes propriedades:
		
\begin{itemize}
\item A rede tem apenas um nodo de entrada, chamado de \textbf{fonte} (\textit{source});
\item Todos os capacitores são entre um nodo e o terra;
\item A rede não possui \textit{loops} resistivos, por isso é chamada de Árvore.
\end{itemize}


		\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7 \linewidth]{imagens/rc_tree.jpg}
% \includegraphics{sta.png}
\caption{Uma árvore RC. Obtida de \citacaoAzul{Rabaey08}.}
\label{fig:rc_tree}
\end{center}
\end{figure}

		

%		\subsubsection{Limitações do Modelo RC Concentrado}
%
%			Com a utilização do atraso de Elmore, ignora-se o fato de que algumas resistências influenciam nas capacitâncias dos nodos da Árvore RC, ponderando de forma diferente a soma da Equação \ref{eq:tau}. Ao se obter a resistência compartilhada entre dois nodos $i$ e $k$ e o nodo fonte $s$, o impacto da resistência nas capacitâncias \textit{downstream} de $i$ e $k$ não são considerados, resultando em uma perda de precisão no modelo de atraso de Elmore. Por exemplo, a influência de $R_2$ em $C_2$ não é considerada no atraso $\tau_{D4}$ (Figura \ref{fig:rc_tree}). Esse efeito é conhecido como \textit{resistive shield} \citacaoAzul{Kashyap00}. Considerando um caso hipotético, nesta topologia, se $R_2 = \infty$, o atraso de Elmore $\tau_{D4}$ continuaria sendo dado pela Equação \ref{eq:delay_4}, mesmo que $R_2$ impedisse $C_4$ de ser carregado ou descarregado.




\subsection{Extração de Elementos Parasitas no Projeto de Circuitos Digitais}

Quando se tem as informações de capacitância e resistência totais de uma interconexão, $C_{wire}$ e $R_{wire}$ respectivamente, em uma fase de \textit{pré-layout}, é necessário criar uma topologia para este fio, uma vez que o atraso da interconexão depende de como ela está estruturada. Existem três topologias (Figura \ref{fig:interconnect_tree}) que podem ser utilizadas a fim de representar a interconexão \citacaoAzul{BhaskerChadha09}:



\begin{itemize}
\item \textbf{Árvore de melhor caso (\textit{Best-case tree}): } (Figura \ref{fig:interconnect_tree}-a) Assume-se que cada pino de destino é fisicamente adjacente ao \textit{driver}. Assim, nenhuma resistência estará no caminho entre \textit{driver} e destino, e todos os pinos de destino atuarão como \textit{load} na saída da interconexão.

\item \textbf{Árvore balanceada (\textit{Balanced tree}): } (Figura \ref{fig:interconnect_tree}-b) Na árvore balanceada, todos os pinos de destino se encontram na mesma distância do \textit{driver}, e o caminho para cada destino corresponde a mesma quantidade de capacitância e resistência que os outros caminhos.

\item \textbf{Árvore de pior caso (\textit{Worst-case tree}): } (Figura \ref{fig:interconnect_tree}-c) Neste caso, todos os destinos se encontram no fim da interconexão. Assim, cada pino de destino vê a resistência e a capacitância total da interconexão.
\end{itemize}

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.8 \linewidth]{imagens/interconnect_tree.png}
% \includegraphics{sta.png}
\caption{Representações utilizadas para as árvores RC em um contexto de \textit{pre-layout}. Obtida de \citacaoAzul{BhaskerChadha09}.}
\label{fig:interconnect_tree}
\end{center}
\end{figure}
\abreviatura{SPEF}{Standard Parasitic Exchange Format}
\abreviatura{SPF}{Standard Parasitic Format}
\abreviatura{DSPF}{Detailed Standard Parasitic Format}
\abreviatura{RSPF}{Reduced Standard Parasitic Format}
\abreviatura{IEEE}{Institute of Electrical and Electronics Engineers}

		Em projetos de circuitos digitais, as capacitâncias parasitas são geralmente descritas no formato SPEF \footnote{Existem outros formatos como SPF (\textit{standard parasitic format}), DSPF (\textit{detailed standard parasitic format}), RSPF (\textit{reduced standard parasitic format}) e SBPF (\textit{Synopsys binary parasitic format}).} (\textit{Standard Parasitic Exchange Format}) definido pelo \textit{IEEE} (\textit{Institute of Electrical and Electronics Engineers}). O formato SPEF é um padrão feito para garantir a interoperabilidade entre ferramentas de automação de projeto eletrônico (\textit{EDA: Electronic Design Automation}). Os parasitas podem ser representados em diferentes níveis de sofisticação, desde o simplista modelo de capacitância concentrada, até uma representação mais precisa de Árvores RC.

		Um exemplo de interconexão descrita no formato SPEF \citacaoAzul{IEEE99} pode ser visualizado nas Figuras \ref{fig:spef_example} e \ref{fig:spef_example_code}. A linha 1 no código SPEF da Figura \ref{fig:spef_example_code} apresenta o nome da interconexão (\emfase{inp1}) e o valor de sua capacitância total ($5.4$). As linhas 2, 3 e 4 indicam que existe uma conexão entre uma entrada primária \emfase{inp1}, indicado por \emfase{*P inp1 I}, e a entrada de um pino interno \textit{a} da porta \emfase{u1}, indicado por \emfase{*I u1:a I}. Da linha 6 até a linha 9 são representadas as capacitâncias da árvore RC.

		A representação de um capacitor num arquivo SPEF se dá pelo formato:

		\begin{verbatim}
		[Número] [Nome] [Capacitância]
		\end{verbatim}

		De maneira semelhante, os resistores, como pode ser visto nas linhas 11 até 13, são descritos no formato:

		\begin{verbatim}
		[Número] [Capacitor Fonte] [Capacitor Destino] [Resistência]
		\end{verbatim}

		O valor $*END$ (linha 14) é utilizado para determinar o fim da descrição de uma interconexão.

\begin{figure}[ht!]
\begin{center}
\subfigure[]
{
\includegraphics[trim=0 8cm 0 0, clip=true, width=0.8 \linewidth]{imagens/spef_example}
\label{fig:spef_example}
}
\subfigure[]
{
\includegraphics[width=0.4 \linewidth, trim=0 4cm 0 0, clip=true]{recursos/spef_example_code.pdf}
\label{fig:spef_example_code}
}
\end{center}
\caption{(a) Interconexão RC obtida do circuito $simple$ da competição de \textit{sizing} do ISPD. (b) SPEF referente à Figura \ref{fig:spef_example}.}
\end{figure}
		

\section{Características Temporais das Interconexões}
\label{sec:caracteristicas_temporais_interconexoes}


\begin{figure}[ht]
\begin{center} % TRIM = L D R U
\subfigure[]
{
\includegraphics[width=0.6 \linewidth]{imagens/modelagem/circuito.pdf} 
\label{fig:circuito_exemplo_modelagem_interconnect}
}
\subfigure[]
{
\includegraphics[width=0.6 \linewidth]{imagens/modelagem/modelagem.pdf} 
\label{fig:circuito_exemplo_modelagem_interconnect2}

}
\caption{(a) Um circuito composto por três portas lógicas ($u1$, $u2$ e $u3$), uma célula sequencial ($f1$) e uma interconexão em forma de árvore RC, que liga a saída de $u1$ às entradas de $u2$, $u3$ e $f1$; (b) São apresentadas as modelagens para os \textit{timing arcs} da porta lógica $u1$; O modelo da interconexão é abstraído, recebendo um valor de capacitância efetiva. As setas indicam que a interconexão oferece um atraso e uma degradação no \textit{slew}. Cada destino da interconexão é representado como um valor de capacitância de seus pinos de entrada. }
\label{fig:circuito_exemplo_modelagem_interconnect_inteira}
\end{center}
\end{figure}

A Figura \ref{fig:circuito_exemplo_modelagem_interconnect_inteira} ilustra as três principais contribuições das interconexões, sobre o atraso do circuito:
\begin{itemize}
	\item \textbf{Capacitância Vista Pelo \textit{Driver}: } É necessário modelar a carga capacitiva a ser carregada pelo \textit{driver} da interconexão com o objetivo de se obter a informação de \textit{load}, a qual é utilizada no cálculo do \textit{delay} e \textit{slew} dos \textit{timing arcs} das portas lógicas, como visto anteriormente. Nesta capacitância é incluído também o impacto causado pelos pinos de destino da interconexão \footnote{Um pino de destino de uma interconexão é um pino que se liga na interconexão, que não é o pino \textit{driver}. Por exemplo, na Figura \ref{fig:circuito_exemplo_modelagem_interconnect}, os pinos de destino da interconexão são o segundo pino de entrada da porta $u2$, o pino de entrada da porta $u3$ e o pino $d$ do \textit{flip-flop} $f1$.}. Na fase \textit{pré-layout}, essa estimativa é realizada somando a capacitância total da interconexão com a capacitância de cada pino de destino dela. Porém, ao se tratar de interconexões com característica resistiva, o uso da abordagem de capacitância concentrada é impreciso. Para que os modelos de atraso não-lineares, que dependem do valor de capacitância de saída, sejam utilizados para os \textit{drivers} diretamente, é necessário o uso de uma abordagem conhecida como \textbf{Capacitância Efetiva ($C_{eff}$)}. Tal abordagem tenta encontrar um valor de capacitância que pode ser utilizado como carga equivalente, em termos de \textit{timing}, para a saída do \textit{driver} \citacaoAzul{BhaskerChadha09}. Algumas técnicas serão abordadas no Capítulo \ref{cap:tecnica}.

	\item \textbf{Atraso da Interconexão: } Além do impacto local nos \textit{delays} e \textit{slews} de seus \textit{drivers}, as interconexões exercem impacto global no circuito, com seu próprio atraso de propagação (Figura \ref{fig:circuito_exemplo_modelagem_interconnect2}), devido a sua característica resistiva. Com a alta frequência de operação dos circuitos digitais atuais e o dimensionamento dos transistores para escalas nanométricas, os atrasos das interconexões, que antes não eram significativos, hoje chegam consumir de 50\% a 70\% do ciclo do relógio, e esta porcentagem tende a aumentar na medida que os transistores diminuem \citacaoAzul{Cong96}. Uma das métricas mais populares para se calcular o atraso em interconexões é o atraso de Elmore (\textit{Elmore Delay}) \citacaoAzul{Elmore48}, pela simplicidade e razoável correlação com os atrasos reais. Esta técnica será apresentada com mais detalhes na Seção \ref{sec:calculo_elmore}.
	
	\item \textbf{Degradação do \textit{Slew}: } O cálculo do \textit{slew} é crucial para determinar a precisão de uma avaliação de \textit{timing} em um circuito digital \citacaoAzul{Zhou2007}. Os \textit{delays} dos \textit{timing arcs} dependem do \textit{slew} de entrada e do \textit{slew} de saída. Quando um sinal se propaga por uma interconexão, seu \textit{slew} (i.e., sua declividade) sofre uma degradação devido ao efeito resistivo da mesma (Figura \ref{fig:circuito_exemplo_modelagem_interconnect2}). A não-modelagem desta degradação pela interconexão, acarreta em erros de até 50\% \citacaoAzul{Sheehan2002}. A abordagem para degradação do \textit{slew} utilizada neste trabalho será apresentada na Seção \ref{sec:degradacao_slew}.
\end{itemize}
		
		
%Conforme explicado anteriormente, o impacto local de uma interconexão no seu \textit{driver} se dá pela contribuição no valor da capacitância vista pelo mesmo. 
%
%Para se realizar os cálculos de atrasos com precisão e eficiência, modelos são utilizados para o \textit{driver}, para a interconexão e para os destinos. Cada arco de \textit{timing} é modelado de modo a fazer com que os atrasos correspondam com a simulação elétrica. A interconexão, da mesma maneira, é modelada geralmente com modelos simplificados, que capturam o comportamento elétrico da descrição original da Árvore RC.

%Na Figura \ref{fig:circuito_exemplo_modelagem_interconnect} é mostrado um circuito de exemplo composto por três portas lógicas ($u1$, $u2$ e $u3$), uma célula sequencial ($f1$) e a interconexão que liga a saída de $u1$ nas entradas de $u2$, $u3$ e $f1$. Na Figura \ref{fig:circuito_exemplo_modelagem_interconnect2} é ilustrada a modelagem deste circuito de exemplo.
%
%Existem algumas maneiras conhecidas de estimar o valor de capacitância visto na saída do \textit{driver}. 









\chapter{Cálculo das Características Temporais da Interconexão}
\label{cap:tecnica}
		
		Este capítulo tem por objetivo apresentar uma técnica utilizada para o cálculo das características temporais das interconexões, necessário para a estimativa de \textit{timing} global dos circuitos digitais. Na Seção \ref{sec:representacao_interconexoes_puri} será apresentado um modelo computacional para as interconexões. A Seção \ref{sec:calculo_elmore} apresentará uma revisão bibliográfica mostrando algumas técnicas para cálculo do atraso das interconexões, bem como a técnica de Elmore e a técnica escolhida para ser implementada no presente trabalho, que será detalhada na Seção \ref{sec:calculo_ceff_degradacao}.
	
\section{Representação das Interconexões}
\label{sec:representacao_interconexoes_puri}
		% \label{cap:atraso}
		% \afazer{Neste capítulo, serão apresentados detalhes sobre a implementação dos modelos de atrasos de interconexões, complementando a informação já obtida no Capítulo \ref{cap:sta}.}

		Para que o atraso de uma interconexão seja estimado com precisão, um modelo de grafo (Figura \ref{fig:grafo_interconexao}) pode ser utilizado para representar o fio em termos de capacitâncias e resistências.

		No modelo de grafo $I(C, R)$ utilizado, o conjunto dos vértices é composto pelos nodos internos da interconexão, que representam cada capacitor. As arestas do grafo modelam os resistores, e cada resistor conecta um par de capacitores. Sendo assim:
		\begin{itemize}
		\item \textbf{C} = \{$c | c$ é um capacitor da rede RC\}
		\item \textbf{R} = \{$(c, d) |$ existe um resistor que conecta os capacitores $c$ e $d$\}
		\end{itemize}
	
		\begin{figure}[ht]
		\begin{center}% TRIM = L D R U
		\includegraphics[width=0.5 \linewidth, trim=0cm 12cm 0 0, clip=true]{imagens/grafo_interconexao/grafo.pdf}
		\caption{O grafo correspondente à interconexão da Figura \ref{fig:circuito_exemplo_modelagem_interconnect}, com cinco vértices e quatro arestas.}
		\label{fig:grafo_interconexao}
		\end{center}
		\end{figure}


\section{Cálculo do Atraso das Interconexões} 
\label{sec:calculo_elmore}
		
\abreviatura{AWE}{Asymptotic Waveform Evaluation}
\abreviatura{PRIMA}{Passive Reduced-Order Interconnect Macromodeling Algorithm}

Diversas técnicas são empregadas no cálculo do atraso das interconexões. Uma vez que o cálculo real dos atrasos das interconexões possui custo muito elevado para ser realizado para milhares de interconexões em centenas de vezes, modelos aproximados geralmente são utilizados no fluxo \textit{standard cell}. A avaliação assintótica da forma de onda (\textit{AWE: Asymptotic Waveform Evaluation}) \citacaoAzul{AWE} é uma técnica amplamente utilizada para geração de modelos de ordem reduzida, realizando uma aproximação na função de transferência via aproximação de Padé. Outras técnicas como PRIMA (Passive Reduced-Order Interconnect Macromodeling Algorithm) \citacaoAzul{Odabasioglu1997} possuem uma alta complexidade computacional, sendo muito lentas para serem utilizadas no contexto de uma técnica de otimização, como \textit{gate sizing} \citacaoAzul{Markov13}.

A técnica de \citacaoInline{Elmore48} é uma técnica baseada no primeiro momento da resposta ao impulso amplamente utilizada no cálculo dos atrasos das interconexões. A popularidade da técnica de Elmore deve-se aos fatores que seguem:
		
\begin{itemize}
\item Boa correlação com os atrasos reais nos nodos mais afastados do \textit{driver} \citacaoAzul{Kashyap00};
\item Utiliza uma fórmula fechada, que envolve apenas as resistências e capacitâncias do circuito \citacaoAzul{Horowitz1983};
\item Provê um limite superior provado para o atraso real de qualquer árvore RC \citacaoAzul{Gupta97};
\item É aditiva, ou seja, o atraso do nodo A até o nodo C passando pelo nodo B é a soma dos atrasos entre A e B e entre B e C \citacaoAzul{Kashyap00}.
\end{itemize}
	
De acordo com \citacaoInline{Rabaey08}, em um nodo $c_i$ da árvore RC, o atraso de Elmore ($\tau_i$) pode ser facilmente calculado como:
\begin{equation}
\tau_i = \sum_{k=1}^{N} C_k R_{ik}
\label{eq:elmore}
\end{equation}


Onde $N$ é o número de capacitores da árvore RC, $C_k$ é o valor de capacitância do nodo $c_k$ e $R_{ik}$ é a resistência compartilhada entre os caminhos $s \to i$ e $s \to k$ ($s$ é o nodo fonte), ou seja:
\begin{equation}
R_{ik} = \sum R_j \Rightarrow (R_j \in [caminhos(s \to i)\cap caminhos(s \to k)])
\label{eq:rik}
\end{equation}

Na topologia da Figura \ref{fig:circuito_exemplo_modelagem_interconnect}, $C0$ é o nodo fonte. Assim, o atraso de Elmore para o nodo $C4$ é:

\begin{equation}
\tau_4 = C_1\ R_1 + C_2\ R_1 + C_3 \ R_1 + C_4(R_1+R_4) 
\label{eq:delay_4}
\end{equation}

A técnica de Elmore pode ser implementada também em sua forma recursiva. O algoritmo para cálculo do atraso de Elmore recebe como entrada o grafo $I(C, R)$ da interconexão e é executado após a inicialização das capacitâncias totais \textit{downstream} ($C_{total_i}$) de cada nodo interno. 
		
\begin{enumerate}

\item \textbf{Inicialização das capacitâncias totais \textit{downstream}:} Os nodos internos são numerados de $1$ até $n$ em ordem topológica, sendo $n$ o tamanho do conjunto de vértices. Assim, o passo de inicialização de cada $c_i \in C$ acontece em ordem topológica reversa, seguindo a Equação \ref{eq:inicializacao_elmore};
		
\begin{equation}
C_{total_i} = C_i + \sum_{j \in filhos(i)} C_{total_j}
\label{eq:inicializacao_elmore}
\end{equation}

Sendo que $C_i$ é o valor de capacitância do nodo $c_i$. O conjunto $filhos(i)$ é o conjunto de capacitores que estão interligados diretamente com o capacitor $c_i$ através de um resistor $R$, que tenham um nível topológico maior que este\footnote{Caso $c_i$ seja um nodo terminal, seu conjunto $filhos(i)$ é vazio.}. Analogamente, o $pai(i)$ é um capacitor que precede $c_i$\footnote{Se $c_i$ não for o nodo fonte da árvore.} e se conecta com ele, também, através de um resistor. 

\item \textbf{Cálculo dos atrasos utilizando a técnica de Elmore:}  O atraso de Elmore em cada nodo $c_i$ da interconexão é calculado recursivamente, somando o atraso no pai de $c_i$ com o valor da resistência que liga $c_i$ ao seu pai multiplicado pela capacitância total \textit{downstream} de $c_i$, como mostrado na Equação \ref{eq:elmore_recursivo}.

\begin{equation}
\tau_i = \tau_{pai(i)} + R(pai(i), i) \times C_{total_i}
\label{eq:elmore_recursivo}
\end{equation}

\end{enumerate}

A função $R(i, j)$ retorna o valor da resistência que liga dois capacitores $c_i$ e $c_j \in C$. O atributo $C_{total_i}$ é a capacitância total \textit{downstream} de um nodo $c_i$. Assim, o cálculo do atraso em cada nodo da interconexão compõe o atraso da interconexão partindo do \textit{driver} até cada pino de destino.

A técnica de Elmore para atraso de interconexões fornece boas aproximações quando o efeito conhecido como \textit{resistive shielding} não é tão alto. Este efeito acontece devido ao fato de que as resistências alteram o tempo que as capacitâncias levam para serem carregadas ou descarregadas. O efeito de \textit{resistive shielding} faz com que o atraso do \textit{driver} de uma interconexão seja menor que o atraso dele considerando a capacitância concentrada da interconexão. Similarmente, o efeito faz com que o atraso da interconexão seja menor que o atraso de Elmore utilizando o valor de capacitância total para cada segmento. Considere a interconexão da Figura \ref{fig:circuito_exemplo_modelagem_interconnect}, no caso extremo em que $R4 = \infty$, o capacitor $C4$ nunca seria carregado, e portanto, o atraso da interconexão não deveria levar em consideração o valor do capacitor $C4$.

Algumas adaptações na técnica de Elmore foram propostas para que o cálculo do atraso das interconexões capturem também o efeito do \textit{resistive shielding} utilizando a abordagem da capacitância efetiva em cada nodo da interconexão. Na Figura \ref{fig:effective_capacitance_vs_actual_vs_total}, as transições na saída de um \textit{driver} são comparadas ao se utilizar a abordagem de capacitância efetiva (linha pontilhada) e de capacitância concentrada (linha contínua). Pode-se observar que para o valor escolhido de capacitância efetiva, o sinal leva o mesmo tempo para atingir o ponto médio da curva (\textit{$V_{dd} = 50\%$}) que quando o \textit{driver} está conectado diretamente à carga real da árvore RC (linha tracejada). Note a diferença neste ponto em relação à curva de capacitância concentrada, mostrando a imprecisão de se utilizar este modelo em certos casos.

\begin{figure}[ht]
\begin{center} % TRIM = L D R U
\includegraphics[width=\linewidth]{imagens/effective_capacitance_vs_actual_vs_total.pdf} 
\caption{Formas de onda na saída de uma porta lógica em função da abordagem utilizada para cálculo da capacitância. Obtida de \citacaoAzul{BhaskerChadha09}.}
\label{fig:effective_capacitance_vs_actual_vs_total}
\end{center}
\end{figure}

Como a abordagem de capacitância efetiva está relacionada à consideração do efeito de \textit{resistive shielding}, ao utilizá-la em cada segmento da interconexão, é possível obter-se um atraso na interconexão mais preciso do que o atraso de Elmore, mesmo sem considerar momentos de maior ordem da resposta ao impulso.

\citacaoInline{Kashyap00} propuseram uma técnica para calcular o atraso da interconexão levando em conta o efeito de \textit{resistive shielding}. Com a mesma complexidade da técnica de Elmore, a técnica proposta para cálculo de atraso em uma árvore RC calcula também o valor de capacitância efetiva. Porém, \citacaoInline{Kashyap00} não consideravam o \textit{driver} da interconexão como sendo uma porta lógica \textit{CMOS}. Como consequência, sua aproximação para o \textit{slew} na entrada da árvore RC era imprecisa. Como o cálculo da capacitância efetiva de uma árvore depende do \textit{slew} que incide nesta, e o \textit{slew} depende da capacitância vista pelo \textit{driver}, \citacaoInline{PURI02} propuseram uma técnica que leva em consideração o impacto da capacitância no \textit{slew} do driver, e também, do \textit{slew} no cálculo da capacitância efetiva. Esta técnica será apresentada na Seção \ref{sec:calculo_ceff_degradacao} e foi a técnica implementada neste trabalho.
		
\section{Técnica de \citacaoInline{PURI02} para o Cálculo da Capacitância Efetiva e Degradação do \textit{Slew}}
\label{sec:calculo_ceff_degradacao}
%\afazer{Aqui, será descrito em forma de Algoritmo ou Fluxograma, o algoritmo utilizado para cálculo do atraso, na abordagem de Capacitância Efetiva \citacaoInline{PURI02}, que será implementado neste trabalho.}	

O objetivo desta seção é apresentar a técnica para cálculo das informações referentes às características temporais das interconexões que foi escolhida para ser implementada neste trabalho.

Devido ao fato de que o valor de capacitância efetiva de uma interconexão depende do \textit{slew} incidente nesta, que por sua vez, depende do valor de capacitância efetiva, \citacaoInline{PURI02} propuseram uma técnica iterativa para simular esta interdependência. A técnica em questão obtém o atraso de Elmore com capacitância efetiva para a interconexão, bem como a degradação do \textit{slew} e o valor de capacitância utilizado no cálculo do \textit{delay} e \textit{slew} do \textit{driver}.

A seguir serão apresentadas as técnicas para cálculo da capacitância efetiva e degradação do \textit{slew}, bem como o algoritmo implementado para realização desses cálculos.

\subsection{Cálculo da Capacitância Efetiva}

\simbolo{$C$}{Capacitor}
\simbolo{$R$}{Resistor}


\begin{figure}[ht]
\begin{center}
\includegraphics[width=\linewidth]{imagens/puri/imagem_puri.pdf}
\caption{Visão geral da técnica iterativa para o cálculo do atraso da interconexão, capacitância efetiva e degradação do \textit{slew}. Adaptada de \citacaoAzul{PURI02}.}
\label{fig:imagem_puri}
\end{center}
\end{figure}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\linewidth]{imagens/puri/effective_ramp.pdf}
\caption{Cálculo da capacitância efetiva utilizando rampa de entrada. Obtida de \citacaoAzul{PURI02}.}
\label{fig:effective_ramp}
\end{center}
\end{figure}

Considere uma rede $\pi$ $C_1 - R - C_2$ alimentada por uma fonte de tensão $V(t)$, como a ilustrada na Figura \ref{fig:effective_ramp}. Seja $I(t)$ a corrente total fornecida pela fonte de tensão $V(t)$, $I_1(t)$ a corrente através de $C_1$ e $I_2(t)$ a corrente através de $R - C_2$. De acordo com \citacaoInline{PURI02}, realizando uma análise no domínio da frequência, obtemos que:

\begin{equation}
I(s) = I_1(s) + I_2(s)
\end{equation}

Se

\begin{equation}
I_1(s) = \frac{V(s)}{1/C_1s}
\end{equation}

\begin{equation}
I_2(s) = \frac{V(s)}{R+1/C_2s}
\end{equation}

Então:

\begin{equation}
I(s) = \frac{V(s)}{1/C_1s} + \frac{V(s)}{R+1/C_2s}
\end{equation}

ou

\begin{equation}
I(s) = V(s)\left(C_1s + \frac{C_2s}{1+RC_2s}\right)
\label{eq:ifreq}
\end{equation}

Agora, considerando que a fonte de tensão $V(t)$ é uma rampa com tempo de subida $t_r$, $V(t)$ é dado por:

\begin{equation}
V(t) = \left\{
\begin{array}{l l}
\frac{V_{dd}}{t_r} \times t & \quad \text{se $t < t_r$} \\
V_{dd} & \quad \text{caso contrário}
\end{array} \right. 
\end{equation}

E no domínio da frequência:

\begin{equation}
V(s) = \frac{V_{dd}}{t_r} \times \frac{1}{s^2}\times (1-e^{-st_r})
\label{eq:vfreq}
\end{equation}

Substituindo a $V(s)$ da Equação \ref{eq:ifreq} pela Equação \ref{eq:vfreq} e voltando ao domínio do tempo obtém-se:

\begin{equation}
I(t) = \frac{V_{dd}}{t_r}((C_1 + C_2) - C_2e^{-\frac{t}{RC_2}}) \quad \text{para $t < t_r$}
\end{equation}

Em termos de \textit{timing}, na capacitância efetiva, a carga transferida $Q$ é a mesma que da rede $\pi$, no ponto médio da curva (tempo que a curva atinge $50\% V_{dd}$). A carga transferida $Q$ é a integral da corrente $I(t)$ com o tempo indo de $0$ até $t_r/2$:

\begin{equation}
Q = \int_0^{t_r/2} I(t) \mathrm{d}t = \int_0^{t_r/2} \frac{V_{dd}}{t_r}((C_1 + C_2) - C_2e^{-\frac{t}{RC_2}}) \mathrm{d}t
\end{equation}

A carga transferida $Q$ para carregar a capacitância efetiva da rede $\pi$ ($C_{eff}$) até $50\%$ de $V_{dd}$ é dada, também, por $\frac{C_{eff}V_{dd}}{2}$. Ao igualar as duas equações de transferência de carga, obtemos:

\begin{equation}
C_{eff} = C_1 + C_2(1 - \frac{2RC_2 V_{dd}}{t_r} (1 - e^{-\frac{t_r}{2RC_2}}))
\end{equation}

\simbolo{$C_{eff}$}{Capacitância Efetiva}

Assim, $C_{eff} = C_1 + C_2 \times K$, onde $K$ é o fator de \textit{shielding}, definido por:

\begin{equation}
K = 1 - 2x(1 - e^{-\frac{1}{2x}}), \quad  \text{onde } x = \frac{RC_2}{t_r}
\label{eq:shieldfactor}
\end{equation}

\subsection{Degradação do \textit{Slew} Através da Árvore RC}
\label{sec:degradacao_slew}

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\linewidth, trim=0 16cm 0 0, clip=true]{imagens/puri/degradacao_slew.pdf}
\caption{Degradação no \textit{slew} em um segmento de uma árvore RC. Obtida de \citacaoAzul{PURI02}.}
\label{fig:degradacao_slew}
\end{center}
\end{figure}


O \textit{slew} é degradado na árvore RC para obtenção de coeficientes mais precisos para os fatores de \textit{shielding}. Considere um segmento de uma árvore RC, mostrado na Figura \ref{fig:degradacao_slew}, que é alimentado por uma fonte de tensão $V(t) = \frac{V_{dd}}{t_r} \times t$, onde $t_r$ é o \textit{slew} da rampa de entrada. Conforme \citacaoAzul{PURI02}, a tensão de saída neste caso, quando $t = t_r$, pode ser derivada como:

\begin{equation}
\frac{V_{dd}}{t_r}(t_r - RC_2 + RC_2 e^{-\frac{t_r}{RC_2}})
\label{eq:slew2}
\end{equation}

Conforme a Figura \ref{fig:degradacao_slew}:

\begin{equation}
\frac{V_1}{t_r} = \frac{V_{dd}}{t_r'}
\label{eq:slew1}
\end{equation}

Onde $t_r'$ é o \textit{slew} na saída. Substituindo $V_1$ da Equação \ref{eq:slew1} pela Equação \ref{eq:slew2}, obtemos o valor de \textit{slew} na saída, em função do \textit{slew} aplicado na entrada:

\begin{equation}
t_r' = \frac{t_r}{1-x(1-e^{-\frac{1}{x}})} \quad \text{onde } x = \frac{RC_2}{t_r}
\end{equation}

Generalizando para uma árvore RC qualquer \footnote{Representada conforme apresentado na Seção \ref{sec:representacao_interconexoes_puri}.} e utilizando o valor de capacitância efetiva, o $slew_i$ no nodo $c_i$ é definido pela equação:

\begin{equation}
slew_i = \frac{slew_j}{1-\frac{R_i\ C_{eff_i}}{slew_j} (1-e^{-\frac{slew_j}{R_i\ C_{eff_i}}})}
\label{eq:degradacao_slew}
\end{equation}

\simbolo{$slew_i$}{Slew no nodo $i$ de uma interconexão}

Onde $slew_j$ é o \textit{slew} na entrada de $v_i$, vindo pelo nodo pai $v_j$ e $R_i$ é o valor do resistor que conecta $c_i$ com $c_j$

\subsection{O Algoritmo de \citacaoInline{PURI02}}

		Dado o grafo de uma árvore RC\footnote{Com os nodos numerados de $1$ a $n$ em ordem topológica, onde $n$ é o tamanho do conjunto de vértices e o nodo $c_1$ é o nodo fonte da árvore RC.}, o algoritmo apresentado nessa seção calcula os valores de capacitância efetiva e \textit{slew} em cada nodo interno da interconexão. Para o atraso da interconexão, o método implementa a técnica de Elmore utilizando os valores de capacitância efetiva, ao invés dos valores de capacitância total \textit{downstream}, simulando o efeito de \textit{resistive shielding}.
		
\simbolo{$C{eff_i}$}{Capacitância efetiva no nodo $i$ de uma interconexão}

		A capacitância efetiva é denotada em cada nodo $c_i$ por $C_{eff_i}$ e o \textit{slew} por $slew_i$. O valor do \textit{slew} aplicado no nodo fonte da árvore RC, denotado por $slew_1$, é exatamente o valor do \textit{slew} na saída do \textit{driver} desta interconexão, o qual é função do \textit{slew} na entrada da porta lógica \textit{driver} e da capacitância efetiva vista na saída. Este valor de \textit{slew} será refinado iterativamente para se estimar o valor de capacitância efetiva da interconexão.
		
\simbolo{$C{total_i}$}{Capacitância total \textit{downstream} no nodo $i$ de uma interconexão}
		
		
		O algoritmo para cálculo iterativo da capacitância efetiva de uma interconexão, bem como seu atraso e a degradação no \textit{slew}, conforme \citacaoAzul{PURI02}, ocorre em cinco passos:

		\begin{enumerate}

			\item \textbf{Inicialização:}

				\begin{enumerate}

					\item A capacitância efetiva $C_{eff_i}$ de cada nodo $c_i$ da Árvore RC é incializada com o valor de capacitância total \textit{downstream} de $c_i$, ou seja $C_{eff_i} = C_{total_i}$;
					
					\item O \textit{slew} no nodo fonte da árvore RC $slew_1$ é calculado utilizando o modelo de atraso da porta lógica \textit{driver}, considerando a capacitância concentrada da árvore RC (i.e., $\sum_{i=1}^N C_i$): $slew_1 = f(C_{total_1})$.

				\end{enumerate}

			\item \textbf{Atualização dos \textit{slews} em ordem topológica:}  \label{enum:algo_net_timing:1}

				\begin{enumerate}
\simbolo{$\tau_i$}{Atraso de Elmore no nodo $i$ de uma interconexão}

					\item Atraso $\tau_i$ do nodo fonte $c_1$ para cada nodo $c_i$ da árvore é calculado utilizando a técnica de Elmore (Equação \ref{eq:elmore_recursivo}), substituindo $C_{eff_i}$ por $C_{total_i}$, para simular o efeito de \textit{resistive shielding};


					\item A degradação do \textit{slew} em cada nodo $c_i$ é calculada utilizando a Equação \ref{eq:degradacao_slew}.
					
				\end{enumerate}

			\item \textbf{Atualização das capacitâncias efetivas em ordem topológica reversa:}
				\begin{enumerate}

					\item A capacitância efetiva ($C_{eff_i}$) de cada nodo $c_i$ é calculada como a soma da capacitância do nodo $c_i$ e todas as capacitâncias dos nodos filhos:

					\begin{equation}
						C_{eff_i}=C_i + \sum_{j \in filhos(i)}\ K_j \times C_{tot_j}
					\end{equation}
\simbolo{$K_j$}{Fator de \textit{shielding} correspondente ao efeito causado pelo resistor $R_j$ no nodo $j$}

					Onde $K_j$ é o fator de \textit{shielding}, definido por:

					\begin{equation}
						K_j=1-\frac{2R_jC_{eff_j}}{slew_i}(1-e^{-\frac{slew_i}{2R_jC_{eff_j}}})
					\end{equation}
					
					Onde $R_j$ é o valor da resistência que conecta o nodo $c_j$ ao seu pai, no caso, $c_i$.

				\end{enumerate}


			\item \textbf{Atualização do \textit{Slew} do \textit{Driver}:} O \textit{slew} no nodo fonte $slew_1$ é calculado diretamente, utilizando o $C_{eff_1}$ atual  \label{enum:algo_net_timing:2};

			\item \textbf{Iteração:} Os passos de \ref{enum:algo_net_timing:1} até \ref{enum:algo_net_timing:2} são repetidos até que $slew_1$ convirja, dada uma precisão $\varepsilon$ .

		\end{enumerate}
\simbolo{$\varepsilon$}{Menor número representável em ponto flutuante, utilizado como métrica de precisão}

Na implementação apresentada neste trabalho, o $\varepsilon$ foi definido como sendo $1\%$ e na maioria dos casos observados, cerca de $5$ iterações são necessárias para realizar o cálculo da capacitância efetiva \citacaoAzul{PURI02}. Como cada iteração do algoritmo percorre a lista em ordem topológica (direta e reversa), a complexidade assintótica de pior caso de cada iteração do algoritmo é de $O(n)$ onde n é o número de nodos da árvore, ao passo que a complexidade do algoritmo é $O(c.n)$, onde $c$ é o número de iterações. Entretanto, como o número de iterações é na grande maioria dos casos menor que $5$ (E portanto $c$ é muito menor que $n$), assume-se que o crescimento no tempo de execução tem comportamento linear.
		
%\section{Proposta de Modificação da Técnica de \citacaoInline{PURI02}}
%\label{sec:modificacao}
%
%Conforme dito anteriormente, o trabalho de \citacaoInline{PURI02} não esclarece como os \textit{slews} são anotados nos pinos de destino das interconexões. Por meio de experimentos foi possível observar que ao anotar-se os \textit{slews} degradados\footnote{que anteriormente foram utilizados para o cálculo da capacitância efetiva} nos pinos de destino da interconexão, a ferramenta reporta valores muito pessimistas para as informações globais do circuito, conforme observado na Tabela \ref{tab:ceff_elmore_slew}. Após uma pesquisa na bibliografia, uma métrica mais otimista de propagação dos \textit{slews} foi incorporada ao algoritmo de \citacaoInline{PURI02} a fim de obter resultados mais otimistas.
%
%Em \citacaoAzul{Hu2007} é abordado o problema da insersão de \textit{buffers} nas interconexões, a fim de reduzir as violações de \textit{slew}. Ao inserir um \textit{buffer} é necessário estimar o valor do \textit{slew} em sua entrada, considerando o \textit{slew} do \textit{driver} da interconexão e a degradação causada pela característica resistiva da mesma. Conforme \citacaoInline{Hu2007}, o \textit{slew} $s_j$ anotado na entrada da porta lógica destino da interconexão é \citacaoAzul{Kashyap2004}:
%
%\begin{equation}
%\label{eq:degradacao_slew_sqrt}
%s_j = \sqrt{s_i^2 + s_{i \to j}^2}
%\end{equation}
%
%Onde $s_i$ é o \textit{slew} no \textit{driver} da interconexão e $s_{i \to j}$ é a degradação do \textit{slew}. Considerando o atraso de Elmore no nodo destino da interconexão ($\tau_j$), a degradação pode ser calculada utilizando a métrica de \citacaoInline{Bakoglu1990}:
%\begin{equation}
%s_{i \to j} = ln(4) * \tau_j
%\end{equation}
%
%		O algoritmo para cálculo iterativo da capacitância efetiva de uma interconexão, bem como seu atraso de propagação ocorre em sete passos:
%
%		\begin{enumerate}
%
%			\item \textbf{Inicialização:} Este passo é exatamente o mesmo do algoritmo apresentado na Seção \ref{sec:calculo_ceff_degradacao}.
%
%			\item \textbf{Atualização dos \textit{slews} em ordem topológica:} A degradação do \textit{slew} em cada nodo $c_i$ é calculada utilizando a Equação \ref{eq:degradacao_slew}. \label{enum:algo_net_timing_mod:1}
%				
%			\item \textbf{Atualização das capacitâncias efetivas em ordem topológica reversa:} Este passo é exatamente o mesmo do algoritmo apresentado na Seção \ref{sec:calculo_ceff_degradacao}.
%
%			\item \textbf{Atualização do \textit{Slew} do \textit{Driver}:} O \textit{slew} no nodo fonte $slew_1$ é calculado diretamente, utilizando o $C_{eff_1}$ atual  \label{enum:algo_net_timing_mod:2};
%
%			\item \textbf{Iteração:} Os passos de \ref{enum:algo_net_timing_mod:1} até \ref{enum:algo_net_timing_mod:2} são repetidos até que $slew_1$ convirja, dada uma precisão $\varepsilon$.
%
%
%		\item \textbf{Anotação dos \textit{Slews} nos \textit{Fanouts}:} Para cada pino de destino da interconexão, o \textit{slew} é calculado usando a Equação \ref{eq:degradacao_slew_sqrt}.
%		
%		\item \textbf{Cálculo do Atraso de Elmore: } 
%			
%			\begin{enumerate}
%			
%				\item Atraso $\tau_i$ do nodo fonte $c_1$ para cada nodo $c_i$ da árvore é calculado utilizando a técnica de Elmore (Equação \ref{eq:elmore_recursivo});
%		
%				\item O atraso de Elmore em cada ponto de destino da interconexão é multiplicado por $ln(2)$, para se obter o tempo de transição até $50\% V_{dd}$.
%				
%			\end{enumerate}
%
%		\end{enumerate}
%		
%		

\chapter{Análise de \textit{Timing} Estática}
\label{cap:sta}

O objetivo deste capítulo é apresentar a análise de \textit{timing} estática (\textit{STA: Static Timing Analysis}), bem como os conceitos importantes referentes à esta técnica, juntamente com o algoritmo de STA.

Análise de \textit{timing} estática, ou \textit{static timing analysis} \citacaoAzul{Guntzel00} \citacaoAzul{BhaskerChadha09}, é uma das técnicas utilizadas para se estimar o atraso crítico de circuitos digitais. A análise de \textit{timing} é chamada de estática quando ela não realiza simulação e portanto, independe de estímulos de entrada, considerando apenas a topologia do circuito. É um processo completo e exaustivo \citacaoAzul{BhaskerChadha09} que verifica as mais diversas informações de \textit{timing} em um circuito, como os \textit{delays}, \textit{slews}, \textit{slacks} (folgas), \textit{required times} (tempos requeridos) e diversas violações de restrições de projeto.

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=0.8 \linewidth]{imagens/sta.pdf}
% \includegraphics{sta.png}
\caption{Análise de \textit{timing} estática. Adaptado de \citacaoAzul{BhaskerChadha09}.}
\label{fig:STA}
\end{center}
\end{figure}
\abreviatura{HDL}{Hardware Description Language}
Dada a descrição do projeto usando alguma linguagem de descrição de hardware (\textit{HDL: Hardware Description Language}), restrições de projeto e uma biblioteca de células, o objetivo da análise de \textit{timing} é apresentar informações temporais em todos os pontos do circuito e apontar as possíveis violações (Figura \ref{fig:STA}). Essas informações são utilizadas para avaliar se o projeto sob verificação pode operar na velocidade estipulada, ou seja, se o circuito final poderá funcionar com segurança na frequência de relógio escolhida, sem que existam violações nas restrições de projeto.

O fluxo básico de uma ferramenta de análise de \textit{timing} é:

\begin{enumerate}
\item \textbf{Leitura dos arquivos de entrada:} Nesta etapa, os arquivos referentes às bibliotecas de célula, descrição do circuito juntamente com as restrições do projeto são lidos e suas informações são armazenadas em estruturas de dados, que serão consultadas na geração do modelo de grafo e na atualização das informações temporais;

\item \textbf{Geração do grafo de \textit{timing}:} Responsável por implementar o modelo de grafo de \textit{timing}. As estruturas de dados utilizadas na implementação do modelo de grafo têm impacto direto no desempenho da ferramenta de \textit{timing}.

\item \label{enum:etapa_sta} \textbf{Atualização de informações temporais: } Etapa onde a propagação dos atrasos através dos \textit{timing arcs}, bem como a avaliação do cumprimento ou não das restrições de desempenho são realizados. 
\end{enumerate}

Na Seção \ref{sec:representacao_circuitos_sta} será apresentado o modelo de grafo utilizado para modelar os circuitos digitais na análise de \textit{timing}. A Seção \ref{sec:calculo_desempenho} mostrará a nomenclatura utilizada para as diversas informações temporais relevantes na análise de \textit{timing} estática. Finalmente, as informações particulares sobre a implementação da ferramenta construída neste trabalho serão apresentadas na Seção \ref{sec:implementacao_sta}. 

\section{Representação de Circuitos Digitais}
\label{sec:representacao_circuitos_sta}

\begin{figure}[ht]
\begin{center}
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/exemplo_circuito_simple.pdf}
\label{fig:exemplo_circuito_simple}
}
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/exemplo_grafo_simple.pdf}
\label{fig:exemplo_grafo_simple}
}
\caption{(a) Circuito \textit{simple} retirado do banco de \textit{benchmarks} da competição de \textit{sizing} do ISPD; (b) Grafo correspondente ao circuito da letra (a).}
\label{fig:exemplo_simple_circuito_grafo}
\end{center}
\end{figure}

Um circuito combinacional pode ser representado por um grafo de \textit{timing}. Neste grafo, as portas lógicas e os pinos de entrada e saídas primárias são os vértices e as interconexões são as arestas, como mostrado na Figura \ref{fig:exemplo_simple_circuito_grafo} \citacaoAzul{BhaskerChadha09}.




%Um par de vértices, $v_i$ e $v_j \in V$ são conectados por uma aresta direcionada $a(v_i, v_j) \in E$ se existe uma interconexão da saída do elemento representado pelo vértice $v_i$ para a entrada do elemento representado pelo vértice $v_j$. Dois vértices especiais, fonte (\textit{source}) e terminal (\textit{sink}), juntamente de suas arestas,  são inseridos antes das entradas e depois das saídas primárias, respectivamente, a fim de fornecer ao grafo, um único ponto de entrada e de saída.
%
%Um exemplo de circuito e seu grafo correspondente é ilustrado nas Figuras \ref{fig:exemplo_circuito_simple} e \ref{fig:exemplo_grafo_simple}, em que as cores utilizadas para representar as entradas primárias, células combinacionais, células sequenciais e saídas primárias são respectivamente: azul, laranja, amarelo e verde. Note que neste caso, a entrada primária de \textit{clock} e sua interconexão não são representados no modelo de grafo, visto que neste trabalho, a abordagem será restringida a análise de timing em circuitos combinacionais, ou seja, não serão considerados tempos de \textit{setup} e \textit{hold} nas células sequenciais.

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\linewidth]{imagens/subcircuitos.pdf}
\caption{Grafo de \textit{timing} dividido em dois sub-circuitos devido à existência de uma célula sequencial.}
\label{fig:subcircuitos}
\end{center}
\end{figure}

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\linewidth]{imagens/grafo_refinado.pdf}
\caption{Grafo de \textit{timing} com célula sequencial atuando como entrada e saída primária do circuito.}
\label{fig:grafo_refinado}
\end{center}
\end{figure}

Um circuito que consiste de células combinacionais e sequenciais (\textit{flip-flops} e \textit{latches}) pode ser representado como um conjunto de blocos combinacionais, divididos pelos \textit{latches} (Figura \ref{fig:subcircuitos}). Assim, a entrada de uma célula sequencial pode ser tratada como uma saída primária do circuito, e a saída dessa pode ser tratada como uma entrada primária de outro circuito (Figura \ref{fig:grafo_refinado}).

Em um contexto de projeto com o fluxo \textit{standard cell}, é interessante que o grafo modele também os \textit{timing arcs} das portas lógicas. Assim, alternativamente, os vértices do grafo de \textit{timing} representam os pinos de entrada e saída das portas lógicas, entradas e saídas primárias e as arestas representam os \textit{timing arcs} e as interconexões. Um grafo representando o modelo escolhido pode ser visualizado na Figura \ref{fig:grafo_timing_points}.


		 % Um circuito combinacional pode ser representado como um grafo direcionado $G(V, A)$, onde em $V$, o conjunto de vértices, são encontrados os pinos do circuito, e nas arestas ($E$), a união de dois conjuntos: as interconexões, denotado pela letra $I$, e os arcos de \textit{timing}, neste caso denominado $A$.

		A nomenclatura usada no grafo direcionado $G(V, E)$ deste segundo modelo, adotado no presente trabalho, é a seguinte:

%%% SIMBOLOS
\simbolo{$G(V, E)$}{ \\Grafo de \textit{timing}}
\simbolo{$V$}{\{ $v_i | v_i$ é um \textit{timing point} (pino de \textit{timing}), que pode ser a entrada ou saída de uma porta lógica, aqui referenciado como pino. Um \textit{timing point} pode também representar uma entrada ou saída primária do circuito. \}}
\simbolo{$I$}{\{ $(v_i, v_j) | v_i, v_j \in V$ e $(v_i, v_j)$ é uma interconexão do circuito, que conecta $v_i$ em $v_j$. $v_i$ é um pino de saída de uma porta lógica ou uma entrada primária, e $v_j$ pode ser a entrada de uma porta lógica ou uma saída primária. \}}
\simbolo{$A$}{\{ $(v_i, v_j) | v_i, v_j \in V$ e $(v_i, v_j)$ é um \textit{timing arc}. Portanto, $v_i$ e $v_j$ são pinos de entrada e saída (respectivamente) de uma mesma porta lógica. \}}
\simbolo{$E$}{I $\cup$ A}
%%%

\begin{itemize}

\item V  = \{ $v_i | v_i$ é um \textit{timing point} (pino de \textit{timing}), que pode ser a entrada ou saída de uma porta lógica, aqui referenciado como pino. Um \textit{timing point} pode também representar uma entrada ou saída primária do circuito. \}

\item I = \{ $(v_i, v_j) | v_i, v_j \in V$ e $(v_i, v_j)$ é uma interconexão do circuito, que conecta $v_i$ em $v_j$. $v_i$ é um pino de saída de uma porta lógica ou uma entrada primária, e $v_j$ pode ser a entrada de uma porta lógica ou uma saída primária. \}

\item A = \{ $(v_i, v_j) | v_i, v_j \in V$ e $(v_i, v_j)$ é um \textit{timing arc}. Portanto, $v_i$ e $v_j$ são pinos de entrada e saída (respectivamente) de uma mesma porta lógica. \}

\item Por fim, o conjunto das arestas E = I $\cup$ A.

\end{itemize}

\begin{figure}[H]
\begin{center}% TRIM = L D R U
\includegraphics[width=\linewidth]{imagens/grafo_timing_points.pdf}
% \includegraphics{sta.png}
\caption{Grafo de \textit{timing} com representação dos \textit{timing points}, \textit{timing arcs} e interconexões.}
\label{fig:grafo_timing_points}
\end{center}
\end{figure}

Nos vértices, ou \textit{timing points}, são armazenadas as informações temporais para os pinos do circuito, tais como os \textit{arrival times}, \textit{slews} e \textit{slacks} que serão apresentadas na Seção \ref{sec:calculo_desempenho}.

	
		
\section{Cálculo do Pior Atraso do Circuito}
\label{sec:calculo_desempenho}

\abreviatura{PERT}{Program Evaluation and Review Technique}
\abreviatura{CPM}{Critical Path Method}
O cálculo do pior atraso do circuito é realizado propagando os \textit{arrival times} (tempos de chegada) das portas lógicas em ordem topológica através de um método conhecido como \textit{PERT/CPM (Program Evaluation and Review Technique / Critical Path Method)}. Para o entendimento das políticas de propagação dos atrasos na avaliação do desempenho de um circuito, os termos a seguir são importantes:

\begin{itemize}

\item \textbf{Caminho: } uma sequência de vértices (\textit{timing points}) tal que, para cada um de seus vértices há uma aresta (\textit{timing arc} ou interconexão) para o próximo vértice da sequência. O primeiro \textit{timing point} da sequência é uma entrada primária e o último é uma saída primária;

%%% SIMBOLOS
\simbolo{$inputs(i)$}{ \\Conjunto de \textit{timing points} que se ligam com $v_i$ através de um \textit{timing arc}. Todo $v_j \in input(i)$ é necessariamente um pino de entrada de uma porta lógica, e $v_i$ é um pino de saída}
\simbolo{$a_i$}{\textit{arrival time}, ou tempo de chegada no pino $v_i$. O \textit{arrival time} é definido pelo atraso do caminho parcial que inicia em uma entrada primária e termina em $v_i$}
\simbolo{$slew_i$}{O \textit{slew} no pino $v_i$;}
\simbolo{$d_{j \to i}$}{O \textit{delay} do \textit{timing arc} que vai do pino $v_j$ até o pino $v_i$}
\simbolo{$slew_{j \to i}$}{\\ O \textit{slew} do \textit{timing arc} que vai do pino $v_j$ até o pino $v_i$}
\simbolo{$iD_{i \to k}$}{O atraso de propagação na interconexão que liga o pino $v_i$ até o pino $v_k$. No modelo de capacitância concentrada, $iD_{i \to k} = 0$}
\simbolo{$iS_{i \to k}$}{Degradação do \textit{slew} através da interconexão que liga $v_i$ em $v_k$}
\simbolo{$fanouts(i)$}{ \\Conjunto dos pinos que são destino da interconexão para qual $v_i$ é \textit{driver}}
\simbolo{$r_i$}{É o \textit{required time} no \textit{timing point} $v_i$. O \textit{required time} é o tempo máximo que o valor de $a_i$ pode assumir para que a restrição de desempenho seja respeitada. Se $v_i$ é uma saída primária do circuito, então $r_i = T$, onde $f = \frac{1}{T}$ é a frequência mínima de operação do circuito digital}
\simbolo{$slack_i$}{Folga de tempo no ponto $v_i$, ou seja, quanto o \textit{arrival time} pode atrasar neste ponto, de modo que o período máximo continue sendo respeitado. Se em um determinado ponto do circuito o \textit{slack} é negativo, então o caminho em questão está violando a restrição de atraso máximo do sistema}
%%%

\item \textbf{$inputs(i)$}: conjunto de \textit{timing points} que se ligam com $v_i$ através de um \textit{timing arc}. Todo $v_j \in input(i)$ é necessariamente um pino de entrada de uma porta lógica, e $v_i$ é um pino de saída;

\item \textbf{$a_i$}: \textit{arrival time}, ou tempo de chegada no pino $v_i$. O \textit{arrival time} é definido pelo atraso do caminho parcial que inicia em uma entrada primária e termina em $v_i$;

\item \textbf{$slew_i$}: o \textit{slew} no pino $v_i$;

\item \textbf{$d_{j \to i}$}: o \textit{delay} do \textit{timing arc} que vai do pino $v_j$ até o pino $v_i$;

\item \textbf{$slew_{j \to i}$}: o \textit{slew} do \textit{timing arc} que vai do pino $v_j$ até o pino $v_i$;

\item \textbf{$iD_{i \to k}$}: o atraso de propagação na interconexão que liga o pino $v_i$ até o pino $v_k$. No modelo de capacitância concentrada, $iD_{i \to k} = 0$;

\item \textbf{$iS_{i \to k}$}: degradação do \textit{slew} através da interconexão que liga $v_i$ em $v_k$;

\item \textbf{$fanouts(i)$}: conjunto dos pinos que são destino da interconexão para qual $v_i$ é \textit{driver};

\item \textbf{$r_i$}: é o \textit{required time} no \textit{timing point} $v_i$. O \textit{required time} é o tempo máximo que o valor de $a_i$ pode assumir para que a restrição de desempenho seja respeitada. Se $v_i$ é uma saída primária do circuito, então $r_i = T$, onde $f = \frac{1}{T}$ é a frequência mínima de operação do circuito digital;

\item \textbf{$slack_i$}: folga de tempo no ponto $v_i$, ou seja, quanto o \textit{arrival time} pode atrasar neste ponto, de modo que o período máximo continue sendo respeitado. Se em um determinado ponto do circuito o \textit{slack} é negativo, então o caminho em questão está violando a restrição de atraso máximo do sistema. 
\end{itemize}
		
Na análise de \textit{timing} estática, os piores atrasos de cada porta lógica são propagados visitando-se o grafo direcionado em ordem topológica. Para cada $v_i \in V$ que são pinos de saída de portas lógicas, os \textit{arrival times}, bem como os \textit{slews} são determinados de modo a respeitar as seguintes restrições:

\begin{equation}
a_i = \max_{\forall v_j \in inputs(i)}(a_j + d_{j \to i}) \label{eq:arrival_saida}
\end{equation}

\begin{equation}
slew_i = \max_{\forall v_j \in inputs(i)}(slew_{j \to i}) \label{eq:slew_saida}
\end{equation}

Se $v_i \in V$ é um pino de entrada de uma porta lógica e $v_j \in V$ é o \textit{driver} da interconexão que conecta $v_j$ em $v_i$, o \textit{arrival time} e o \textit{slew} em $v_i$ são definidos por:

\begin{equation}
a_i = a_j + iD_{j \to i} \label{eq:arrival_interconexao}
\end{equation}

\begin{equation}
slew_i = slew_j + iS_{j \to i} \label{eq:slew_interconexao}
\end{equation}

Após a propagação dos \textit{arrival times} em todos os pinos, é necessário realizar a propagação dos tempos requeridos, o que é feito percorrendo-se o grafo em ordem topológica reversa, a fim de obterem-se os valores dos \textit{slacks}. Em um pino de saída $v_i$ de uma porta lógica, o tempo requerido pode ser obtido facilmente, observando o menor dos tempos requeridos dentre os seus \textit{fanouts} e suas interconexões, ou seja:

\begin{equation}
r_i = \min_{\forall v_j \in fanouts(i)}(r_j - iD_{i \to j}) \label{eq:req_out}
\end{equation}

Para se propagar o \textit{required time} do pino $v_j$ de saída de uma porta lógica para uma entrada $v_i$, utiliza-se o valor de \textit{delay} do arco que liga $v_i$ em $v_j$, o qual já foi calculado previamente:

\begin{equation}
r_i = r_j - d_{i \to j}  \label{eq:req_in}
\end{equation}

A partir dos \textit{required times} e \textit{arrival times}, podemos determinar os \textit{slacks} nos  diversos pontos do circuito, através da equação:

\begin{equation}
slack_i = r_i - a_i  \label{eq:slack}
\end{equation}

Se em algum ponto $v_i$, $slack_i = 0$, então $v_i$ se encontra em um caminho crítico. Se $slack_i < 0$, então $v_i$ se encontra em um caminho que viola a restrição de desempenho.

O \textbf{pior slack} é definido como o menor valor de \textit{slack} entre as saídas primárias. O valor \textbf{total de slack negativo} é o somatório dos módulos dos \textit{slacks} negativos das saídas primárias.

\section{Implementação da Ferramenta de STA}
	\label{sec:implementacao_sta}
	Esta seção apresentará as estratégias utilizadas para o desenvolvimento da ferramenta de análise de \textit{timing}. Serão ilustradas as principais estruturas de dados, modelos de grafo, e serão apresentados também os algoritmos implementados na ferramenta desenvolvida.

	\subsection{O Modelo de Grafo Adotado}

As estruturas de dados utilizadas para armazenar os elementos do grafo são essencialmente listas ordenadas topologicamente. Em uma lista ordenada topologicamente, dado um elemento $i$, à esquerda necessariamente se encontram os elementos de mesmo ou menor nível lógico, e à direita, de nível igual ou maior, como mostrado na Figura \ref{fig:grafo_lista_nivel_logico}. Da mesma maneira, os \textit{timing arcs} e as interconexões também são ordenados topologicamente, em suas respectivas listas. Com essa escolha, o algoritmo de análise de \textit{timing} estática passa a ser apenas de uma varredura em ordem, na lista de \textit{timing points}, atualizando a informação de \textit{timing} acumulada para cada vértice do grafo.

		\begin{figure}[ht]
		\begin{center}% TRIM = L D R U
		\includegraphics[width=\linewidth]{imagens/grafo_lista_nivel_logico.pdf}
		\caption{Na lista ordenada, observando o elemento \textit{u1:o}, os elementos de menor ou de igual  nível lógico (\textit{fonte, inp1, inp2, f1:q, u1:a, u1:b, u2:a}) se encontram à esquerda, e os de maior ou igual (\textit{u2:o, f1:d, out, terminal}) se encontram à direita.}
		\label{fig:grafo_lista_nivel_logico}
		\end{center}
		\end{figure}

	% , onde V é o conjunto dos pinos do circuito, ou \textit{timing points}. Um par de vértices, ou pinos, $v_i$ e $v_j \in V$, são conectados por uma aresta direcionada $(v_i,v_j) \in A$ se existe uma interconexão que liga $v_i$ em $v_j$, sendo que $v_i$ é um pino de saída de uma porta lógica e $v_j$ é o pino de entrada de outra porta lógica.

\subsection{Algoritmo de Análise de \textit{Timing} Estática}

Com o modelo de grafo definido e implementado em suas devidas estruturas de dados, a análise de \textit{timing} estática é realizada atualizando as informações de \textit{timing} de cada nodo do grafo de \textit{timing}, em ordem topológica, como mostrado no algoritmo \ref{algo:sta}.

\begin{algorithm}[ht]
\Entrada{Grafo de \textit{timing} $G(V, E)$}
\Saida{Informações de \textit{timing} para os elementos do grafo (\textit{timing points}, interconexões e \textit{timing arcs})}



\ParaTodo{ $v_i \in V$ em ordem topológica}{
	\uSe{$v_i$ é um pino de entrada}
	{
		$C_{eff} \gets calcular\_C_{eff}()$; \label{lin:calcular_ceff}\\ 
		$d_{i \to o}	 \gets delay\_biblioteca(s_i, C_{eff})$; \label{lin:delay}\\ 
		$slew_{i \to o}	 \gets slew\_biblioteca(slew_i, C_{eff})$; \label{lin:slew}\\ 
		$propagar\_atrasos()$; \label{lin:propaga}
	}
	\SenaoSe{$v_i$ é um pino de saída ou é uma entrada primária}
	{
		$propagar\_para\_fanouts()$;\label{lin:propaga_fanouts}
	}
}
\ParaTodo{ cada $v_i \in V$ em ordem topológica reversa}{
	$atualiza\_folgas(v_i)$;
}
\caption{Análise de \textit{timing} estática.}
\label{algo:sta}
\end{algorithm}

No algoritmo \ref{algo:sta} é apresentada a rotina de análise de \textit{timing}. Os vértices são processados topologicamente, propagando os atrasos calculados de cada \textit{timing arc} das portas lógicas para suas saídas.

Para os pinos de entrada das portas lógicas, o procedimento realizado compreende da Linha \ref{lin:calcular_ceff} até a Linha \ref{lin:propaga}. Na Linha \ref{lin:calcular_ceff} é realizado o cálculo da capacitância efetiva, que posteriormente é utilizada para se obter os valores de \textit{delay} e \textit{slew} nos arcos que partem de $v_i$ (Linhas \ref{lin:delay} e \ref{lin:slew}). A seguir, na Linha \ref{lin:propaga}, representada pela rotina $propagar\_atrasos()$, os \textit{arrival times} e \textit{slews} são propagados para o pino de saída utilizando as Equações \ref{eq:arrival_saida} e \ref{eq:slew_saida}, respectivamente.

Já para os pinos de saída, a rotina $propagar\_para\_fanouts()$ é executada, e corresponde à propagação dos \textit{arrival times} e \textit{slews} através das interconexões, utilizando as Equações \ref{eq:arrival_interconexao} e \ref{eq:slew_interconexao}.

Após todos os \textit{arrival times} serem calculados, as folgas são obtidas propagando-se os \textit{required times} em ordem topológica reversa, como foi apresentado na Seção \ref{sec:calculo_desempenho} pelas Equações \ref{eq:req_out}, \ref{eq:req_in} e \ref{eq:slack}, correspondendo ao procedimento $atualiza\_folgas()$.


\chapter{Experimentos}
\label{cap:experimentos}



Esse capítulo tem por objetivo descrever os experimentos realizados neste trabalho e apresentar os resultados obtidos.

Na Seção \ref{sec:metodologia} será apresentada a metodologia e infraestrutura utilizadas para a realização dos experimentos.

Na Seção \ref{sec:validacao_lumped} é apresentado o primeiro experimento, que trata da validação da ferramenta perante o \textit{PrimeTime}, utilizando o modelo de interconexões de capacitância concentrada.

Na Seção \ref{sec:sta_industrial} será apresentada a maneira como o \textit{PrimeTime} modela o circuito, e como as informações de \textit{timing} são calculadas.

E por fim, a Seção \ref{sec:validacao_ceff} tem por objetivo mostrar os resultados obtidos com a técnica de cálculo de capacitância efetiva e degradação do \textit{slew} implementadas neste trabalho.
A organização dos experimentos realizados a fim de validar a ferramenta pode ser observada na Tabela \ref{tab:tec}.

\begin{table}[ht]
\footnotesize
	\begin{tabularx}{\textwidth}{@{\extracolsep{\fill} }cccc}
		\toprule
		\multirow{2}{*}{\textit{Driver}}	& \multicolumn{2}{c}{Interconexão}						& \multirow{2}{*}{Tabela}					\\
		\cmidrule(r){2-3}
		~								& Atraso					& Degradação do \textit{Slew}	& ~											\\
		\midrule
		$C_{total}$                 		& \textbf{SEM}			& \textbf{SEM}					& \ref{tab:lumped_capacitance_vs_primetime}	\\
		$C_{eff}$                   		& Elmore ($C_{eff}$)		& \citacaoAzul{PURI02}			& \ref{tab:ceff_elmore_slew}					\\
		$C_{eff}$                 		& Elmore ($C_{eff}$)		&  \textbf{SEM}					& \ref{tab:ceff_elmore_no_slew}				\\
		$C_{total}$                 		& Elmore ($C_{total}$)	& \citacaoAzul{PURI02}			& \ref{tab:lump_elmore_slew}					\\ 
		\bottomrule
	\end{tabularx}
	\caption{Técnicas validadas nos experimentos e as respectivas tabelas que apresentam os resultados obtidos.}
	\label{tab:tec}
\end{table}



\section{Metodologia e Infraestrutura Experimental}
\label{sec:metodologia}
%\afazer{A COMPLETAR}

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/fluxo_validacao.pdf}
\caption{Fluxo utilizado na validação da ferramenta implementada neste trabalho perante a ferramenta industrial \textit{PrimeTime}.}
\label{fig:fluxo_validacao}
\end{center}
\end{figure}

Para realizar a avaliação das técnicas abordadas neste trabalho, uma ferramenta para análise de \textit{timing} na linguagem de programação C++ foi implementada. A ferramenta realiza a análise de \textit{timing} e considera dois possíveis modelos de interconexão: o modelo da capacitância concentrada e o modelo RC concentrado.

Como parte dos experimentos é realizada comparando as informações calculadas pela ferramenta implementada com as informações reportadas pelo \textit{PrimeTime}, o erro percentual ($EP_t$) e o erro médio percentual absoluto ($EMPA$) (Equações \ref{eq:ep} e \ref{eq:empa}) foram adotados como métricas para estimar a qualidade das informações de \textit{timing} reportadas pela ferramenta implementada neste trabalho (Figura \ref{fig:fluxo_validacao}).

\begin{equation}
\label{eq:ep}
EP_t = \frac{(A_t - P_t)}{A_t} \times 100
\end{equation}

\begin{equation}
\label{eq:empa}
EMPA = \frac{\sum_{t=1}^n |EP_t|}{n}
\end{equation}

O erro percentual é calculado para cada uma das informações comparadas com o \textit{PrimeTime} utilizando a equação \ref{eq:ep}, sendo que $A_t$ é a informação obtida pelo \textit{PrimeTime} e $P_t$ é a informação calculada pela ferramenta implementada. Tais informações usadas para fim de validação da ferramenta foram:
\abreviatura{TNS}{Total Negative Slack}
\abreviatura{PO}{Primary Output}


\begin{itemize}
\item \textbf{\textit{TNS (Total Negative Slack)}: } O somatório de \textit{slack} negativo nas saídas primárias.

\item \textbf{\textit{Violating POs: }} Número de saídas primárias violando a restrição de desempenho mínimo.

\item \textbf{\textit{Runtime (s): }} Tempo de execução, em segundos, para realizar uma análise de \textit{timing} em um circuito, desconsiderando o tempo constante de inicialização da ferramenta.

\item \textbf{\textit{Critical Path: }} Valor do caminho crítico do circuito.
\end{itemize}

Os resultados dos experimentos serão apresentados posteriormente por meio de gráficos, tabelas e histogramas.

Este trabalho utilizou como base a infraestrutura disponibilizada pela competição de \textit{gate sizing} discreto do ISPD de 2013, a qual fornece:

\begin{itemize}

\item Um conjunto de 8 circuitos da competição do ISPD de 2013:
	\begin{enumerate}
	\item \textbf{$usb\_phy$}: com 511 células combinacionais, 98 células sequenciais, 15 entradas e 19 saídas primárias;
	\item \textbf{$pci\_bridge32$}: com 27316 células combinacionais, 3359 células sequenciais, 160 entradas e 201 saídas primárias;
	\item \textbf{$fft$}: com 30297 células combinacionais, 1984 células sequenciais, 1026 entradas e 1026 saídas primárias;
	\item \textbf{$cordic$}: com 40371 células combinacionais, 1230 células sequenciais, 34 entradas e 64 saídas primárias;
	\item \textbf{$des\_perf$}: com 103842 células combinacionais, 8802 células sequenciais, 234 entradas e 201 saídas primárias;
	\item \textbf{$edit\_dist$}: com 125000 células combinacionais, 5661 células sequenciais, 2562 entradas e 12 saídas primárias;
	\item \textbf{$matrix\_mult$}: com 30297 células combinacionais, 1984 células sequenciais, 3202 entradas e 1600 saídas primárias;
	\item \textbf{$netcard$}: com 884427 células combinacionais, 97831 células sequenciais, 1836 entradas e 10 saídas primárias.
	\end{enumerate}

\item Uma biblioteca \textit{standard cell} realista, composta por onze células combinacionais de diversas funções lógicas e um célula sequencial;

\item Uma ferramenta de análise de \textit{timing} estática PrimeTime \textregistered \ da empresa \citacaoInline{PrimeTime12}  para comparação de resultados;
\end{itemize}

Os circuitos são compostos por descrições no formato Verilog, capacitâncias parasitas e resistências descritas no formato IEEE SPEF (\textit{Standard Parasitic Exchange Format}) \citacaoAzul{IEEE99}, e restrições de \textit{timing} descritas no formato SDC (\textit{Synopsys Design Constraints}).



	\section{Validação do Modelo de Capacitância Concentrada Perante Ferramenta Industrial}
	\label{sec:validacao_lumped}

\abreviatura{RAM}{Random-Access Memory}
\abreviatura{GB}{Gigabyte}


Este experimento tem por objetivo validar a ferramenta de \textit{STA} desenvolvida perante a ferramenta industrial \textit{PrimeTime}, utilizando a abordagem de capacitância concentrada para modelar as interconexões. Para uma comparação justa, a ferramenta industrial foi também configurada para utilizar este modelo. Para tanto, utilizou-se um computador \textit{desktop} com processador \textit{Intel Core i7}, de 4 núcleos, e 4GB de \textit{RAM}, e os resultados deste experimento são apresentados na Tabela \ref{tab:lumped_capacitance_vs_primetime}.



\begin{table}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/comparacoes/lumped_capacitance_vs_primetime.pdf}
\caption{Comparação das informações de \textit{timing} calculadas pela ferramenta implementada \textit{versus} informações fornecidas pelo \textit{PrimeTime}, utilizando o modelo de interconexões de capacitância concentrada.}
\label{tab:lumped_capacitance_vs_primetime}
\end{center}
\end{table}

\abreviatura{EMPA}{Erro Médio Percentual Absoluto}


As células marcadas correspondem aos valores que são menores que os obtidos na ferramenta comercial. A penúltima linha apresenta a média dos valores calculados para cada coluna da tabela. A última linha mostra o $EMPA$ para cada uma das informações mostradas nas colunas. Os valores de $EMPA$ valendo $0,00\%$ indicam que a ferramenta calcula os mesmos valores que a ferramenta industrial para as informações comparadas. A média de \textit{runtime} obtida é $6,92$ vezes menor que a média da ferramenta industrial, sendo $50,05$ vezes menor para os 7 primeiros circuitos (excluindo o $netcard$). No circuito $usb\_phy$, a diferença de \textit{runtime} é de $20$ vezes e nos outros circuitos (exceto o $netcard$) a diferença tem valor médio de $52,71$ vezes com baixo desvio padrão ($6,48$).

\section{Análise de \textit{Timing} Estática em Ferramenta Industrial}
\label{sec:sta_industrial}
	
Esta seção tem por objetivo apresentar o modelo (Figura \ref{fig:modelagem_primetime}) utilizado para cálculo do desempenho na ferramenta industrial \textit{PrimeTime} e apresentar algumas informações de \textit{timing} relevantes, obtidas para cada circuito da competição de \textit{sizing} do ISPD.

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/modelo_primetime.png} 
\caption{Modelagem utilizada no \textit{PrimeTime} para o \textit{driver}, interconexão e destinos. Obtida de \citacaoAzul{Ptug13}.}
\label{fig:modelagem_primetime}
\end{center}
\end{figure}


\subsection{Modelagem de \textit{Driver} (\textit{Driver model})}

No \textit{PrimeTime}, o \textit{driver} é modelado utilizando uma rampa de tensão em série com um resistor (um modelo Thèvenin). O resistor ajuda a suavizar a rampa de tensão, para que a forma de onda resultante seja similar à forma de onda do \textit{driver} real, que está conectado na interconexão.

De acordo com \citacaoAzul{Ptug13}, o modelo de \textit{driver} tem três parâmetros: 
\begin{itemize}
\item A resistência do \textit{driver} $R_d$;
\item O tempo de início da rampa $t_Z$;
\item A duração da rampa $\Delta t$.
\end{itemize}

 O \textit{PrimeTime} escolhe os parâmetros de modo que a forma de onda de saída seja o mais próximo possível da simulação. O modelo de \textit{driver} simplificado é construído para cada \textit{timing arc} de cada porta lógica do circuito.

\subsection{Modelagem do Destino (\textit{Receiver model})}
Cada destino da interconexão é representado como um valor de capacitância, que corresponde à capacitância do pino em que a interconexão está ligada.

\subsection{Modelagem da Interconexão (\textit{Reduced-order network model})}

Um modelo reduzido de interconexão é uma representação simplificada de uma interconexão, com as mesmas características de resposta da interconexão original, a qual pode ter centenas de capacitâncias e resistências. O \textit{PrimeTime} utiliza a redução de Arnoldi \citacaoAzul{Odabasioglu1997} \citacaoAzul{Silveira1999} para criar um modelo reduzido. Através do modelo reduzido, a ferramenta escolhe valores para a $C_{eff}$, de modo que o atraso do \textit{driver} seja igual ao atraso do \textit{driver} ligado à interconexão original. Por falta de fontes na bibliografia, não foi possível implementar este método de ajuste da $C_{eff}$, impossibilitando uma comparação mais justa. Desta forma, não foi possível identificar o algoritmo para o cálculo do atraso das interconexões no \textit{PrimeTime}.

\subsection{Resultados Obtidos}

\begin{table}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/comparacoes/primetime.pdf}
\caption{Valores obtidos pelo \textit{PrimeTime} no \textit{benchmark} experimental utilizado neste trabalho.}
\label{tab:comparacoes_primetime}
\end{center}
\end{table}

A Tabela \ref{tab:comparacoes_primetime} mostra os valores obtidos pelo \textit{PrimeTime} aplicando a STA na infraestrutura experimental. A última linha da tabela mostra as médias para cada informação obtida.

\section{Validação da Técnica Implementada Perante Ferramenta Industrial}
\label{sec:validacao_ceff}
	
Esta seção tem por objetivo comparar a qualidade das informações de \textit{timing} obtidas pela ferramenta de análise de \textit{timing} implementada neste trabalho com  as informações reportadas pelo \textit{PrimeTime}. Utilizando as técnicas apresentadas na Seção \ref{sec:calculo_ceff_degradacao} (i. e., capacitância efetiva, atraso de interconexões e degradação de \textit{slew}), a análise de \textit{timing} estática foi aplicada nos circuitos de teste e suas soluções foram comparadas com as fornecidas pela ferramenta industrial. Tal comparação foi realizada com base nas métricas apresentada na Seção \ref{sec:metodologia}. Os resultados deste experimento podem ser vistos na Tabela \ref{tab:ceff_elmore_slew}.

\begin{table}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/comparacoes/ceff_elmore_slew.pdf}
\caption{Valores obtidos pela ferramenta implementada neste trabalho nos circuitos da competição de \textit{sizing} do ISPD.}
\label{tab:ceff_elmore_slew}
\end{center}
\end{table}

A penúltima linha apresenta a média dos valores de cada coluna e a última linha apresenta o $EMPA$ para cada uma das informações em relação ao \textit{PrimeTime}, que foram apresentados na Tabela \ref{tab:comparacoes_primetime}. Com esse experimento, conclui-se que a ferramenta desenvolvida neste trabalho fornece informações de \textit{timing} próximas às reportadas pelo \textit{PrimeTime}\footnote{$EMPA = 8,21$ e $4,48$ para \textit{TNS} e \textit{critical path}, respectivamente.}, com um tempo de execução $17,02$ vezes menor.

As células marcadas apresentam os valores que são otimistas em relação do \textit{PrimeTime} (i. e., que são menores que os obtidos pelo \textit{PrimeTime}), correspondendo a 29 dos 36 valores obtidos.

O erro de menor valor absoluto para o \textit{TNS} é de $1,34\%$ e o de maior é $16,7\%$ nos circuitos $usb\_phy$ e $netcard$, respectivamente, sendo que no segundo, o erro reflete em uma aproximação otimista, e no primeiro, pessimista. 

Na média, a análise de \textit{timing} na ferramenta desenvolvida é otimista em relação ao \textit{PrimeTime}, de acordo com o grande número de células marcadas. É possível observar também que os maiores erros são obtidos nos maiores circuitos e os menores erros, nos menores circuitos.

\begin{table}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/comparacoes/lump_elmore_slew.pdf}
\caption{Experimentos utilizando o modelo capacitância concentrada para carga de saída dos \textit{drivers}, técnica de Elmore para computar os atrasos das interconexões, e degradação do \textit{slew} conforme apresentado no Capítulo \ref{cap:tecnica}.}
\label{tab:lump_elmore_slew}
\end{center}
\end{table}

No experimento mostrado na Tabela \ref{tab:lump_elmore_slew}, o modelo de capacitância concentrada foi utilizado para modelar a carga vista pelo \textit{driver}. Para o atraso das interconexões, a técnica de Elmore com capacitância concentrada foi utilizada. Já para a degradação do \textit{slew}, foi utilizada a técnica descrita no Capítulo \ref{cap:tecnica}. Como esperado, os modelos utilizados neste experimento refletem em uma aproximação pessimista para o atraso do circuito\footnote{Informação obtida do baixo número de células marcadas (total de 4, com exceção das células de \textit{runtime}).}, já que a técnica de Elmore pura\footnote{Sem utilizar a abordagem de capacitância efetiva.} foi aplicada no cálculo dos atrasos das interconexões. A técnica obteve $0,13\%$ e $311,79\%$ de erro para TNS nos circuitos $matrix\_mult$ e $netcard$, respectivamente. Já para \textit{critical path}, os erros obtidos vão de $1,94\%$ até $13,85\%$, nos circuitos $des\_perf$ e $usb\_phy$, respectivamente. 

\begin{table}[h!]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/comparacoes/ceff_elmore_no_slew.pdf}
\caption{Experimentos utilizando o modelo capacitância efetiva para carga de saída dos \textit{drivers}, técnica de Elmore utilizando as capacitâcias efetivas de cada nodo interno das interconexões, para computar seus atrasos. Neste experimento, a degradação do \textit{slew} não foi considerada.}
\label{tab:ceff_elmore_no_slew}
\end{center}
\end{table}


A importância do cálculo da degradação do \textit{slew} pode ser visualizado na Tabela \ref{tab:ceff_elmore_no_slew}. Os erros obtidos neste experimento ($40,80\%$ para TNS e $21,21\%$ para critical path) mostram resultados muito otimistas em relação ao \textit{PrimeTime},  quando a técnica apresentada no Capítulo \ref{cap:tecnica} é aplicada, sem considerar a degradação do \textit{slew} nos destinos das interconexões.

\subsection{Relação entre $C_{eff}$ e $C_{total}$}
\label{sec:ceff_ctotal}

\begin{table}[h]
%\begin{center}% TRIM = L D R U
\includegraphics[width=\linewidth]{imagens/ceff_ratio/ceff_ctotal_todos.pdf}
\caption{Relação $C_{eff} / C_{total}$ média por circuito.}
\label{tab:ceff_ctotal_todos}
\end{table}

Este experimento tem por objetivo justificar os baixos erros obtidos pelo experimento apresentado na Tabela \ref{tab:lump_elmore_slew}. Foram obtidas as relações $C_{eff}/C_{total}$ médias para todos os circuitos, os considerando em três configurações diferentes:
	\begin{itemize}
		\item \textbf{Min.: } configuração de menor consumo de \textit{leakage}\footnote{\textit{Leakage} se trata de uma parcela da potência estática que é dissipada pelos transistores \textit{CMOS} mesmo quando estão desligados.};
		\item \textbf{Normal: } configuração padrão, conforme descrita em \textit{verilog};
		\item \textbf{Max.: } configuração de maior consumo de \textit{leakage};
	\end{itemize}

Na Tabela \ref{tab:ceff_ctotal_todos}, observa-se que nos circuitos testados, o valor de $C_{eff}$ médio fica muito próximo do valor de $C_{total}$ na configuração de maior consumo de \textit{leakage}. Nessa configuração, as portas lógicas possuem maiores \textit{slews} em relação às configurações de menor \textit{leakage} e \textit{leakage} padrão. Por exemplo, no circuito $pci\_bridge$, a mudança da configuração \textit{Min.} para \textit{Max.} aumenta em 43\% o \textit{slew} médio do circuito, e no $matrix\_mult$, 93\%. Como $C_{eff} = C_1 + C_2 \times K$, sendo $K$ definido na Equação \ref{eq:shieldfactor}, o crescimento no valor do \textit{slew} implica no crescimento do valor $K$, fazendo com que $C_{eff}$ fique mais próxima de $C_1 + C_2$, que por sua vez, é o valor $C_{total}$.  Este experimento explica o baixo erro obtido ao utilizar-se o modelo de capacitância concentrada para estimar o valor da capacitância vista pelo \textit{driver} (Tabela \ref{tab:lump_elmore_slew}).

Foram obtidas também as relações $C_{eff}/C_{total}$ para todas as interconexões dos circuitos $pci\_bridge32$ e $matrix\_mult$ e os histogramas com as distribuições de frequências para estas relações são apresentados nas Figuras \ref{fig:pci_bridge32_resistance} e \ref{fig:matrix_mult_resistance}. No experimento apresentado na  Figura \ref{fig:pci_bridge32_resistance} são mostradas as relações $C_{eff}/C_{total}$ nas interconexões do circuito $pci\_bridge32$, divididas em três partes. Na primeira em verde, se encontram as frequências das relações $C_{eff}/C_{total}$ nas interconexões com menor valor de resistência; a segunda parte, em vermelho, mostra a distribuição das frequências nas interconexões com valor médio de resistência; e a última parte, em azul, mostra as frequências para a última parte das interconexões, ou seja, as com maior valor de resistência total. Note que na Figura \ref{fig:pci_bridge32_resistance_full} todos os valores de frequência são mostrados, e na Figura \ref{fig:pci_bridge32_resistance_zoom}, apenas os valores de frequência menores que 200 são mostrados. Este mesmo experimento foi também realizado para o circuito $matrix\_mult$ e seu resultado pode ser visualizado na Figura \ref{fig:matrix_mult_resistance}.

Analisando os histogramas apresentados nas Figuras \ref{fig:pci_bridge32_resistance} e \ref{fig:matrix_mult_resistance}, observa-se o impacto do efeito de \textit{resistive shielding}. Nas interconexões com menor valor resistivo, o valor de $C_{eff}$ é mais próximo de $C_{total}$ na maioria dos casos. Quanto maior for o valor de resistências das interconexões, maior o efeito de \textit{resistive shielding}, fazendo com que as relações $C_{eff}/C_{total}$ assumam mais valores menores que $1$.

\subsection{Erro de \textit{Arrival Times} nas Saídas Primárias}

\begin{figure}[ht]
%\begin{center}% TRIM = L D R U

\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/arrival_error/matrix_mult_puri.pdf}
}
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/arrival_error/pci_bridge32_puri.pdf}
}
\caption{Distribuição das frequências dos erros percentuais calculados nas saídas primárias dos circuitos: (a) $matrix\_mult$; (b) $pci\_bridge32$. Na primeira parte os erros foram calculados considerando a configuração de menor consumo de \textit{leakage}. Na segunda parte, considerando a configuração padrão. E na terceira, considerando a configuração de maior consumo de \textit{leakage}. $\mu$ e $\sigma$ representam a média e desvio padrão das amostras, respectivamente.}
\label{fig:arrival_error}
\end{figure}

Este experimento avalia os erros nos \textit{arrival times} obtidos pela ferramenta implementada neste trabalho em relação aos calculados pelo \textit{PrimeTime}, nos circuitos $pci\_bridge32$ e $matrix\_mult$. Este experimento complementa o experimento apresentado na Seção \ref{sec:ceff_ctotal} na escolha do modelo a ser utilizado para as interconexões.

Como observado na Tabela \ref{tab:ceff_ctotal_todos}, quando o circuito está na configuração de maior \textit{leakage}, o valor de $C_{eff}$ se aproxima de $C_{total}$ ($C_{eff} / C_{total} = 0.99$), possibilitando o uso da abordagem de capacitância concentrada para representar as interconexões, refletindo em um resultado semelhante ao da abordagem de capacitância efetiva, porém com um \textit{runtime} cerca de $3.5$ vezes menor. A distribuição das frequências dos erros percentuais obtidos neste experimento podem ser visualizados na Figura \ref{fig:arrival_error}.

\abreviatura{D2M}{Delay With 2 Moments}
\abreviatura{PERI}{Probability Distribution Function Extension for Ramp Inputs}


\citacaoInline{Markov13} realizaram um experimento semelhante comparando quatro técnicas para o cálculo do atraso das interconexões e duas para a degradação do \textit{slew}. No contexto de uma técnica de \textit{gate sizing}, a ferramenta de análise de \textit{timing} utilizada tem grande impacto no \textit{runtime} da otimização. Tal experimento influenciou na escolha das técnicas para atraso da interconexão e degradação do \textit{slew} (D2M \citacaoAzul{Alpert2000} e PERI \citacaoAzul{kashyap2002peri}, respectivamente).

\begin{figure}[ht]
%\begin{center}% TRIM = L D R U
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/experimentos/pci_bridge32_resistance_full.pdf}
\label{fig:pci_bridge32_resistance_full}
}
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/experimentos/pci_bridge32_resistance_zoom.pdf}
\label{fig:pci_bridge32_resistance_zoom}
}
\caption{Distribuição das frequências das relações $C_{eff}/C_{total}$ das interconexões do circuito $pci\_bridge32$. Na primeira parte, as frequências são das interconexões com menor valor de resistência total, na segunda parte, das com valor de resistência total médio, e na terceira, das com maiores valores de resistência total.}
\label{fig:pci_bridge32_resistance}

\end{figure}

\begin{figure}[ht]
%\begin{center}% TRIM = L D R U
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/experimentos/matrix_mult_resistance_full.pdf}
\label{fig:matrix_mult_resistance_full}
}
\subfigure[]
{
\includegraphics[width=\linewidth]{imagens/experimentos/matrix_mult_resistance_zoom.pdf}
\label{fig:matrix_mult_resistance_zoom}
}
\caption{Distribuição das frequências das relações $C_{eff}/C_{total}$ das interconexões do circuito $matrix\_mult$. Na primeira parte, as frequências são das interconexões com menor valor de resistência total, na segunda parte, das com valor de resistência total médio, e na terceira, das com maiores valores de resistência total.}
\label{fig:matrix_mult_resistance}

\end{figure}

\subsection{Nível Lógico \textit{versus} Erro Relativo}

Neste experimento os erros relativos percentuais dos \textit{arrival times} de saída de cada porta lógica dos circuitos $pci\_bridge32$ e $matrix\_mult$ em relação aos \textit{arrival times} reportados pelo \textit{PrimeTime} foram analisados ao decorrer dos níveis lógicos dos circuitos.

As Figuras \ref{fig:pci_bridge32_logic-level_x_relative-error} e \ref{fig:matrix_mult_logic-level_x_relative-error} mostram os erros distribuídos pelos níveis lógicos nos circuitos $pci\_bridge32$ e $matrix\_mult$, respectivamente. Em azul, estão apresentados os pontos de cada \textit{arrival time} de saída. Na curva em vermelho, são mostrados os erros para os \textit{arrival times} de saída das portas pertencentes ao caminho crítico. Na curva em verde, são mostrados os erros referentes às portas pertencentes ao caminho com o maior número de portas.

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/pci_bridge32_logic-level_x_relative-error.png}
\caption{Erro relativo dos \textit{arrival times} em relação aos resultados obtidos pelo \textit{PrimeTime}, ao decorrer dos níveis lógicos, no \textit{benchmark} $pci\_bridge32$. O \textit{arrival time} utilizado na comparação é o \textit{arrival time} no \textit{timing point} de saída de cada porta lógica. Em azul, cada ponto representa uma porta lógica. Em vermelho, é a curva referente às portas lógicas pertencentes ao caminho crítico. A curva em verde, é referente às portas lógicas pertencentes ao maior caminho, ou seja, ao caminho com maior número de portas.}
\label{fig:pci_bridge32_logic-level_x_relative-error}
\end{center}
\end{figure}

\begin{figure}[ht]
\begin{center}% TRIM = L D R U
\includegraphics[width=\textwidth]{imagens/matrix_mult_logic-level_x_relative-error.png}
\caption{Erro relativo dos \textit{arrival times} em relação aos resultados obtidos pelo \textit{PrimeTime}, ao decorrer dos níveis lógicos, no \textit{benchmark} $matrix\_mult$. O \textit{arrival time} utilizado na comparação é o \textit{arrival time} no \textit{timing point} de saída de cada porta lógica. Em azul, cada ponto representa uma porta lógica. Em vermelho, é a curva referente às portas lógicas pertencentes ao caminho crítico. A curva em verde, é referente às portas lógicas pertencentes ao maior caminho, ou seja, ao caminho com maior número de portas.}
\label{fig:matrix_mult_logic-level_x_relative-error}
\end{center}
\end{figure}

Ao analisar os gráficos das Figuras \ref{fig:pci_bridge32_logic-level_x_relative-error} e \ref{fig:matrix_mult_logic-level_x_relative-error}, observa-se que tanto os erros grandes, quanto os erros pequenos dos primeiros níveis lógicos, ao serem propagados, são estabilizados, convergindo para um número próximo de -7\%, o que se reflete também nos erros dos caminhos críticos e maiores caminhos.

\chapter{Conclusão}
\label{cap:conclusao}

Foram avaliados os impactos das interconexões no contexto da análise de \textit{timing} estática utilizando uma infraestrutura experimental realista.

A consideração do atraso das interconexões no fluxo \textit{standard cell} é de muita importância e a avaliação desses atrasos deve ser eficiente e precisa. Neste trabalho foi possível observar a importância da avaliação dos atrasos das interconexões e também, que a desconsideração da degradação do \textit{slew} através das interconexões pode obter atrasos muito otimistas para o circuito, acarretando erros de cerca de $20\%$ no valor do caminho crítico para os circuitos da competição de \textit{sizing} do ISPD.

A abordagem da capacitância efetiva para interconexões implica na consideração do efeito de \textit{resistive shielding}, o qual impacta na qualidade do cálculo do atraso do circuito. A ferramenta de análise de \textit{timing} desenvolvida neste trabalho implementa a técnica de \citacaoInline{PURI02} para o cálculo da capacitância efetiva, atraso das interconexões e degradação do \textit{slew}. Tal ferramenta apresentou ser cerca de \textbf{17,02 vezes mais rápida} que o \textit{PrimeTime}, obtendo resultados para \textit{TNS} e \textit{critical path} que subestimam em cerca de $8,85\%$ e $4,48\%$ respectivamente, os reportados pela ferramenta industrial.

A relação $C_{eff}/C_{total}$ nos circuitos da competição de \textit{sizing} do ISPD de 2013 mostrou-se na média, próxima de 1. A partir dessa informação, o modelo de capacitância concentrada para calcular o atraso dos \textit{drivers}, juntamente com a técnica de Elmore com $C_{total}$ e a técnica de \citacaoInline{PURI02} para degradação do \textit{slew} foi avaliada, apresentando estimativas pessimistas em $10,76\%$ para \textit{TNS} nos circuitos testados (exceto o $netcard$) e $6,48\%$ para \textit{critical path}, sendo que o tempo de execução é cerca de \textbf{3 vezes menor} que o da técnica considerando a $C_{eff}$.



\section{Trabalhos Futuros}
Diversos trabalhos futuros podem ser realizados a fim de complementar a ferramenta avaliada neste trabalho, tais como:
	
	\begin{itemize}
		\item Investigação detalhada dos erros obtidos pela técnica implementada neste trabalho, quando comparada à ferramenta industrial;
		
		\item Avaliação da eficiência da técnica implementada no contexto de uma técnica de otimização de fluxo \textit{standard cell}, como por exemplo, \textit{gate sizing};
		
		\item Avaliação da técnica implementada utilizando bibliotecas \textit{standard cell} e circuitos comerciais.
	\end{itemize}

 
 
 
% 	\section{Código Fonte em C++ da Ferramenta Desenvolvida}
%
% 		\lstinputlisting[label=timing_analysis.cpp,caption=timing\_analysis.cpp]{../implementacao/TimingAnalysis/src/timing_analysis.cpp}


%--------------------------------------------------------
% Elementos pós-textuais
\bibliography{Relatorio}

% \includepdf[pages=-]{artigo/sbc-template.pdf}


\end{document}
